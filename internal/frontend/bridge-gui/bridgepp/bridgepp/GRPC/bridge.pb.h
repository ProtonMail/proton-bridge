// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bridge.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bridge_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bridge_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bridge_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bridge_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bridge_2eproto;
namespace grpc {
class AddLogEntryRequest;
struct AddLogEntryRequestDefaultTypeInternal;
extern AddLogEntryRequestDefaultTypeInternal _AddLogEntryRequest_default_instance_;
class AddressChangedEvent;
struct AddressChangedEventDefaultTypeInternal;
extern AddressChangedEventDefaultTypeInternal _AddressChangedEvent_default_instance_;
class AddressChangedLogoutEvent;
struct AddressChangedLogoutEventDefaultTypeInternal;
extern AddressChangedLogoutEventDefaultTypeInternal _AddressChangedLogoutEvent_default_instance_;
class ApiCertIssueEvent;
struct ApiCertIssueEventDefaultTypeInternal;
extern ApiCertIssueEventDefaultTypeInternal _ApiCertIssueEvent_default_instance_;
class AppEvent;
struct AppEventDefaultTypeInternal;
extern AppEventDefaultTypeInternal _AppEvent_default_instance_;
class AvailableKeychainsResponse;
struct AvailableKeychainsResponseDefaultTypeInternal;
extern AvailableKeychainsResponseDefaultTypeInternal _AvailableKeychainsResponse_default_instance_;
class ChangeKeychainFinishedEvent;
struct ChangeKeychainFinishedEventDefaultTypeInternal;
extern ChangeKeychainFinishedEventDefaultTypeInternal _ChangeKeychainFinishedEvent_default_instance_;
class ChangeMailServerSettingsFinishedEvent;
struct ChangeMailServerSettingsFinishedEventDefaultTypeInternal;
extern ChangeMailServerSettingsFinishedEventDefaultTypeInternal _ChangeMailServerSettingsFinishedEvent_default_instance_;
class ConfigureAppleMailRequest;
struct ConfigureAppleMailRequestDefaultTypeInternal;
extern ConfigureAppleMailRequestDefaultTypeInternal _ConfigureAppleMailRequest_default_instance_;
class DiskCacheErrorEvent;
struct DiskCacheErrorEventDefaultTypeInternal;
extern DiskCacheErrorEventDefaultTypeInternal _DiskCacheErrorEvent_default_instance_;
class DiskCacheEvent;
struct DiskCacheEventDefaultTypeInternal;
extern DiskCacheEventDefaultTypeInternal _DiskCacheEvent_default_instance_;
class DiskCachePathChangeFinishedEvent;
struct DiskCachePathChangeFinishedEventDefaultTypeInternal;
extern DiskCachePathChangeFinishedEventDefaultTypeInternal _DiskCachePathChangeFinishedEvent_default_instance_;
class DiskCachePathChangedEvent;
struct DiskCachePathChangedEventDefaultTypeInternal;
extern DiskCachePathChangedEventDefaultTypeInternal _DiskCachePathChangedEvent_default_instance_;
class EventStreamRequest;
struct EventStreamRequestDefaultTypeInternal;
extern EventStreamRequestDefaultTypeInternal _EventStreamRequest_default_instance_;
class GenericErrorEvent;
struct GenericErrorEventDefaultTypeInternal;
extern GenericErrorEventDefaultTypeInternal _GenericErrorEvent_default_instance_;
class GuiReadyResponse;
struct GuiReadyResponseDefaultTypeInternal;
extern GuiReadyResponseDefaultTypeInternal _GuiReadyResponse_default_instance_;
class HasNoKeychainEvent;
struct HasNoKeychainEventDefaultTypeInternal;
extern HasNoKeychainEventDefaultTypeInternal _HasNoKeychainEvent_default_instance_;
class ImapLoginFailedEvent;
struct ImapLoginFailedEventDefaultTypeInternal;
extern ImapLoginFailedEventDefaultTypeInternal _ImapLoginFailedEvent_default_instance_;
class ImapSmtpSettings;
struct ImapSmtpSettingsDefaultTypeInternal;
extern ImapSmtpSettingsDefaultTypeInternal _ImapSmtpSettings_default_instance_;
class InternetStatusEvent;
struct InternetStatusEventDefaultTypeInternal;
extern InternetStatusEventDefaultTypeInternal _InternetStatusEvent_default_instance_;
class KeychainEvent;
struct KeychainEventDefaultTypeInternal;
extern KeychainEventDefaultTypeInternal _KeychainEvent_default_instance_;
class LoginAbortRequest;
struct LoginAbortRequestDefaultTypeInternal;
extern LoginAbortRequestDefaultTypeInternal _LoginAbortRequest_default_instance_;
class LoginErrorEvent;
struct LoginErrorEventDefaultTypeInternal;
extern LoginErrorEventDefaultTypeInternal _LoginErrorEvent_default_instance_;
class LoginEvent;
struct LoginEventDefaultTypeInternal;
extern LoginEventDefaultTypeInternal _LoginEvent_default_instance_;
class LoginFinishedEvent;
struct LoginFinishedEventDefaultTypeInternal;
extern LoginFinishedEventDefaultTypeInternal _LoginFinishedEvent_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginTfaRequestedEvent;
struct LoginTfaRequestedEventDefaultTypeInternal;
extern LoginTfaRequestedEventDefaultTypeInternal _LoginTfaRequestedEvent_default_instance_;
class LoginTwoPasswordsRequestedEvent;
struct LoginTwoPasswordsRequestedEventDefaultTypeInternal;
extern LoginTwoPasswordsRequestedEventDefaultTypeInternal _LoginTwoPasswordsRequestedEvent_default_instance_;
class MailEvent;
struct MailEventDefaultTypeInternal;
extern MailEventDefaultTypeInternal _MailEvent_default_instance_;
class MailServerSettingsChangedEvent;
struct MailServerSettingsChangedEventDefaultTypeInternal;
extern MailServerSettingsChangedEventDefaultTypeInternal _MailServerSettingsChangedEvent_default_instance_;
class MailServerSettingsErrorEvent;
struct MailServerSettingsErrorEventDefaultTypeInternal;
extern MailServerSettingsErrorEventDefaultTypeInternal _MailServerSettingsErrorEvent_default_instance_;
class MailServerSettingsEvent;
struct MailServerSettingsEventDefaultTypeInternal;
extern MailServerSettingsEventDefaultTypeInternal _MailServerSettingsEvent_default_instance_;
class NoActiveKeyForRecipientEvent;
struct NoActiveKeyForRecipientEventDefaultTypeInternal;
extern NoActiveKeyForRecipientEventDefaultTypeInternal _NoActiveKeyForRecipientEvent_default_instance_;
class RebuildKeychainEvent;
struct RebuildKeychainEventDefaultTypeInternal;
extern RebuildKeychainEventDefaultTypeInternal _RebuildKeychainEvent_default_instance_;
class ReportBugErrorEvent;
struct ReportBugErrorEventDefaultTypeInternal;
extern ReportBugErrorEventDefaultTypeInternal _ReportBugErrorEvent_default_instance_;
class ReportBugFinishedEvent;
struct ReportBugFinishedEventDefaultTypeInternal;
extern ReportBugFinishedEventDefaultTypeInternal _ReportBugFinishedEvent_default_instance_;
class ReportBugRequest;
struct ReportBugRequestDefaultTypeInternal;
extern ReportBugRequestDefaultTypeInternal _ReportBugRequest_default_instance_;
class ReportBugSuccessEvent;
struct ReportBugSuccessEventDefaultTypeInternal;
extern ReportBugSuccessEventDefaultTypeInternal _ReportBugSuccessEvent_default_instance_;
class ResetFinishedEvent;
struct ResetFinishedEventDefaultTypeInternal;
extern ResetFinishedEventDefaultTypeInternal _ResetFinishedEvent_default_instance_;
class ShowMainWindowEvent;
struct ShowMainWindowEventDefaultTypeInternal;
extern ShowMainWindowEventDefaultTypeInternal _ShowMainWindowEvent_default_instance_;
class StreamEvent;
struct StreamEventDefaultTypeInternal;
extern StreamEventDefaultTypeInternal _StreamEvent_default_instance_;
class SyncFinishedEvent;
struct SyncFinishedEventDefaultTypeInternal;
extern SyncFinishedEventDefaultTypeInternal _SyncFinishedEvent_default_instance_;
class SyncProgressEvent;
struct SyncProgressEventDefaultTypeInternal;
extern SyncProgressEventDefaultTypeInternal _SyncProgressEvent_default_instance_;
class SyncStartedEvent;
struct SyncStartedEventDefaultTypeInternal;
extern SyncStartedEventDefaultTypeInternal _SyncStartedEvent_default_instance_;
class ToggleAutostartFinishedEvent;
struct ToggleAutostartFinishedEventDefaultTypeInternal;
extern ToggleAutostartFinishedEventDefaultTypeInternal _ToggleAutostartFinishedEvent_default_instance_;
class ToggleSplitModeFinishedEvent;
struct ToggleSplitModeFinishedEventDefaultTypeInternal;
extern ToggleSplitModeFinishedEventDefaultTypeInternal _ToggleSplitModeFinishedEvent_default_instance_;
class UpdateCheckFinished;
struct UpdateCheckFinishedDefaultTypeInternal;
extern UpdateCheckFinishedDefaultTypeInternal _UpdateCheckFinished_default_instance_;
class UpdateErrorEvent;
struct UpdateErrorEventDefaultTypeInternal;
extern UpdateErrorEventDefaultTypeInternal _UpdateErrorEvent_default_instance_;
class UpdateEvent;
struct UpdateEventDefaultTypeInternal;
extern UpdateEventDefaultTypeInternal _UpdateEvent_default_instance_;
class UpdateForceEvent;
struct UpdateForceEventDefaultTypeInternal;
extern UpdateForceEventDefaultTypeInternal _UpdateForceEvent_default_instance_;
class UpdateIsLatestVersion;
struct UpdateIsLatestVersionDefaultTypeInternal;
extern UpdateIsLatestVersionDefaultTypeInternal _UpdateIsLatestVersion_default_instance_;
class UpdateManualReadyEvent;
struct UpdateManualReadyEventDefaultTypeInternal;
extern UpdateManualReadyEventDefaultTypeInternal _UpdateManualReadyEvent_default_instance_;
class UpdateManualRestartNeededEvent;
struct UpdateManualRestartNeededEventDefaultTypeInternal;
extern UpdateManualRestartNeededEventDefaultTypeInternal _UpdateManualRestartNeededEvent_default_instance_;
class UpdateSilentRestartNeeded;
struct UpdateSilentRestartNeededDefaultTypeInternal;
extern UpdateSilentRestartNeededDefaultTypeInternal _UpdateSilentRestartNeeded_default_instance_;
class UpdateVersionChanged;
struct UpdateVersionChangedDefaultTypeInternal;
extern UpdateVersionChangedDefaultTypeInternal _UpdateVersionChanged_default_instance_;
class UsedBytesChangedEvent;
struct UsedBytesChangedEventDefaultTypeInternal;
extern UsedBytesChangedEventDefaultTypeInternal _UsedBytesChangedEvent_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserBadEvent;
struct UserBadEventDefaultTypeInternal;
extern UserBadEventDefaultTypeInternal _UserBadEvent_default_instance_;
class UserBadEventFeedbackRequest;
struct UserBadEventFeedbackRequestDefaultTypeInternal;
extern UserBadEventFeedbackRequestDefaultTypeInternal _UserBadEventFeedbackRequest_default_instance_;
class UserChangedEvent;
struct UserChangedEventDefaultTypeInternal;
extern UserChangedEventDefaultTypeInternal _UserChangedEvent_default_instance_;
class UserDisconnectedEvent;
struct UserDisconnectedEventDefaultTypeInternal;
extern UserDisconnectedEventDefaultTypeInternal _UserDisconnectedEvent_default_instance_;
class UserEvent;
struct UserEventDefaultTypeInternal;
extern UserEventDefaultTypeInternal _UserEvent_default_instance_;
class UserListResponse;
struct UserListResponseDefaultTypeInternal;
extern UserListResponseDefaultTypeInternal _UserListResponse_default_instance_;
class UserSplitModeRequest;
struct UserSplitModeRequestDefaultTypeInternal;
extern UserSplitModeRequestDefaultTypeInternal _UserSplitModeRequest_default_instance_;
}  // namespace grpc
PROTOBUF_NAMESPACE_OPEN
template<> ::grpc::AddLogEntryRequest* Arena::CreateMaybeMessage<::grpc::AddLogEntryRequest>(Arena*);
template<> ::grpc::AddressChangedEvent* Arena::CreateMaybeMessage<::grpc::AddressChangedEvent>(Arena*);
template<> ::grpc::AddressChangedLogoutEvent* Arena::CreateMaybeMessage<::grpc::AddressChangedLogoutEvent>(Arena*);
template<> ::grpc::ApiCertIssueEvent* Arena::CreateMaybeMessage<::grpc::ApiCertIssueEvent>(Arena*);
template<> ::grpc::AppEvent* Arena::CreateMaybeMessage<::grpc::AppEvent>(Arena*);
template<> ::grpc::AvailableKeychainsResponse* Arena::CreateMaybeMessage<::grpc::AvailableKeychainsResponse>(Arena*);
template<> ::grpc::ChangeKeychainFinishedEvent* Arena::CreateMaybeMessage<::grpc::ChangeKeychainFinishedEvent>(Arena*);
template<> ::grpc::ChangeMailServerSettingsFinishedEvent* Arena::CreateMaybeMessage<::grpc::ChangeMailServerSettingsFinishedEvent>(Arena*);
template<> ::grpc::ConfigureAppleMailRequest* Arena::CreateMaybeMessage<::grpc::ConfigureAppleMailRequest>(Arena*);
template<> ::grpc::DiskCacheErrorEvent* Arena::CreateMaybeMessage<::grpc::DiskCacheErrorEvent>(Arena*);
template<> ::grpc::DiskCacheEvent* Arena::CreateMaybeMessage<::grpc::DiskCacheEvent>(Arena*);
template<> ::grpc::DiskCachePathChangeFinishedEvent* Arena::CreateMaybeMessage<::grpc::DiskCachePathChangeFinishedEvent>(Arena*);
template<> ::grpc::DiskCachePathChangedEvent* Arena::CreateMaybeMessage<::grpc::DiskCachePathChangedEvent>(Arena*);
template<> ::grpc::EventStreamRequest* Arena::CreateMaybeMessage<::grpc::EventStreamRequest>(Arena*);
template<> ::grpc::GenericErrorEvent* Arena::CreateMaybeMessage<::grpc::GenericErrorEvent>(Arena*);
template<> ::grpc::GuiReadyResponse* Arena::CreateMaybeMessage<::grpc::GuiReadyResponse>(Arena*);
template<> ::grpc::HasNoKeychainEvent* Arena::CreateMaybeMessage<::grpc::HasNoKeychainEvent>(Arena*);
template<> ::grpc::ImapLoginFailedEvent* Arena::CreateMaybeMessage<::grpc::ImapLoginFailedEvent>(Arena*);
template<> ::grpc::ImapSmtpSettings* Arena::CreateMaybeMessage<::grpc::ImapSmtpSettings>(Arena*);
template<> ::grpc::InternetStatusEvent* Arena::CreateMaybeMessage<::grpc::InternetStatusEvent>(Arena*);
template<> ::grpc::KeychainEvent* Arena::CreateMaybeMessage<::grpc::KeychainEvent>(Arena*);
template<> ::grpc::LoginAbortRequest* Arena::CreateMaybeMessage<::grpc::LoginAbortRequest>(Arena*);
template<> ::grpc::LoginErrorEvent* Arena::CreateMaybeMessage<::grpc::LoginErrorEvent>(Arena*);
template<> ::grpc::LoginEvent* Arena::CreateMaybeMessage<::grpc::LoginEvent>(Arena*);
template<> ::grpc::LoginFinishedEvent* Arena::CreateMaybeMessage<::grpc::LoginFinishedEvent>(Arena*);
template<> ::grpc::LoginRequest* Arena::CreateMaybeMessage<::grpc::LoginRequest>(Arena*);
template<> ::grpc::LoginTfaRequestedEvent* Arena::CreateMaybeMessage<::grpc::LoginTfaRequestedEvent>(Arena*);
template<> ::grpc::LoginTwoPasswordsRequestedEvent* Arena::CreateMaybeMessage<::grpc::LoginTwoPasswordsRequestedEvent>(Arena*);
template<> ::grpc::MailEvent* Arena::CreateMaybeMessage<::grpc::MailEvent>(Arena*);
template<> ::grpc::MailServerSettingsChangedEvent* Arena::CreateMaybeMessage<::grpc::MailServerSettingsChangedEvent>(Arena*);
template<> ::grpc::MailServerSettingsErrorEvent* Arena::CreateMaybeMessage<::grpc::MailServerSettingsErrorEvent>(Arena*);
template<> ::grpc::MailServerSettingsEvent* Arena::CreateMaybeMessage<::grpc::MailServerSettingsEvent>(Arena*);
template<> ::grpc::NoActiveKeyForRecipientEvent* Arena::CreateMaybeMessage<::grpc::NoActiveKeyForRecipientEvent>(Arena*);
template<> ::grpc::RebuildKeychainEvent* Arena::CreateMaybeMessage<::grpc::RebuildKeychainEvent>(Arena*);
template<> ::grpc::ReportBugErrorEvent* Arena::CreateMaybeMessage<::grpc::ReportBugErrorEvent>(Arena*);
template<> ::grpc::ReportBugFinishedEvent* Arena::CreateMaybeMessage<::grpc::ReportBugFinishedEvent>(Arena*);
template<> ::grpc::ReportBugRequest* Arena::CreateMaybeMessage<::grpc::ReportBugRequest>(Arena*);
template<> ::grpc::ReportBugSuccessEvent* Arena::CreateMaybeMessage<::grpc::ReportBugSuccessEvent>(Arena*);
template<> ::grpc::ResetFinishedEvent* Arena::CreateMaybeMessage<::grpc::ResetFinishedEvent>(Arena*);
template<> ::grpc::ShowMainWindowEvent* Arena::CreateMaybeMessage<::grpc::ShowMainWindowEvent>(Arena*);
template<> ::grpc::StreamEvent* Arena::CreateMaybeMessage<::grpc::StreamEvent>(Arena*);
template<> ::grpc::SyncFinishedEvent* Arena::CreateMaybeMessage<::grpc::SyncFinishedEvent>(Arena*);
template<> ::grpc::SyncProgressEvent* Arena::CreateMaybeMessage<::grpc::SyncProgressEvent>(Arena*);
template<> ::grpc::SyncStartedEvent* Arena::CreateMaybeMessage<::grpc::SyncStartedEvent>(Arena*);
template<> ::grpc::ToggleAutostartFinishedEvent* Arena::CreateMaybeMessage<::grpc::ToggleAutostartFinishedEvent>(Arena*);
template<> ::grpc::ToggleSplitModeFinishedEvent* Arena::CreateMaybeMessage<::grpc::ToggleSplitModeFinishedEvent>(Arena*);
template<> ::grpc::UpdateCheckFinished* Arena::CreateMaybeMessage<::grpc::UpdateCheckFinished>(Arena*);
template<> ::grpc::UpdateErrorEvent* Arena::CreateMaybeMessage<::grpc::UpdateErrorEvent>(Arena*);
template<> ::grpc::UpdateEvent* Arena::CreateMaybeMessage<::grpc::UpdateEvent>(Arena*);
template<> ::grpc::UpdateForceEvent* Arena::CreateMaybeMessage<::grpc::UpdateForceEvent>(Arena*);
template<> ::grpc::UpdateIsLatestVersion* Arena::CreateMaybeMessage<::grpc::UpdateIsLatestVersion>(Arena*);
template<> ::grpc::UpdateManualReadyEvent* Arena::CreateMaybeMessage<::grpc::UpdateManualReadyEvent>(Arena*);
template<> ::grpc::UpdateManualRestartNeededEvent* Arena::CreateMaybeMessage<::grpc::UpdateManualRestartNeededEvent>(Arena*);
template<> ::grpc::UpdateSilentRestartNeeded* Arena::CreateMaybeMessage<::grpc::UpdateSilentRestartNeeded>(Arena*);
template<> ::grpc::UpdateVersionChanged* Arena::CreateMaybeMessage<::grpc::UpdateVersionChanged>(Arena*);
template<> ::grpc::UsedBytesChangedEvent* Arena::CreateMaybeMessage<::grpc::UsedBytesChangedEvent>(Arena*);
template<> ::grpc::User* Arena::CreateMaybeMessage<::grpc::User>(Arena*);
template<> ::grpc::UserBadEvent* Arena::CreateMaybeMessage<::grpc::UserBadEvent>(Arena*);
template<> ::grpc::UserBadEventFeedbackRequest* Arena::CreateMaybeMessage<::grpc::UserBadEventFeedbackRequest>(Arena*);
template<> ::grpc::UserChangedEvent* Arena::CreateMaybeMessage<::grpc::UserChangedEvent>(Arena*);
template<> ::grpc::UserDisconnectedEvent* Arena::CreateMaybeMessage<::grpc::UserDisconnectedEvent>(Arena*);
template<> ::grpc::UserEvent* Arena::CreateMaybeMessage<::grpc::UserEvent>(Arena*);
template<> ::grpc::UserListResponse* Arena::CreateMaybeMessage<::grpc::UserListResponse>(Arena*);
template<> ::grpc::UserSplitModeRequest* Arena::CreateMaybeMessage<::grpc::UserSplitModeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace grpc {

enum LogLevel : int {
  LOG_PANIC = 0,
  LOG_FATAL = 1,
  LOG_ERROR = 2,
  LOG_WARN = 3,
  LOG_INFO = 4,
  LOG_DEBUG = 5,
  LOG_TRACE = 6,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = LOG_PANIC;
constexpr LogLevel LogLevel_MAX = LOG_TRACE;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum UserState : int {
  SIGNED_OUT = 0,
  LOCKED = 1,
  CONNECTED = 2,
  UserState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UserState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UserState_IsValid(int value);
constexpr UserState UserState_MIN = SIGNED_OUT;
constexpr UserState UserState_MAX = CONNECTED;
constexpr int UserState_ARRAYSIZE = UserState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UserState_descriptor();
template<typename T>
inline const std::string& UserState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UserState_descriptor(), enum_t_value);
}
inline bool UserState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UserState>(
    UserState_descriptor(), name, value);
}
enum LoginErrorType : int {
  USERNAME_PASSWORD_ERROR = 0,
  FREE_USER = 1,
  CONNECTION_ERROR = 2,
  TFA_ERROR = 3,
  TFA_ABORT = 4,
  TWO_PASSWORDS_ERROR = 5,
  TWO_PASSWORDS_ABORT = 6,
  LoginErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoginErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoginErrorType_IsValid(int value);
constexpr LoginErrorType LoginErrorType_MIN = USERNAME_PASSWORD_ERROR;
constexpr LoginErrorType LoginErrorType_MAX = TWO_PASSWORDS_ABORT;
constexpr int LoginErrorType_ARRAYSIZE = LoginErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginErrorType_descriptor();
template<typename T>
inline const std::string& LoginErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginErrorType_descriptor(), enum_t_value);
}
inline bool LoginErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginErrorType>(
    LoginErrorType_descriptor(), name, value);
}
enum UpdateErrorType : int {
  UPDATE_MANUAL_ERROR = 0,
  UPDATE_FORCE_ERROR = 1,
  UPDATE_SILENT_ERROR = 2,
  UpdateErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateErrorType_IsValid(int value);
constexpr UpdateErrorType UpdateErrorType_MIN = UPDATE_MANUAL_ERROR;
constexpr UpdateErrorType UpdateErrorType_MAX = UPDATE_SILENT_ERROR;
constexpr int UpdateErrorType_ARRAYSIZE = UpdateErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateErrorType_descriptor();
template<typename T>
inline const std::string& UpdateErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateErrorType_descriptor(), enum_t_value);
}
inline bool UpdateErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateErrorType>(
    UpdateErrorType_descriptor(), name, value);
}
enum DiskCacheErrorType : int {
  DISK_CACHE_UNAVAILABLE_ERROR = 0,
  CANT_MOVE_DISK_CACHE_ERROR = 1,
  DISK_FULL_ERROR = 2,
  DiskCacheErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DiskCacheErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DiskCacheErrorType_IsValid(int value);
constexpr DiskCacheErrorType DiskCacheErrorType_MIN = DISK_CACHE_UNAVAILABLE_ERROR;
constexpr DiskCacheErrorType DiskCacheErrorType_MAX = DISK_FULL_ERROR;
constexpr int DiskCacheErrorType_ARRAYSIZE = DiskCacheErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DiskCacheErrorType_descriptor();
template<typename T>
inline const std::string& DiskCacheErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DiskCacheErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DiskCacheErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DiskCacheErrorType_descriptor(), enum_t_value);
}
inline bool DiskCacheErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DiskCacheErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DiskCacheErrorType>(
    DiskCacheErrorType_descriptor(), name, value);
}
enum MailServerSettingsErrorType : int {
  IMAP_PORT_STARTUP_ERROR = 0,
  SMTP_PORT_STARTUP_ERROR = 1,
  IMAP_PORT_CHANGE_ERROR = 2,
  SMTP_PORT_CHANGE_ERROR = 3,
  IMAP_CONNECTION_MODE_CHANGE_ERROR = 4,
  SMTP_CONNECTION_MODE_CHANGE_ERROR = 5,
  MailServerSettingsErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MailServerSettingsErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MailServerSettingsErrorType_IsValid(int value);
constexpr MailServerSettingsErrorType MailServerSettingsErrorType_MIN = IMAP_PORT_STARTUP_ERROR;
constexpr MailServerSettingsErrorType MailServerSettingsErrorType_MAX = SMTP_CONNECTION_MODE_CHANGE_ERROR;
constexpr int MailServerSettingsErrorType_ARRAYSIZE = MailServerSettingsErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MailServerSettingsErrorType_descriptor();
template<typename T>
inline const std::string& MailServerSettingsErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailServerSettingsErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailServerSettingsErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MailServerSettingsErrorType_descriptor(), enum_t_value);
}
inline bool MailServerSettingsErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MailServerSettingsErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MailServerSettingsErrorType>(
    MailServerSettingsErrorType_descriptor(), name, value);
}
enum ErrorCode : int {
  UNKNOWN_ERROR = 0,
  TLS_CERT_EXPORT_ERROR = 1,
  TLS_KEY_EXPORT_ERROR = 2,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = UNKNOWN_ERROR;
constexpr ErrorCode ErrorCode_MAX = TLS_KEY_EXPORT_ERROR;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
// ===================================================================

class AddLogEntryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AddLogEntryRequest) */ {
 public:
  inline AddLogEntryRequest() : AddLogEntryRequest(nullptr) {}
  ~AddLogEntryRequest() override;
  explicit PROTOBUF_CONSTEXPR AddLogEntryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddLogEntryRequest(const AddLogEntryRequest& from);
  AddLogEntryRequest(AddLogEntryRequest&& from) noexcept
    : AddLogEntryRequest() {
    *this = ::std::move(from);
  }

  inline AddLogEntryRequest& operator=(const AddLogEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLogEntryRequest& operator=(AddLogEntryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLogEntryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLogEntryRequest* internal_default_instance() {
    return reinterpret_cast<const AddLogEntryRequest*>(
               &_AddLogEntryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AddLogEntryRequest& a, AddLogEntryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLogEntryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLogEntryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddLogEntryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddLogEntryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddLogEntryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddLogEntryRequest& from) {
    AddLogEntryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLogEntryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AddLogEntryRequest";
  }
  protected:
  explicit AddLogEntryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageFieldNumber = 2,
    kMessageFieldNumber = 3,
    kLevelFieldNumber = 1,
  };
  // string package = 2;
  void clear_package();
  const std::string& package() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package();
  PROTOBUF_NODISCARD std::string* release_package();
  void set_allocated_package(std::string* package);
  private:
  const std::string& _internal_package() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package(const std::string& value);
  std::string* _internal_mutable_package();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .grpc.LogLevel level = 1;
  void clear_level();
  ::grpc::LogLevel level() const;
  void set_level(::grpc::LogLevel value);
  private:
  ::grpc::LogLevel _internal_level() const;
  void _internal_set_level(::grpc::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.AddLogEntryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class GuiReadyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.GuiReadyResponse) */ {
 public:
  inline GuiReadyResponse() : GuiReadyResponse(nullptr) {}
  ~GuiReadyResponse() override;
  explicit PROTOBUF_CONSTEXPR GuiReadyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GuiReadyResponse(const GuiReadyResponse& from);
  GuiReadyResponse(GuiReadyResponse&& from) noexcept
    : GuiReadyResponse() {
    *this = ::std::move(from);
  }

  inline GuiReadyResponse& operator=(const GuiReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuiReadyResponse& operator=(GuiReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuiReadyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuiReadyResponse* internal_default_instance() {
    return reinterpret_cast<const GuiReadyResponse*>(
               &_GuiReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GuiReadyResponse& a, GuiReadyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GuiReadyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuiReadyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuiReadyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GuiReadyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GuiReadyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GuiReadyResponse& from) {
    GuiReadyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuiReadyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.GuiReadyResponse";
  }
  protected:
  explicit GuiReadyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShowSplashScreenFieldNumber = 1,
  };
  // bool showSplashScreen = 1;
  void clear_showsplashscreen();
  bool showsplashscreen() const;
  void set_showsplashscreen(bool value);
  private:
  bool _internal_showsplashscreen() const;
  void _internal_set_showsplashscreen(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.GuiReadyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool showsplashscreen_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ReportBugRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ReportBugRequest) */ {
 public:
  inline ReportBugRequest() : ReportBugRequest(nullptr) {}
  ~ReportBugRequest() override;
  explicit PROTOBUF_CONSTEXPR ReportBugRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugRequest(const ReportBugRequest& from);
  ReportBugRequest(ReportBugRequest&& from) noexcept
    : ReportBugRequest() {
    *this = ::std::move(from);
  }

  inline ReportBugRequest& operator=(const ReportBugRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugRequest& operator=(ReportBugRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugRequest* internal_default_instance() {
    return reinterpret_cast<const ReportBugRequest*>(
               &_ReportBugRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReportBugRequest& a, ReportBugRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReportBugRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReportBugRequest& from) {
    ReportBugRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportBugRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugRequest";
  }
  protected:
  explicit ReportBugRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOsTypeFieldNumber = 1,
    kOsVersionFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kAddressFieldNumber = 4,
    kEmailClientFieldNumber = 5,
    kIncludeLogsFieldNumber = 6,
  };
  // string osType = 1;
  void clear_ostype();
  const std::string& ostype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ostype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ostype();
  PROTOBUF_NODISCARD std::string* release_ostype();
  void set_allocated_ostype(std::string* ostype);
  private:
  const std::string& _internal_ostype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ostype(const std::string& value);
  std::string* _internal_mutable_ostype();
  public:

  // string osVersion = 2;
  void clear_osversion();
  const std::string& osversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_osversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_osversion();
  PROTOBUF_NODISCARD std::string* release_osversion();
  void set_allocated_osversion(std::string* osversion);
  private:
  const std::string& _internal_osversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_osversion(const std::string& value);
  std::string* _internal_mutable_osversion();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string address = 4;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string emailClient = 5;
  void clear_emailclient();
  const std::string& emailclient() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emailclient(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emailclient();
  PROTOBUF_NODISCARD std::string* release_emailclient();
  void set_allocated_emailclient(std::string* emailclient);
  private:
  const std::string& _internal_emailclient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emailclient(const std::string& value);
  std::string* _internal_mutable_emailclient();
  public:

  // bool includeLogs = 6;
  void clear_includelogs();
  bool includelogs() const;
  void set_includelogs(bool value);
  private:
  bool _internal_includelogs() const;
  void _internal_set_includelogs(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.ReportBugRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ostype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr osversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emailclient_;
    bool includelogs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // bytes password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginAbortRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginAbortRequest) */ {
 public:
  inline LoginAbortRequest() : LoginAbortRequest(nullptr) {}
  ~LoginAbortRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginAbortRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginAbortRequest(const LoginAbortRequest& from);
  LoginAbortRequest(LoginAbortRequest&& from) noexcept
    : LoginAbortRequest() {
    *this = ::std::move(from);
  }

  inline LoginAbortRequest& operator=(const LoginAbortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAbortRequest& operator=(LoginAbortRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginAbortRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginAbortRequest* internal_default_instance() {
    return reinterpret_cast<const LoginAbortRequest*>(
               &_LoginAbortRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginAbortRequest& a, LoginAbortRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAbortRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAbortRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginAbortRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginAbortRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginAbortRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginAbortRequest& from) {
    LoginAbortRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginAbortRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginAbortRequest";
  }
  protected:
  explicit LoginAbortRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginAbortRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ImapSmtpSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ImapSmtpSettings) */ {
 public:
  inline ImapSmtpSettings() : ImapSmtpSettings(nullptr) {}
  ~ImapSmtpSettings() override;
  explicit PROTOBUF_CONSTEXPR ImapSmtpSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImapSmtpSettings(const ImapSmtpSettings& from);
  ImapSmtpSettings(ImapSmtpSettings&& from) noexcept
    : ImapSmtpSettings() {
    *this = ::std::move(from);
  }

  inline ImapSmtpSettings& operator=(const ImapSmtpSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImapSmtpSettings& operator=(ImapSmtpSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImapSmtpSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImapSmtpSettings* internal_default_instance() {
    return reinterpret_cast<const ImapSmtpSettings*>(
               &_ImapSmtpSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ImapSmtpSettings& a, ImapSmtpSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(ImapSmtpSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImapSmtpSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImapSmtpSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImapSmtpSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImapSmtpSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImapSmtpSettings& from) {
    ImapSmtpSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImapSmtpSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ImapSmtpSettings";
  }
  protected:
  explicit ImapSmtpSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImapPortFieldNumber = 1,
    kSmtpPortFieldNumber = 2,
    kUseSSLForImapFieldNumber = 3,
    kUseSSLForSmtpFieldNumber = 4,
  };
  // int32 imapPort = 1;
  void clear_imapport();
  int32_t imapport() const;
  void set_imapport(int32_t value);
  private:
  int32_t _internal_imapport() const;
  void _internal_set_imapport(int32_t value);
  public:

  // int32 smtpPort = 2;
  void clear_smtpport();
  int32_t smtpport() const;
  void set_smtpport(int32_t value);
  private:
  int32_t _internal_smtpport() const;
  void _internal_set_smtpport(int32_t value);
  public:

  // bool useSSLForImap = 3;
  void clear_usesslforimap();
  bool usesslforimap() const;
  void set_usesslforimap(bool value);
  private:
  bool _internal_usesslforimap() const;
  void _internal_set_usesslforimap(bool value);
  public:

  // bool useSSLForSmtp = 4;
  void clear_usesslforsmtp();
  bool usesslforsmtp() const;
  void set_usesslforsmtp(bool value);
  private:
  bool _internal_usesslforsmtp() const;
  void _internal_set_usesslforsmtp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.ImapSmtpSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t imapport_;
    int32_t smtpport_;
    bool usesslforimap_;
    bool usesslforsmtp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AvailableKeychainsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AvailableKeychainsResponse) */ {
 public:
  inline AvailableKeychainsResponse() : AvailableKeychainsResponse(nullptr) {}
  ~AvailableKeychainsResponse() override;
  explicit PROTOBUF_CONSTEXPR AvailableKeychainsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailableKeychainsResponse(const AvailableKeychainsResponse& from);
  AvailableKeychainsResponse(AvailableKeychainsResponse&& from) noexcept
    : AvailableKeychainsResponse() {
    *this = ::std::move(from);
  }

  inline AvailableKeychainsResponse& operator=(const AvailableKeychainsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailableKeychainsResponse& operator=(AvailableKeychainsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailableKeychainsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailableKeychainsResponse* internal_default_instance() {
    return reinterpret_cast<const AvailableKeychainsResponse*>(
               &_AvailableKeychainsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AvailableKeychainsResponse& a, AvailableKeychainsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailableKeychainsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailableKeychainsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailableKeychainsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvailableKeychainsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvailableKeychainsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvailableKeychainsResponse& from) {
    AvailableKeychainsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvailableKeychainsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AvailableKeychainsResponse";
  }
  protected:
  explicit AvailableKeychainsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeychainsFieldNumber = 1,
  };
  // repeated string keychains = 1;
  int keychains_size() const;
  private:
  int _internal_keychains_size() const;
  public:
  void clear_keychains();
  const std::string& keychains(int index) const;
  std::string* mutable_keychains(int index);
  void set_keychains(int index, const std::string& value);
  void set_keychains(int index, std::string&& value);
  void set_keychains(int index, const char* value);
  void set_keychains(int index, const char* value, size_t size);
  std::string* add_keychains();
  void add_keychains(const std::string& value);
  void add_keychains(std::string&& value);
  void add_keychains(const char* value);
  void add_keychains(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keychains() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keychains();
  private:
  const std::string& _internal_keychains(int index) const;
  std::string* _internal_add_keychains();
  public:

  // @@protoc_insertion_point(class_scope:grpc.AvailableKeychainsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keychains_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 9,
    kIdFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kAvatarTextFieldNumber = 3,
    kPasswordFieldNumber = 8,
    kStateFieldNumber = 4,
    kSplitModeFieldNumber = 5,
    kUsedBytesFieldNumber = 6,
    kTotalBytesFieldNumber = 7,
  };
  // repeated string addresses = 9;
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();
  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string avatarText = 3;
  void clear_avatartext();
  const std::string& avatartext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatartext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatartext();
  PROTOBUF_NODISCARD std::string* release_avatartext();
  void set_allocated_avatartext(std::string* avatartext);
  private:
  const std::string& _internal_avatartext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatartext(const std::string& value);
  std::string* _internal_mutable_avatartext();
  public:

  // bytes password = 8;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .grpc.UserState state = 4;
  void clear_state();
  ::grpc::UserState state() const;
  void set_state(::grpc::UserState value);
  private:
  ::grpc::UserState _internal_state() const;
  void _internal_set_state(::grpc::UserState value);
  public:

  // bool splitMode = 5;
  void clear_splitmode();
  bool splitmode() const;
  void set_splitmode(bool value);
  private:
  bool _internal_splitmode() const;
  void _internal_set_splitmode(bool value);
  public:

  // int64 usedBytes = 6;
  void clear_usedbytes();
  int64_t usedbytes() const;
  void set_usedbytes(int64_t value);
  private:
  int64_t _internal_usedbytes() const;
  void _internal_set_usedbytes(int64_t value);
  public:

  // int64 totalBytes = 7;
  void clear_totalbytes();
  int64_t totalbytes() const;
  void set_totalbytes(int64_t value);
  private:
  int64_t _internal_totalbytes() const;
  void _internal_set_totalbytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatartext_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int state_;
    bool splitmode_;
    int64_t usedbytes_;
    int64_t totalbytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserSplitModeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserSplitModeRequest) */ {
 public:
  inline UserSplitModeRequest() : UserSplitModeRequest(nullptr) {}
  ~UserSplitModeRequest() override;
  explicit PROTOBUF_CONSTEXPR UserSplitModeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSplitModeRequest(const UserSplitModeRequest& from);
  UserSplitModeRequest(UserSplitModeRequest&& from) noexcept
    : UserSplitModeRequest() {
    *this = ::std::move(from);
  }

  inline UserSplitModeRequest& operator=(const UserSplitModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSplitModeRequest& operator=(UserSplitModeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSplitModeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSplitModeRequest* internal_default_instance() {
    return reinterpret_cast<const UserSplitModeRequest*>(
               &_UserSplitModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UserSplitModeRequest& a, UserSplitModeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSplitModeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSplitModeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSplitModeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSplitModeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSplitModeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserSplitModeRequest& from) {
    UserSplitModeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSplitModeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserSplitModeRequest";
  }
  protected:
  explicit UserSplitModeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kActiveFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bool active = 2;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserSplitModeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    bool active_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserBadEventFeedbackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserBadEventFeedbackRequest) */ {
 public:
  inline UserBadEventFeedbackRequest() : UserBadEventFeedbackRequest(nullptr) {}
  ~UserBadEventFeedbackRequest() override;
  explicit PROTOBUF_CONSTEXPR UserBadEventFeedbackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserBadEventFeedbackRequest(const UserBadEventFeedbackRequest& from);
  UserBadEventFeedbackRequest(UserBadEventFeedbackRequest&& from) noexcept
    : UserBadEventFeedbackRequest() {
    *this = ::std::move(from);
  }

  inline UserBadEventFeedbackRequest& operator=(const UserBadEventFeedbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserBadEventFeedbackRequest& operator=(UserBadEventFeedbackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserBadEventFeedbackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserBadEventFeedbackRequest* internal_default_instance() {
    return reinterpret_cast<const UserBadEventFeedbackRequest*>(
               &_UserBadEventFeedbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserBadEventFeedbackRequest& a, UserBadEventFeedbackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserBadEventFeedbackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserBadEventFeedbackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserBadEventFeedbackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserBadEventFeedbackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserBadEventFeedbackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserBadEventFeedbackRequest& from) {
    UserBadEventFeedbackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserBadEventFeedbackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserBadEventFeedbackRequest";
  }
  protected:
  explicit UserBadEventFeedbackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kDoResyncFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bool doResync = 2;
  void clear_doresync();
  bool doresync() const;
  void set_doresync(bool value);
  private:
  bool _internal_doresync() const;
  void _internal_set_doresync(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserBadEventFeedbackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    bool doresync_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserListResponse) */ {
 public:
  inline UserListResponse() : UserListResponse(nullptr) {}
  ~UserListResponse() override;
  explicit PROTOBUF_CONSTEXPR UserListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserListResponse(const UserListResponse& from);
  UserListResponse(UserListResponse&& from) noexcept
    : UserListResponse() {
    *this = ::std::move(from);
  }

  inline UserListResponse& operator=(const UserListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListResponse& operator=(UserListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListResponse* internal_default_instance() {
    return reinterpret_cast<const UserListResponse*>(
               &_UserListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UserListResponse& a, UserListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserListResponse& from) {
    UserListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserListResponse";
  }
  protected:
  explicit UserListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .grpc.User users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::grpc::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >*
      mutable_users();
  private:
  const ::grpc::User& _internal_users(int index) const;
  ::grpc::User* _internal_add_users();
  public:
  const ::grpc::User& users(int index) const;
  ::grpc::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >&
      users() const;

  // @@protoc_insertion_point(class_scope:grpc.UserListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User > users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ConfigureAppleMailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ConfigureAppleMailRequest) */ {
 public:
  inline ConfigureAppleMailRequest() : ConfigureAppleMailRequest(nullptr) {}
  ~ConfigureAppleMailRequest() override;
  explicit PROTOBUF_CONSTEXPR ConfigureAppleMailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigureAppleMailRequest(const ConfigureAppleMailRequest& from);
  ConfigureAppleMailRequest(ConfigureAppleMailRequest&& from) noexcept
    : ConfigureAppleMailRequest() {
    *this = ::std::move(from);
  }

  inline ConfigureAppleMailRequest& operator=(const ConfigureAppleMailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureAppleMailRequest& operator=(ConfigureAppleMailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigureAppleMailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureAppleMailRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigureAppleMailRequest*>(
               &_ConfigureAppleMailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConfigureAppleMailRequest& a, ConfigureAppleMailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureAppleMailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureAppleMailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureAppleMailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureAppleMailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigureAppleMailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfigureAppleMailRequest& from) {
    ConfigureAppleMailRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigureAppleMailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ConfigureAppleMailRequest";
  }
  protected:
  explicit ConfigureAppleMailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:grpc.ConfigureAppleMailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class EventStreamRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.EventStreamRequest) */ {
 public:
  inline EventStreamRequest() : EventStreamRequest(nullptr) {}
  ~EventStreamRequest() override;
  explicit PROTOBUF_CONSTEXPR EventStreamRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventStreamRequest(const EventStreamRequest& from);
  EventStreamRequest(EventStreamRequest&& from) noexcept
    : EventStreamRequest() {
    *this = ::std::move(from);
  }

  inline EventStreamRequest& operator=(const EventStreamRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventStreamRequest& operator=(EventStreamRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventStreamRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventStreamRequest* internal_default_instance() {
    return reinterpret_cast<const EventStreamRequest*>(
               &_EventStreamRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EventStreamRequest& a, EventStreamRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EventStreamRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventStreamRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventStreamRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventStreamRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventStreamRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EventStreamRequest& from) {
    EventStreamRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventStreamRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.EventStreamRequest";
  }
  protected:
  explicit EventStreamRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientPlatformFieldNumber = 1,
  };
  // string ClientPlatform = 1;
  void clear_clientplatform();
  const std::string& clientplatform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientplatform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientplatform();
  PROTOBUF_NODISCARD std::string* release_clientplatform();
  void set_allocated_clientplatform(std::string* clientplatform);
  private:
  const std::string& _internal_clientplatform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientplatform(const std::string& value);
  std::string* _internal_mutable_clientplatform();
  public:

  // @@protoc_insertion_point(class_scope:grpc.EventStreamRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientplatform_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class StreamEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.StreamEvent) */ {
 public:
  inline StreamEvent() : StreamEvent(nullptr) {}
  ~StreamEvent() override;
  explicit PROTOBUF_CONSTEXPR StreamEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamEvent(const StreamEvent& from);
  StreamEvent(StreamEvent&& from) noexcept
    : StreamEvent() {
    *this = ::std::move(from);
  }

  inline StreamEvent& operator=(const StreamEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamEvent& operator=(StreamEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kApp = 1,
    kLogin = 2,
    kUpdate = 3,
    kCache = 4,
    kMailServerSettings = 5,
    kKeychain = 6,
    kMail = 7,
    kUser = 8,
    kGenericError = 9,
    EVENT_NOT_SET = 0,
  };

  static inline const StreamEvent* internal_default_instance() {
    return reinterpret_cast<const StreamEvent*>(
               &_StreamEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StreamEvent& a, StreamEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamEvent& from) {
    StreamEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.StreamEvent";
  }
  protected:
  explicit StreamEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
    kLoginFieldNumber = 2,
    kUpdateFieldNumber = 3,
    kCacheFieldNumber = 4,
    kMailServerSettingsFieldNumber = 5,
    kKeychainFieldNumber = 6,
    kMailFieldNumber = 7,
    kUserFieldNumber = 8,
    kGenericErrorFieldNumber = 9,
  };
  // .grpc.AppEvent app = 1;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::grpc::AppEvent& app() const;
  PROTOBUF_NODISCARD ::grpc::AppEvent* release_app();
  ::grpc::AppEvent* mutable_app();
  void set_allocated_app(::grpc::AppEvent* app);
  private:
  const ::grpc::AppEvent& _internal_app() const;
  ::grpc::AppEvent* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::grpc::AppEvent* app);
  ::grpc::AppEvent* unsafe_arena_release_app();

  // .grpc.LoginEvent login = 2;
  bool has_login() const;
  private:
  bool _internal_has_login() const;
  public:
  void clear_login();
  const ::grpc::LoginEvent& login() const;
  PROTOBUF_NODISCARD ::grpc::LoginEvent* release_login();
  ::grpc::LoginEvent* mutable_login();
  void set_allocated_login(::grpc::LoginEvent* login);
  private:
  const ::grpc::LoginEvent& _internal_login() const;
  ::grpc::LoginEvent* _internal_mutable_login();
  public:
  void unsafe_arena_set_allocated_login(
      ::grpc::LoginEvent* login);
  ::grpc::LoginEvent* unsafe_arena_release_login();

  // .grpc.UpdateEvent update = 3;
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::grpc::UpdateEvent& update() const;
  PROTOBUF_NODISCARD ::grpc::UpdateEvent* release_update();
  ::grpc::UpdateEvent* mutable_update();
  void set_allocated_update(::grpc::UpdateEvent* update);
  private:
  const ::grpc::UpdateEvent& _internal_update() const;
  ::grpc::UpdateEvent* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::grpc::UpdateEvent* update);
  ::grpc::UpdateEvent* unsafe_arena_release_update();

  // .grpc.DiskCacheEvent cache = 4;
  bool has_cache() const;
  private:
  bool _internal_has_cache() const;
  public:
  void clear_cache();
  const ::grpc::DiskCacheEvent& cache() const;
  PROTOBUF_NODISCARD ::grpc::DiskCacheEvent* release_cache();
  ::grpc::DiskCacheEvent* mutable_cache();
  void set_allocated_cache(::grpc::DiskCacheEvent* cache);
  private:
  const ::grpc::DiskCacheEvent& _internal_cache() const;
  ::grpc::DiskCacheEvent* _internal_mutable_cache();
  public:
  void unsafe_arena_set_allocated_cache(
      ::grpc::DiskCacheEvent* cache);
  ::grpc::DiskCacheEvent* unsafe_arena_release_cache();

  // .grpc.MailServerSettingsEvent mailServerSettings = 5;
  bool has_mailserversettings() const;
  private:
  bool _internal_has_mailserversettings() const;
  public:
  void clear_mailserversettings();
  const ::grpc::MailServerSettingsEvent& mailserversettings() const;
  PROTOBUF_NODISCARD ::grpc::MailServerSettingsEvent* release_mailserversettings();
  ::grpc::MailServerSettingsEvent* mutable_mailserversettings();
  void set_allocated_mailserversettings(::grpc::MailServerSettingsEvent* mailserversettings);
  private:
  const ::grpc::MailServerSettingsEvent& _internal_mailserversettings() const;
  ::grpc::MailServerSettingsEvent* _internal_mutable_mailserversettings();
  public:
  void unsafe_arena_set_allocated_mailserversettings(
      ::grpc::MailServerSettingsEvent* mailserversettings);
  ::grpc::MailServerSettingsEvent* unsafe_arena_release_mailserversettings();

  // .grpc.KeychainEvent keychain = 6;
  bool has_keychain() const;
  private:
  bool _internal_has_keychain() const;
  public:
  void clear_keychain();
  const ::grpc::KeychainEvent& keychain() const;
  PROTOBUF_NODISCARD ::grpc::KeychainEvent* release_keychain();
  ::grpc::KeychainEvent* mutable_keychain();
  void set_allocated_keychain(::grpc::KeychainEvent* keychain);
  private:
  const ::grpc::KeychainEvent& _internal_keychain() const;
  ::grpc::KeychainEvent* _internal_mutable_keychain();
  public:
  void unsafe_arena_set_allocated_keychain(
      ::grpc::KeychainEvent* keychain);
  ::grpc::KeychainEvent* unsafe_arena_release_keychain();

  // .grpc.MailEvent mail = 7;
  bool has_mail() const;
  private:
  bool _internal_has_mail() const;
  public:
  void clear_mail();
  const ::grpc::MailEvent& mail() const;
  PROTOBUF_NODISCARD ::grpc::MailEvent* release_mail();
  ::grpc::MailEvent* mutable_mail();
  void set_allocated_mail(::grpc::MailEvent* mail);
  private:
  const ::grpc::MailEvent& _internal_mail() const;
  ::grpc::MailEvent* _internal_mutable_mail();
  public:
  void unsafe_arena_set_allocated_mail(
      ::grpc::MailEvent* mail);
  ::grpc::MailEvent* unsafe_arena_release_mail();

  // .grpc.UserEvent user = 8;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::grpc::UserEvent& user() const;
  PROTOBUF_NODISCARD ::grpc::UserEvent* release_user();
  ::grpc::UserEvent* mutable_user();
  void set_allocated_user(::grpc::UserEvent* user);
  private:
  const ::grpc::UserEvent& _internal_user() const;
  ::grpc::UserEvent* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::grpc::UserEvent* user);
  ::grpc::UserEvent* unsafe_arena_release_user();

  // .grpc.GenericErrorEvent genericError = 9;
  bool has_genericerror() const;
  private:
  bool _internal_has_genericerror() const;
  public:
  void clear_genericerror();
  const ::grpc::GenericErrorEvent& genericerror() const;
  PROTOBUF_NODISCARD ::grpc::GenericErrorEvent* release_genericerror();
  ::grpc::GenericErrorEvent* mutable_genericerror();
  void set_allocated_genericerror(::grpc::GenericErrorEvent* genericerror);
  private:
  const ::grpc::GenericErrorEvent& _internal_genericerror() const;
  ::grpc::GenericErrorEvent* _internal_mutable_genericerror();
  public:
  void unsafe_arena_set_allocated_genericerror(
      ::grpc::GenericErrorEvent* genericerror);
  ::grpc::GenericErrorEvent* unsafe_arena_release_genericerror();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.StreamEvent)
 private:
  class _Internal;
  void set_has_app();
  void set_has_login();
  void set_has_update();
  void set_has_cache();
  void set_has_mailserversettings();
  void set_has_keychain();
  void set_has_mail();
  void set_has_user();
  void set_has_genericerror();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::AppEvent* app_;
      ::grpc::LoginEvent* login_;
      ::grpc::UpdateEvent* update_;
      ::grpc::DiskCacheEvent* cache_;
      ::grpc::MailServerSettingsEvent* mailserversettings_;
      ::grpc::KeychainEvent* keychain_;
      ::grpc::MailEvent* mail_;
      ::grpc::UserEvent* user_;
      ::grpc::GenericErrorEvent* genericerror_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AppEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AppEvent) */ {
 public:
  inline AppEvent() : AppEvent(nullptr) {}
  ~AppEvent() override;
  explicit PROTOBUF_CONSTEXPR AppEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppEvent(const AppEvent& from);
  AppEvent(AppEvent&& from) noexcept
    : AppEvent() {
    *this = ::std::move(from);
  }

  inline AppEvent& operator=(const AppEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppEvent& operator=(AppEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kInternetStatus = 1,
    kToggleAutostartFinished = 2,
    kResetFinished = 3,
    kReportBugFinished = 4,
    kReportBugSuccess = 5,
    kReportBugError = 6,
    kShowMainWindow = 7,
    EVENT_NOT_SET = 0,
  };

  static inline const AppEvent* internal_default_instance() {
    return reinterpret_cast<const AppEvent*>(
               &_AppEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AppEvent& a, AppEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AppEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppEvent& from) {
    AppEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AppEvent";
  }
  protected:
  explicit AppEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInternetStatusFieldNumber = 1,
    kToggleAutostartFinishedFieldNumber = 2,
    kResetFinishedFieldNumber = 3,
    kReportBugFinishedFieldNumber = 4,
    kReportBugSuccessFieldNumber = 5,
    kReportBugErrorFieldNumber = 6,
    kShowMainWindowFieldNumber = 7,
  };
  // .grpc.InternetStatusEvent internetStatus = 1;
  bool has_internetstatus() const;
  private:
  bool _internal_has_internetstatus() const;
  public:
  void clear_internetstatus();
  const ::grpc::InternetStatusEvent& internetstatus() const;
  PROTOBUF_NODISCARD ::grpc::InternetStatusEvent* release_internetstatus();
  ::grpc::InternetStatusEvent* mutable_internetstatus();
  void set_allocated_internetstatus(::grpc::InternetStatusEvent* internetstatus);
  private:
  const ::grpc::InternetStatusEvent& _internal_internetstatus() const;
  ::grpc::InternetStatusEvent* _internal_mutable_internetstatus();
  public:
  void unsafe_arena_set_allocated_internetstatus(
      ::grpc::InternetStatusEvent* internetstatus);
  ::grpc::InternetStatusEvent* unsafe_arena_release_internetstatus();

  // .grpc.ToggleAutostartFinishedEvent toggleAutostartFinished = 2;
  bool has_toggleautostartfinished() const;
  private:
  bool _internal_has_toggleautostartfinished() const;
  public:
  void clear_toggleautostartfinished();
  const ::grpc::ToggleAutostartFinishedEvent& toggleautostartfinished() const;
  PROTOBUF_NODISCARD ::grpc::ToggleAutostartFinishedEvent* release_toggleautostartfinished();
  ::grpc::ToggleAutostartFinishedEvent* mutable_toggleautostartfinished();
  void set_allocated_toggleautostartfinished(::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished);
  private:
  const ::grpc::ToggleAutostartFinishedEvent& _internal_toggleautostartfinished() const;
  ::grpc::ToggleAutostartFinishedEvent* _internal_mutable_toggleautostartfinished();
  public:
  void unsafe_arena_set_allocated_toggleautostartfinished(
      ::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished);
  ::grpc::ToggleAutostartFinishedEvent* unsafe_arena_release_toggleautostartfinished();

  // .grpc.ResetFinishedEvent resetFinished = 3;
  bool has_resetfinished() const;
  private:
  bool _internal_has_resetfinished() const;
  public:
  void clear_resetfinished();
  const ::grpc::ResetFinishedEvent& resetfinished() const;
  PROTOBUF_NODISCARD ::grpc::ResetFinishedEvent* release_resetfinished();
  ::grpc::ResetFinishedEvent* mutable_resetfinished();
  void set_allocated_resetfinished(::grpc::ResetFinishedEvent* resetfinished);
  private:
  const ::grpc::ResetFinishedEvent& _internal_resetfinished() const;
  ::grpc::ResetFinishedEvent* _internal_mutable_resetfinished();
  public:
  void unsafe_arena_set_allocated_resetfinished(
      ::grpc::ResetFinishedEvent* resetfinished);
  ::grpc::ResetFinishedEvent* unsafe_arena_release_resetfinished();

  // .grpc.ReportBugFinishedEvent reportBugFinished = 4;
  bool has_reportbugfinished() const;
  private:
  bool _internal_has_reportbugfinished() const;
  public:
  void clear_reportbugfinished();
  const ::grpc::ReportBugFinishedEvent& reportbugfinished() const;
  PROTOBUF_NODISCARD ::grpc::ReportBugFinishedEvent* release_reportbugfinished();
  ::grpc::ReportBugFinishedEvent* mutable_reportbugfinished();
  void set_allocated_reportbugfinished(::grpc::ReportBugFinishedEvent* reportbugfinished);
  private:
  const ::grpc::ReportBugFinishedEvent& _internal_reportbugfinished() const;
  ::grpc::ReportBugFinishedEvent* _internal_mutable_reportbugfinished();
  public:
  void unsafe_arena_set_allocated_reportbugfinished(
      ::grpc::ReportBugFinishedEvent* reportbugfinished);
  ::grpc::ReportBugFinishedEvent* unsafe_arena_release_reportbugfinished();

  // .grpc.ReportBugSuccessEvent reportBugSuccess = 5;
  bool has_reportbugsuccess() const;
  private:
  bool _internal_has_reportbugsuccess() const;
  public:
  void clear_reportbugsuccess();
  const ::grpc::ReportBugSuccessEvent& reportbugsuccess() const;
  PROTOBUF_NODISCARD ::grpc::ReportBugSuccessEvent* release_reportbugsuccess();
  ::grpc::ReportBugSuccessEvent* mutable_reportbugsuccess();
  void set_allocated_reportbugsuccess(::grpc::ReportBugSuccessEvent* reportbugsuccess);
  private:
  const ::grpc::ReportBugSuccessEvent& _internal_reportbugsuccess() const;
  ::grpc::ReportBugSuccessEvent* _internal_mutable_reportbugsuccess();
  public:
  void unsafe_arena_set_allocated_reportbugsuccess(
      ::grpc::ReportBugSuccessEvent* reportbugsuccess);
  ::grpc::ReportBugSuccessEvent* unsafe_arena_release_reportbugsuccess();

  // .grpc.ReportBugErrorEvent reportBugError = 6;
  bool has_reportbugerror() const;
  private:
  bool _internal_has_reportbugerror() const;
  public:
  void clear_reportbugerror();
  const ::grpc::ReportBugErrorEvent& reportbugerror() const;
  PROTOBUF_NODISCARD ::grpc::ReportBugErrorEvent* release_reportbugerror();
  ::grpc::ReportBugErrorEvent* mutable_reportbugerror();
  void set_allocated_reportbugerror(::grpc::ReportBugErrorEvent* reportbugerror);
  private:
  const ::grpc::ReportBugErrorEvent& _internal_reportbugerror() const;
  ::grpc::ReportBugErrorEvent* _internal_mutable_reportbugerror();
  public:
  void unsafe_arena_set_allocated_reportbugerror(
      ::grpc::ReportBugErrorEvent* reportbugerror);
  ::grpc::ReportBugErrorEvent* unsafe_arena_release_reportbugerror();

  // .grpc.ShowMainWindowEvent showMainWindow = 7;
  bool has_showmainwindow() const;
  private:
  bool _internal_has_showmainwindow() const;
  public:
  void clear_showmainwindow();
  const ::grpc::ShowMainWindowEvent& showmainwindow() const;
  PROTOBUF_NODISCARD ::grpc::ShowMainWindowEvent* release_showmainwindow();
  ::grpc::ShowMainWindowEvent* mutable_showmainwindow();
  void set_allocated_showmainwindow(::grpc::ShowMainWindowEvent* showmainwindow);
  private:
  const ::grpc::ShowMainWindowEvent& _internal_showmainwindow() const;
  ::grpc::ShowMainWindowEvent* _internal_mutable_showmainwindow();
  public:
  void unsafe_arena_set_allocated_showmainwindow(
      ::grpc::ShowMainWindowEvent* showmainwindow);
  ::grpc::ShowMainWindowEvent* unsafe_arena_release_showmainwindow();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.AppEvent)
 private:
  class _Internal;
  void set_has_internetstatus();
  void set_has_toggleautostartfinished();
  void set_has_resetfinished();
  void set_has_reportbugfinished();
  void set_has_reportbugsuccess();
  void set_has_reportbugerror();
  void set_has_showmainwindow();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::InternetStatusEvent* internetstatus_;
      ::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished_;
      ::grpc::ResetFinishedEvent* resetfinished_;
      ::grpc::ReportBugFinishedEvent* reportbugfinished_;
      ::grpc::ReportBugSuccessEvent* reportbugsuccess_;
      ::grpc::ReportBugErrorEvent* reportbugerror_;
      ::grpc::ShowMainWindowEvent* showmainwindow_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class InternetStatusEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.InternetStatusEvent) */ {
 public:
  inline InternetStatusEvent() : InternetStatusEvent(nullptr) {}
  ~InternetStatusEvent() override;
  explicit PROTOBUF_CONSTEXPR InternetStatusEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternetStatusEvent(const InternetStatusEvent& from);
  InternetStatusEvent(InternetStatusEvent&& from) noexcept
    : InternetStatusEvent() {
    *this = ::std::move(from);
  }

  inline InternetStatusEvent& operator=(const InternetStatusEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternetStatusEvent& operator=(InternetStatusEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternetStatusEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternetStatusEvent* internal_default_instance() {
    return reinterpret_cast<const InternetStatusEvent*>(
               &_InternetStatusEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(InternetStatusEvent& a, InternetStatusEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(InternetStatusEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternetStatusEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternetStatusEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternetStatusEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternetStatusEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InternetStatusEvent& from) {
    InternetStatusEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternetStatusEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.InternetStatusEvent";
  }
  protected:
  explicit InternetStatusEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectedFieldNumber = 1,
  };
  // bool connected = 1;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);
  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.InternetStatusEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool connected_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ToggleAutostartFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ToggleAutostartFinishedEvent) */ {
 public:
  inline ToggleAutostartFinishedEvent() : ToggleAutostartFinishedEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ToggleAutostartFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleAutostartFinishedEvent(const ToggleAutostartFinishedEvent& from);
  ToggleAutostartFinishedEvent(ToggleAutostartFinishedEvent&& from) noexcept
    : ToggleAutostartFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ToggleAutostartFinishedEvent& operator=(const ToggleAutostartFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleAutostartFinishedEvent& operator=(ToggleAutostartFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToggleAutostartFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleAutostartFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ToggleAutostartFinishedEvent*>(
               &_ToggleAutostartFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ToggleAutostartFinishedEvent& a, ToggleAutostartFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ToggleAutostartFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleAutostartFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleAutostartFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleAutostartFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ToggleAutostartFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ToggleAutostartFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ToggleAutostartFinishedEvent";
  }
  protected:
  explicit ToggleAutostartFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ToggleAutostartFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ResetFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ResetFinishedEvent) */ {
 public:
  inline ResetFinishedEvent() : ResetFinishedEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResetFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetFinishedEvent(const ResetFinishedEvent& from);
  ResetFinishedEvent(ResetFinishedEvent&& from) noexcept
    : ResetFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ResetFinishedEvent& operator=(const ResetFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetFinishedEvent& operator=(ResetFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ResetFinishedEvent*>(
               &_ResetFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ResetFinishedEvent& a, ResetFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ResetFinishedEvent";
  }
  protected:
  explicit ResetFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ResetFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ReportBugFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ReportBugFinishedEvent) */ {
 public:
  inline ReportBugFinishedEvent() : ReportBugFinishedEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReportBugFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugFinishedEvent(const ReportBugFinishedEvent& from);
  ReportBugFinishedEvent(ReportBugFinishedEvent&& from) noexcept
    : ReportBugFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ReportBugFinishedEvent& operator=(const ReportBugFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugFinishedEvent& operator=(ReportBugFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ReportBugFinishedEvent*>(
               &_ReportBugFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReportBugFinishedEvent& a, ReportBugFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportBugFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportBugFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugFinishedEvent";
  }
  protected:
  explicit ReportBugFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ReportBugFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ReportBugSuccessEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ReportBugSuccessEvent) */ {
 public:
  inline ReportBugSuccessEvent() : ReportBugSuccessEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReportBugSuccessEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugSuccessEvent(const ReportBugSuccessEvent& from);
  ReportBugSuccessEvent(ReportBugSuccessEvent&& from) noexcept
    : ReportBugSuccessEvent() {
    *this = ::std::move(from);
  }

  inline ReportBugSuccessEvent& operator=(const ReportBugSuccessEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugSuccessEvent& operator=(ReportBugSuccessEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugSuccessEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugSuccessEvent* internal_default_instance() {
    return reinterpret_cast<const ReportBugSuccessEvent*>(
               &_ReportBugSuccessEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ReportBugSuccessEvent& a, ReportBugSuccessEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugSuccessEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugSuccessEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugSuccessEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugSuccessEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportBugSuccessEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportBugSuccessEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugSuccessEvent";
  }
  protected:
  explicit ReportBugSuccessEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ReportBugSuccessEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ReportBugErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ReportBugErrorEvent) */ {
 public:
  inline ReportBugErrorEvent() : ReportBugErrorEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReportBugErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugErrorEvent(const ReportBugErrorEvent& from);
  ReportBugErrorEvent(ReportBugErrorEvent&& from) noexcept
    : ReportBugErrorEvent() {
    *this = ::std::move(from);
  }

  inline ReportBugErrorEvent& operator=(const ReportBugErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugErrorEvent& operator=(ReportBugErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugErrorEvent* internal_default_instance() {
    return reinterpret_cast<const ReportBugErrorEvent*>(
               &_ReportBugErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ReportBugErrorEvent& a, ReportBugErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportBugErrorEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportBugErrorEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugErrorEvent";
  }
  protected:
  explicit ReportBugErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ReportBugErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ShowMainWindowEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ShowMainWindowEvent) */ {
 public:
  inline ShowMainWindowEvent() : ShowMainWindowEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ShowMainWindowEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowMainWindowEvent(const ShowMainWindowEvent& from);
  ShowMainWindowEvent(ShowMainWindowEvent&& from) noexcept
    : ShowMainWindowEvent() {
    *this = ::std::move(from);
  }

  inline ShowMainWindowEvent& operator=(const ShowMainWindowEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowMainWindowEvent& operator=(ShowMainWindowEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowMainWindowEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowMainWindowEvent* internal_default_instance() {
    return reinterpret_cast<const ShowMainWindowEvent*>(
               &_ShowMainWindowEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ShowMainWindowEvent& a, ShowMainWindowEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowMainWindowEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowMainWindowEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowMainWindowEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowMainWindowEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShowMainWindowEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShowMainWindowEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ShowMainWindowEvent";
  }
  protected:
  explicit ShowMainWindowEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ShowMainWindowEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginEvent) */ {
 public:
  inline LoginEvent() : LoginEvent(nullptr) {}
  ~LoginEvent() override;
  explicit PROTOBUF_CONSTEXPR LoginEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginEvent(const LoginEvent& from);
  LoginEvent(LoginEvent&& from) noexcept
    : LoginEvent() {
    *this = ::std::move(from);
  }

  inline LoginEvent& operator=(const LoginEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginEvent& operator=(LoginEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kTfaRequested = 2,
    kTwoPasswordRequested = 3,
    kFinished = 4,
    kAlreadyLoggedIn = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const LoginEvent* internal_default_instance() {
    return reinterpret_cast<const LoginEvent*>(
               &_LoginEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LoginEvent& a, LoginEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginEvent& from) {
    LoginEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginEvent";
  }
  protected:
  explicit LoginEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kTfaRequestedFieldNumber = 2,
    kTwoPasswordRequestedFieldNumber = 3,
    kFinishedFieldNumber = 4,
    kAlreadyLoggedInFieldNumber = 5,
  };
  // .grpc.LoginErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::LoginErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::LoginErrorEvent* release_error();
  ::grpc::LoginErrorEvent* mutable_error();
  void set_allocated_error(::grpc::LoginErrorEvent* error);
  private:
  const ::grpc::LoginErrorEvent& _internal_error() const;
  ::grpc::LoginErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::LoginErrorEvent* error);
  ::grpc::LoginErrorEvent* unsafe_arena_release_error();

  // .grpc.LoginTfaRequestedEvent tfaRequested = 2;
  bool has_tfarequested() const;
  private:
  bool _internal_has_tfarequested() const;
  public:
  void clear_tfarequested();
  const ::grpc::LoginTfaRequestedEvent& tfarequested() const;
  PROTOBUF_NODISCARD ::grpc::LoginTfaRequestedEvent* release_tfarequested();
  ::grpc::LoginTfaRequestedEvent* mutable_tfarequested();
  void set_allocated_tfarequested(::grpc::LoginTfaRequestedEvent* tfarequested);
  private:
  const ::grpc::LoginTfaRequestedEvent& _internal_tfarequested() const;
  ::grpc::LoginTfaRequestedEvent* _internal_mutable_tfarequested();
  public:
  void unsafe_arena_set_allocated_tfarequested(
      ::grpc::LoginTfaRequestedEvent* tfarequested);
  ::grpc::LoginTfaRequestedEvent* unsafe_arena_release_tfarequested();

  // .grpc.LoginTwoPasswordsRequestedEvent twoPasswordRequested = 3;
  bool has_twopasswordrequested() const;
  private:
  bool _internal_has_twopasswordrequested() const;
  public:
  void clear_twopasswordrequested();
  const ::grpc::LoginTwoPasswordsRequestedEvent& twopasswordrequested() const;
  PROTOBUF_NODISCARD ::grpc::LoginTwoPasswordsRequestedEvent* release_twopasswordrequested();
  ::grpc::LoginTwoPasswordsRequestedEvent* mutable_twopasswordrequested();
  void set_allocated_twopasswordrequested(::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested);
  private:
  const ::grpc::LoginTwoPasswordsRequestedEvent& _internal_twopasswordrequested() const;
  ::grpc::LoginTwoPasswordsRequestedEvent* _internal_mutable_twopasswordrequested();
  public:
  void unsafe_arena_set_allocated_twopasswordrequested(
      ::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested);
  ::grpc::LoginTwoPasswordsRequestedEvent* unsafe_arena_release_twopasswordrequested();

  // .grpc.LoginFinishedEvent finished = 4;
  bool has_finished() const;
  private:
  bool _internal_has_finished() const;
  public:
  void clear_finished();
  const ::grpc::LoginFinishedEvent& finished() const;
  PROTOBUF_NODISCARD ::grpc::LoginFinishedEvent* release_finished();
  ::grpc::LoginFinishedEvent* mutable_finished();
  void set_allocated_finished(::grpc::LoginFinishedEvent* finished);
  private:
  const ::grpc::LoginFinishedEvent& _internal_finished() const;
  ::grpc::LoginFinishedEvent* _internal_mutable_finished();
  public:
  void unsafe_arena_set_allocated_finished(
      ::grpc::LoginFinishedEvent* finished);
  ::grpc::LoginFinishedEvent* unsafe_arena_release_finished();

  // .grpc.LoginFinishedEvent alreadyLoggedIn = 5;
  bool has_alreadyloggedin() const;
  private:
  bool _internal_has_alreadyloggedin() const;
  public:
  void clear_alreadyloggedin();
  const ::grpc::LoginFinishedEvent& alreadyloggedin() const;
  PROTOBUF_NODISCARD ::grpc::LoginFinishedEvent* release_alreadyloggedin();
  ::grpc::LoginFinishedEvent* mutable_alreadyloggedin();
  void set_allocated_alreadyloggedin(::grpc::LoginFinishedEvent* alreadyloggedin);
  private:
  const ::grpc::LoginFinishedEvent& _internal_alreadyloggedin() const;
  ::grpc::LoginFinishedEvent* _internal_mutable_alreadyloggedin();
  public:
  void unsafe_arena_set_allocated_alreadyloggedin(
      ::grpc::LoginFinishedEvent* alreadyloggedin);
  ::grpc::LoginFinishedEvent* unsafe_arena_release_alreadyloggedin();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.LoginEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_tfarequested();
  void set_has_twopasswordrequested();
  void set_has_finished();
  void set_has_alreadyloggedin();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::LoginErrorEvent* error_;
      ::grpc::LoginTfaRequestedEvent* tfarequested_;
      ::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested_;
      ::grpc::LoginFinishedEvent* finished_;
      ::grpc::LoginFinishedEvent* alreadyloggedin_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginErrorEvent) */ {
 public:
  inline LoginErrorEvent() : LoginErrorEvent(nullptr) {}
  ~LoginErrorEvent() override;
  explicit PROTOBUF_CONSTEXPR LoginErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginErrorEvent(const LoginErrorEvent& from);
  LoginErrorEvent(LoginErrorEvent&& from) noexcept
    : LoginErrorEvent() {
    *this = ::std::move(from);
  }

  inline LoginErrorEvent& operator=(const LoginErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginErrorEvent& operator=(LoginErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginErrorEvent* internal_default_instance() {
    return reinterpret_cast<const LoginErrorEvent*>(
               &_LoginErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LoginErrorEvent& a, LoginErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginErrorEvent& from) {
    LoginErrorEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginErrorEvent";
  }
  protected:
  explicit LoginErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .grpc.LoginErrorType type = 1;
  void clear_type();
  ::grpc::LoginErrorType type() const;
  void set_type(::grpc::LoginErrorType value);
  private:
  ::grpc::LoginErrorType _internal_type() const;
  void _internal_set_type(::grpc::LoginErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginTfaRequestedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginTfaRequestedEvent) */ {
 public:
  inline LoginTfaRequestedEvent() : LoginTfaRequestedEvent(nullptr) {}
  ~LoginTfaRequestedEvent() override;
  explicit PROTOBUF_CONSTEXPR LoginTfaRequestedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginTfaRequestedEvent(const LoginTfaRequestedEvent& from);
  LoginTfaRequestedEvent(LoginTfaRequestedEvent&& from) noexcept
    : LoginTfaRequestedEvent() {
    *this = ::std::move(from);
  }

  inline LoginTfaRequestedEvent& operator=(const LoginTfaRequestedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginTfaRequestedEvent& operator=(LoginTfaRequestedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginTfaRequestedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginTfaRequestedEvent* internal_default_instance() {
    return reinterpret_cast<const LoginTfaRequestedEvent*>(
               &_LoginTfaRequestedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LoginTfaRequestedEvent& a, LoginTfaRequestedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginTfaRequestedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginTfaRequestedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginTfaRequestedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginTfaRequestedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginTfaRequestedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginTfaRequestedEvent& from) {
    LoginTfaRequestedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginTfaRequestedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginTfaRequestedEvent";
  }
  protected:
  explicit LoginTfaRequestedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginTfaRequestedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginTwoPasswordsRequestedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.LoginTwoPasswordsRequestedEvent) */ {
 public:
  inline LoginTwoPasswordsRequestedEvent() : LoginTwoPasswordsRequestedEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LoginTwoPasswordsRequestedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginTwoPasswordsRequestedEvent(const LoginTwoPasswordsRequestedEvent& from);
  LoginTwoPasswordsRequestedEvent(LoginTwoPasswordsRequestedEvent&& from) noexcept
    : LoginTwoPasswordsRequestedEvent() {
    *this = ::std::move(from);
  }

  inline LoginTwoPasswordsRequestedEvent& operator=(const LoginTwoPasswordsRequestedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginTwoPasswordsRequestedEvent& operator=(LoginTwoPasswordsRequestedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginTwoPasswordsRequestedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginTwoPasswordsRequestedEvent* internal_default_instance() {
    return reinterpret_cast<const LoginTwoPasswordsRequestedEvent*>(
               &_LoginTwoPasswordsRequestedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(LoginTwoPasswordsRequestedEvent& a, LoginTwoPasswordsRequestedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginTwoPasswordsRequestedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginTwoPasswordsRequestedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginTwoPasswordsRequestedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginTwoPasswordsRequestedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LoginTwoPasswordsRequestedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LoginTwoPasswordsRequestedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginTwoPasswordsRequestedEvent";
  }
  protected:
  explicit LoginTwoPasswordsRequestedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.LoginTwoPasswordsRequestedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginFinishedEvent) */ {
 public:
  inline LoginFinishedEvent() : LoginFinishedEvent(nullptr) {}
  ~LoginFinishedEvent() override;
  explicit PROTOBUF_CONSTEXPR LoginFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginFinishedEvent(const LoginFinishedEvent& from);
  LoginFinishedEvent(LoginFinishedEvent&& from) noexcept
    : LoginFinishedEvent() {
    *this = ::std::move(from);
  }

  inline LoginFinishedEvent& operator=(const LoginFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginFinishedEvent& operator=(LoginFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const LoginFinishedEvent*>(
               &_LoginFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(LoginFinishedEvent& a, LoginFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginFinishedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginFinishedEvent& from) {
    LoginFinishedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginFinishedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginFinishedEvent";
  }
  protected:
  explicit LoginFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kWasSignedOutFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bool wasSignedOut = 2;
  void clear_wassignedout();
  bool wassignedout() const;
  void set_wassignedout(bool value);
  private:
  bool _internal_wassignedout() const;
  void _internal_set_wassignedout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    bool wassignedout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateEvent) */ {
 public:
  inline UpdateEvent() : UpdateEvent(nullptr) {}
  ~UpdateEvent() override;
  explicit PROTOBUF_CONSTEXPR UpdateEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEvent(const UpdateEvent& from);
  UpdateEvent(UpdateEvent&& from) noexcept
    : UpdateEvent() {
    *this = ::std::move(from);
  }

  inline UpdateEvent& operator=(const UpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEvent& operator=(UpdateEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kManualReady = 2,
    kManualRestartNeeded = 3,
    kForce = 4,
    kSilentRestartNeeded = 5,
    kIsLatestVersion = 6,
    kCheckFinished = 7,
    kVersionChanged = 8,
    EVENT_NOT_SET = 0,
  };

  static inline const UpdateEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateEvent*>(
               &_UpdateEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UpdateEvent& a, UpdateEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateEvent& from) {
    UpdateEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateEvent";
  }
  protected:
  explicit UpdateEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kManualReadyFieldNumber = 2,
    kManualRestartNeededFieldNumber = 3,
    kForceFieldNumber = 4,
    kSilentRestartNeededFieldNumber = 5,
    kIsLatestVersionFieldNumber = 6,
    kCheckFinishedFieldNumber = 7,
    kVersionChangedFieldNumber = 8,
  };
  // .grpc.UpdateErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::UpdateErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::UpdateErrorEvent* release_error();
  ::grpc::UpdateErrorEvent* mutable_error();
  void set_allocated_error(::grpc::UpdateErrorEvent* error);
  private:
  const ::grpc::UpdateErrorEvent& _internal_error() const;
  ::grpc::UpdateErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::UpdateErrorEvent* error);
  ::grpc::UpdateErrorEvent* unsafe_arena_release_error();

  // .grpc.UpdateManualReadyEvent manualReady = 2;
  bool has_manualready() const;
  private:
  bool _internal_has_manualready() const;
  public:
  void clear_manualready();
  const ::grpc::UpdateManualReadyEvent& manualready() const;
  PROTOBUF_NODISCARD ::grpc::UpdateManualReadyEvent* release_manualready();
  ::grpc::UpdateManualReadyEvent* mutable_manualready();
  void set_allocated_manualready(::grpc::UpdateManualReadyEvent* manualready);
  private:
  const ::grpc::UpdateManualReadyEvent& _internal_manualready() const;
  ::grpc::UpdateManualReadyEvent* _internal_mutable_manualready();
  public:
  void unsafe_arena_set_allocated_manualready(
      ::grpc::UpdateManualReadyEvent* manualready);
  ::grpc::UpdateManualReadyEvent* unsafe_arena_release_manualready();

  // .grpc.UpdateManualRestartNeededEvent manualRestartNeeded = 3;
  bool has_manualrestartneeded() const;
  private:
  bool _internal_has_manualrestartneeded() const;
  public:
  void clear_manualrestartneeded();
  const ::grpc::UpdateManualRestartNeededEvent& manualrestartneeded() const;
  PROTOBUF_NODISCARD ::grpc::UpdateManualRestartNeededEvent* release_manualrestartneeded();
  ::grpc::UpdateManualRestartNeededEvent* mutable_manualrestartneeded();
  void set_allocated_manualrestartneeded(::grpc::UpdateManualRestartNeededEvent* manualrestartneeded);
  private:
  const ::grpc::UpdateManualRestartNeededEvent& _internal_manualrestartneeded() const;
  ::grpc::UpdateManualRestartNeededEvent* _internal_mutable_manualrestartneeded();
  public:
  void unsafe_arena_set_allocated_manualrestartneeded(
      ::grpc::UpdateManualRestartNeededEvent* manualrestartneeded);
  ::grpc::UpdateManualRestartNeededEvent* unsafe_arena_release_manualrestartneeded();

  // .grpc.UpdateForceEvent force = 4;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  const ::grpc::UpdateForceEvent& force() const;
  PROTOBUF_NODISCARD ::grpc::UpdateForceEvent* release_force();
  ::grpc::UpdateForceEvent* mutable_force();
  void set_allocated_force(::grpc::UpdateForceEvent* force);
  private:
  const ::grpc::UpdateForceEvent& _internal_force() const;
  ::grpc::UpdateForceEvent* _internal_mutable_force();
  public:
  void unsafe_arena_set_allocated_force(
      ::grpc::UpdateForceEvent* force);
  ::grpc::UpdateForceEvent* unsafe_arena_release_force();

  // .grpc.UpdateSilentRestartNeeded silentRestartNeeded = 5;
  bool has_silentrestartneeded() const;
  private:
  bool _internal_has_silentrestartneeded() const;
  public:
  void clear_silentrestartneeded();
  const ::grpc::UpdateSilentRestartNeeded& silentrestartneeded() const;
  PROTOBUF_NODISCARD ::grpc::UpdateSilentRestartNeeded* release_silentrestartneeded();
  ::grpc::UpdateSilentRestartNeeded* mutable_silentrestartneeded();
  void set_allocated_silentrestartneeded(::grpc::UpdateSilentRestartNeeded* silentrestartneeded);
  private:
  const ::grpc::UpdateSilentRestartNeeded& _internal_silentrestartneeded() const;
  ::grpc::UpdateSilentRestartNeeded* _internal_mutable_silentrestartneeded();
  public:
  void unsafe_arena_set_allocated_silentrestartneeded(
      ::grpc::UpdateSilentRestartNeeded* silentrestartneeded);
  ::grpc::UpdateSilentRestartNeeded* unsafe_arena_release_silentrestartneeded();

  // .grpc.UpdateIsLatestVersion isLatestVersion = 6;
  bool has_islatestversion() const;
  private:
  bool _internal_has_islatestversion() const;
  public:
  void clear_islatestversion();
  const ::grpc::UpdateIsLatestVersion& islatestversion() const;
  PROTOBUF_NODISCARD ::grpc::UpdateIsLatestVersion* release_islatestversion();
  ::grpc::UpdateIsLatestVersion* mutable_islatestversion();
  void set_allocated_islatestversion(::grpc::UpdateIsLatestVersion* islatestversion);
  private:
  const ::grpc::UpdateIsLatestVersion& _internal_islatestversion() const;
  ::grpc::UpdateIsLatestVersion* _internal_mutable_islatestversion();
  public:
  void unsafe_arena_set_allocated_islatestversion(
      ::grpc::UpdateIsLatestVersion* islatestversion);
  ::grpc::UpdateIsLatestVersion* unsafe_arena_release_islatestversion();

  // .grpc.UpdateCheckFinished checkFinished = 7;
  bool has_checkfinished() const;
  private:
  bool _internal_has_checkfinished() const;
  public:
  void clear_checkfinished();
  const ::grpc::UpdateCheckFinished& checkfinished() const;
  PROTOBUF_NODISCARD ::grpc::UpdateCheckFinished* release_checkfinished();
  ::grpc::UpdateCheckFinished* mutable_checkfinished();
  void set_allocated_checkfinished(::grpc::UpdateCheckFinished* checkfinished);
  private:
  const ::grpc::UpdateCheckFinished& _internal_checkfinished() const;
  ::grpc::UpdateCheckFinished* _internal_mutable_checkfinished();
  public:
  void unsafe_arena_set_allocated_checkfinished(
      ::grpc::UpdateCheckFinished* checkfinished);
  ::grpc::UpdateCheckFinished* unsafe_arena_release_checkfinished();

  // .grpc.UpdateVersionChanged versionChanged = 8;
  bool has_versionchanged() const;
  private:
  bool _internal_has_versionchanged() const;
  public:
  void clear_versionchanged();
  const ::grpc::UpdateVersionChanged& versionchanged() const;
  PROTOBUF_NODISCARD ::grpc::UpdateVersionChanged* release_versionchanged();
  ::grpc::UpdateVersionChanged* mutable_versionchanged();
  void set_allocated_versionchanged(::grpc::UpdateVersionChanged* versionchanged);
  private:
  const ::grpc::UpdateVersionChanged& _internal_versionchanged() const;
  ::grpc::UpdateVersionChanged* _internal_mutable_versionchanged();
  public:
  void unsafe_arena_set_allocated_versionchanged(
      ::grpc::UpdateVersionChanged* versionchanged);
  ::grpc::UpdateVersionChanged* unsafe_arena_release_versionchanged();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.UpdateEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_manualready();
  void set_has_manualrestartneeded();
  void set_has_force();
  void set_has_silentrestartneeded();
  void set_has_islatestversion();
  void set_has_checkfinished();
  void set_has_versionchanged();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::UpdateErrorEvent* error_;
      ::grpc::UpdateManualReadyEvent* manualready_;
      ::grpc::UpdateManualRestartNeededEvent* manualrestartneeded_;
      ::grpc::UpdateForceEvent* force_;
      ::grpc::UpdateSilentRestartNeeded* silentrestartneeded_;
      ::grpc::UpdateIsLatestVersion* islatestversion_;
      ::grpc::UpdateCheckFinished* checkfinished_;
      ::grpc::UpdateVersionChanged* versionchanged_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateErrorEvent) */ {
 public:
  inline UpdateErrorEvent() : UpdateErrorEvent(nullptr) {}
  ~UpdateErrorEvent() override;
  explicit PROTOBUF_CONSTEXPR UpdateErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateErrorEvent(const UpdateErrorEvent& from);
  UpdateErrorEvent(UpdateErrorEvent&& from) noexcept
    : UpdateErrorEvent() {
    *this = ::std::move(from);
  }

  inline UpdateErrorEvent& operator=(const UpdateErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateErrorEvent& operator=(UpdateErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateErrorEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateErrorEvent*>(
               &_UpdateErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UpdateErrorEvent& a, UpdateErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateErrorEvent& from) {
    UpdateErrorEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateErrorEvent";
  }
  protected:
  explicit UpdateErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .grpc.UpdateErrorType type = 1;
  void clear_type();
  ::grpc::UpdateErrorType type() const;
  void set_type(::grpc::UpdateErrorType value);
  private:
  ::grpc::UpdateErrorType _internal_type() const;
  void _internal_set_type(::grpc::UpdateErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.UpdateErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateManualReadyEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateManualReadyEvent) */ {
 public:
  inline UpdateManualReadyEvent() : UpdateManualReadyEvent(nullptr) {}
  ~UpdateManualReadyEvent() override;
  explicit PROTOBUF_CONSTEXPR UpdateManualReadyEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateManualReadyEvent(const UpdateManualReadyEvent& from);
  UpdateManualReadyEvent(UpdateManualReadyEvent&& from) noexcept
    : UpdateManualReadyEvent() {
    *this = ::std::move(from);
  }

  inline UpdateManualReadyEvent& operator=(const UpdateManualReadyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateManualReadyEvent& operator=(UpdateManualReadyEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateManualReadyEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateManualReadyEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateManualReadyEvent*>(
               &_UpdateManualReadyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateManualReadyEvent& a, UpdateManualReadyEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateManualReadyEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateManualReadyEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateManualReadyEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateManualReadyEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateManualReadyEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateManualReadyEvent& from) {
    UpdateManualReadyEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateManualReadyEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateManualReadyEvent";
  }
  protected:
  explicit UpdateManualReadyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UpdateManualReadyEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateManualRestartNeededEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateManualRestartNeededEvent) */ {
 public:
  inline UpdateManualRestartNeededEvent() : UpdateManualRestartNeededEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateManualRestartNeededEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateManualRestartNeededEvent(const UpdateManualRestartNeededEvent& from);
  UpdateManualRestartNeededEvent(UpdateManualRestartNeededEvent&& from) noexcept
    : UpdateManualRestartNeededEvent() {
    *this = ::std::move(from);
  }

  inline UpdateManualRestartNeededEvent& operator=(const UpdateManualRestartNeededEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateManualRestartNeededEvent& operator=(UpdateManualRestartNeededEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateManualRestartNeededEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateManualRestartNeededEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateManualRestartNeededEvent*>(
               &_UpdateManualRestartNeededEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UpdateManualRestartNeededEvent& a, UpdateManualRestartNeededEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateManualRestartNeededEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateManualRestartNeededEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateManualRestartNeededEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateManualRestartNeededEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateManualRestartNeededEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateManualRestartNeededEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateManualRestartNeededEvent";
  }
  protected:
  explicit UpdateManualRestartNeededEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateManualRestartNeededEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateForceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateForceEvent) */ {
 public:
  inline UpdateForceEvent() : UpdateForceEvent(nullptr) {}
  ~UpdateForceEvent() override;
  explicit PROTOBUF_CONSTEXPR UpdateForceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateForceEvent(const UpdateForceEvent& from);
  UpdateForceEvent(UpdateForceEvent&& from) noexcept
    : UpdateForceEvent() {
    *this = ::std::move(from);
  }

  inline UpdateForceEvent& operator=(const UpdateForceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateForceEvent& operator=(UpdateForceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateForceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateForceEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateForceEvent*>(
               &_UpdateForceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdateForceEvent& a, UpdateForceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateForceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateForceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateForceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateForceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateForceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateForceEvent& from) {
    UpdateForceEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateForceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateForceEvent";
  }
  protected:
  explicit UpdateForceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UpdateForceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateSilentRestartNeeded final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateSilentRestartNeeded) */ {
 public:
  inline UpdateSilentRestartNeeded() : UpdateSilentRestartNeeded(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateSilentRestartNeeded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSilentRestartNeeded(const UpdateSilentRestartNeeded& from);
  UpdateSilentRestartNeeded(UpdateSilentRestartNeeded&& from) noexcept
    : UpdateSilentRestartNeeded() {
    *this = ::std::move(from);
  }

  inline UpdateSilentRestartNeeded& operator=(const UpdateSilentRestartNeeded& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSilentRestartNeeded& operator=(UpdateSilentRestartNeeded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSilentRestartNeeded& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSilentRestartNeeded* internal_default_instance() {
    return reinterpret_cast<const UpdateSilentRestartNeeded*>(
               &_UpdateSilentRestartNeeded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UpdateSilentRestartNeeded& a, UpdateSilentRestartNeeded& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSilentRestartNeeded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSilentRestartNeeded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSilentRestartNeeded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSilentRestartNeeded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateSilentRestartNeeded& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateSilentRestartNeeded& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateSilentRestartNeeded";
  }
  protected:
  explicit UpdateSilentRestartNeeded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateSilentRestartNeeded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateIsLatestVersion final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateIsLatestVersion) */ {
 public:
  inline UpdateIsLatestVersion() : UpdateIsLatestVersion(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateIsLatestVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateIsLatestVersion(const UpdateIsLatestVersion& from);
  UpdateIsLatestVersion(UpdateIsLatestVersion&& from) noexcept
    : UpdateIsLatestVersion() {
    *this = ::std::move(from);
  }

  inline UpdateIsLatestVersion& operator=(const UpdateIsLatestVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateIsLatestVersion& operator=(UpdateIsLatestVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateIsLatestVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateIsLatestVersion* internal_default_instance() {
    return reinterpret_cast<const UpdateIsLatestVersion*>(
               &_UpdateIsLatestVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(UpdateIsLatestVersion& a, UpdateIsLatestVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateIsLatestVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateIsLatestVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateIsLatestVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateIsLatestVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateIsLatestVersion& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateIsLatestVersion& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateIsLatestVersion";
  }
  protected:
  explicit UpdateIsLatestVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateIsLatestVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateCheckFinished final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateCheckFinished) */ {
 public:
  inline UpdateCheckFinished() : UpdateCheckFinished(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateCheckFinished(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCheckFinished(const UpdateCheckFinished& from);
  UpdateCheckFinished(UpdateCheckFinished&& from) noexcept
    : UpdateCheckFinished() {
    *this = ::std::move(from);
  }

  inline UpdateCheckFinished& operator=(const UpdateCheckFinished& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCheckFinished& operator=(UpdateCheckFinished&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCheckFinished& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCheckFinished* internal_default_instance() {
    return reinterpret_cast<const UpdateCheckFinished*>(
               &_UpdateCheckFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UpdateCheckFinished& a, UpdateCheckFinished& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCheckFinished* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCheckFinished* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCheckFinished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCheckFinished>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateCheckFinished& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateCheckFinished& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateCheckFinished";
  }
  protected:
  explicit UpdateCheckFinished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateCheckFinished)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateVersionChanged final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateVersionChanged) */ {
 public:
  inline UpdateVersionChanged() : UpdateVersionChanged(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateVersionChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateVersionChanged(const UpdateVersionChanged& from);
  UpdateVersionChanged(UpdateVersionChanged&& from) noexcept
    : UpdateVersionChanged() {
    *this = ::std::move(from);
  }

  inline UpdateVersionChanged& operator=(const UpdateVersionChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateVersionChanged& operator=(UpdateVersionChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateVersionChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateVersionChanged* internal_default_instance() {
    return reinterpret_cast<const UpdateVersionChanged*>(
               &_UpdateVersionChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UpdateVersionChanged& a, UpdateVersionChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateVersionChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateVersionChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateVersionChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateVersionChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateVersionChanged& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateVersionChanged& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateVersionChanged";
  }
  protected:
  explicit UpdateVersionChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateVersionChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class DiskCacheEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.DiskCacheEvent) */ {
 public:
  inline DiskCacheEvent() : DiskCacheEvent(nullptr) {}
  ~DiskCacheEvent() override;
  explicit PROTOBUF_CONSTEXPR DiskCacheEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskCacheEvent(const DiskCacheEvent& from);
  DiskCacheEvent(DiskCacheEvent&& from) noexcept
    : DiskCacheEvent() {
    *this = ::std::move(from);
  }

  inline DiskCacheEvent& operator=(const DiskCacheEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskCacheEvent& operator=(DiskCacheEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskCacheEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kPathChanged = 2,
    kPathChangeFinished = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const DiskCacheEvent* internal_default_instance() {
    return reinterpret_cast<const DiskCacheEvent*>(
               &_DiskCacheEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DiskCacheEvent& a, DiskCacheEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskCacheEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskCacheEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskCacheEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskCacheEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskCacheEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiskCacheEvent& from) {
    DiskCacheEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskCacheEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.DiskCacheEvent";
  }
  protected:
  explicit DiskCacheEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kPathChangedFieldNumber = 2,
    kPathChangeFinishedFieldNumber = 3,
  };
  // .grpc.DiskCacheErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::DiskCacheErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::DiskCacheErrorEvent* release_error();
  ::grpc::DiskCacheErrorEvent* mutable_error();
  void set_allocated_error(::grpc::DiskCacheErrorEvent* error);
  private:
  const ::grpc::DiskCacheErrorEvent& _internal_error() const;
  ::grpc::DiskCacheErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::DiskCacheErrorEvent* error);
  ::grpc::DiskCacheErrorEvent* unsafe_arena_release_error();

  // .grpc.DiskCachePathChangedEvent pathChanged = 2;
  bool has_pathchanged() const;
  private:
  bool _internal_has_pathchanged() const;
  public:
  void clear_pathchanged();
  const ::grpc::DiskCachePathChangedEvent& pathchanged() const;
  PROTOBUF_NODISCARD ::grpc::DiskCachePathChangedEvent* release_pathchanged();
  ::grpc::DiskCachePathChangedEvent* mutable_pathchanged();
  void set_allocated_pathchanged(::grpc::DiskCachePathChangedEvent* pathchanged);
  private:
  const ::grpc::DiskCachePathChangedEvent& _internal_pathchanged() const;
  ::grpc::DiskCachePathChangedEvent* _internal_mutable_pathchanged();
  public:
  void unsafe_arena_set_allocated_pathchanged(
      ::grpc::DiskCachePathChangedEvent* pathchanged);
  ::grpc::DiskCachePathChangedEvent* unsafe_arena_release_pathchanged();

  // .grpc.DiskCachePathChangeFinishedEvent pathChangeFinished = 3;
  bool has_pathchangefinished() const;
  private:
  bool _internal_has_pathchangefinished() const;
  public:
  void clear_pathchangefinished();
  const ::grpc::DiskCachePathChangeFinishedEvent& pathchangefinished() const;
  PROTOBUF_NODISCARD ::grpc::DiskCachePathChangeFinishedEvent* release_pathchangefinished();
  ::grpc::DiskCachePathChangeFinishedEvent* mutable_pathchangefinished();
  void set_allocated_pathchangefinished(::grpc::DiskCachePathChangeFinishedEvent* pathchangefinished);
  private:
  const ::grpc::DiskCachePathChangeFinishedEvent& _internal_pathchangefinished() const;
  ::grpc::DiskCachePathChangeFinishedEvent* _internal_mutable_pathchangefinished();
  public:
  void unsafe_arena_set_allocated_pathchangefinished(
      ::grpc::DiskCachePathChangeFinishedEvent* pathchangefinished);
  ::grpc::DiskCachePathChangeFinishedEvent* unsafe_arena_release_pathchangefinished();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.DiskCacheEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_pathchanged();
  void set_has_pathchangefinished();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::DiskCacheErrorEvent* error_;
      ::grpc::DiskCachePathChangedEvent* pathchanged_;
      ::grpc::DiskCachePathChangeFinishedEvent* pathchangefinished_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class DiskCacheErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.DiskCacheErrorEvent) */ {
 public:
  inline DiskCacheErrorEvent() : DiskCacheErrorEvent(nullptr) {}
  ~DiskCacheErrorEvent() override;
  explicit PROTOBUF_CONSTEXPR DiskCacheErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskCacheErrorEvent(const DiskCacheErrorEvent& from);
  DiskCacheErrorEvent(DiskCacheErrorEvent&& from) noexcept
    : DiskCacheErrorEvent() {
    *this = ::std::move(from);
  }

  inline DiskCacheErrorEvent& operator=(const DiskCacheErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskCacheErrorEvent& operator=(DiskCacheErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskCacheErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskCacheErrorEvent* internal_default_instance() {
    return reinterpret_cast<const DiskCacheErrorEvent*>(
               &_DiskCacheErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DiskCacheErrorEvent& a, DiskCacheErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskCacheErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskCacheErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskCacheErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskCacheErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskCacheErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiskCacheErrorEvent& from) {
    DiskCacheErrorEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskCacheErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.DiskCacheErrorEvent";
  }
  protected:
  explicit DiskCacheErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .grpc.DiskCacheErrorType type = 1;
  void clear_type();
  ::grpc::DiskCacheErrorType type() const;
  void set_type(::grpc::DiskCacheErrorType value);
  private:
  ::grpc::DiskCacheErrorType _internal_type() const;
  void _internal_set_type(::grpc::DiskCacheErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.DiskCacheErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class DiskCachePathChangedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.DiskCachePathChangedEvent) */ {
 public:
  inline DiskCachePathChangedEvent() : DiskCachePathChangedEvent(nullptr) {}
  ~DiskCachePathChangedEvent() override;
  explicit PROTOBUF_CONSTEXPR DiskCachePathChangedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskCachePathChangedEvent(const DiskCachePathChangedEvent& from);
  DiskCachePathChangedEvent(DiskCachePathChangedEvent&& from) noexcept
    : DiskCachePathChangedEvent() {
    *this = ::std::move(from);
  }

  inline DiskCachePathChangedEvent& operator=(const DiskCachePathChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskCachePathChangedEvent& operator=(DiskCachePathChangedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskCachePathChangedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskCachePathChangedEvent* internal_default_instance() {
    return reinterpret_cast<const DiskCachePathChangedEvent*>(
               &_DiskCachePathChangedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(DiskCachePathChangedEvent& a, DiskCachePathChangedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskCachePathChangedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskCachePathChangedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskCachePathChangedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskCachePathChangedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskCachePathChangedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiskCachePathChangedEvent& from) {
    DiskCachePathChangedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskCachePathChangedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.DiskCachePathChangedEvent";
  }
  protected:
  explicit DiskCachePathChangedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:grpc.DiskCachePathChangedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class DiskCachePathChangeFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.DiskCachePathChangeFinishedEvent) */ {
 public:
  inline DiskCachePathChangeFinishedEvent() : DiskCachePathChangeFinishedEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DiskCachePathChangeFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskCachePathChangeFinishedEvent(const DiskCachePathChangeFinishedEvent& from);
  DiskCachePathChangeFinishedEvent(DiskCachePathChangeFinishedEvent&& from) noexcept
    : DiskCachePathChangeFinishedEvent() {
    *this = ::std::move(from);
  }

  inline DiskCachePathChangeFinishedEvent& operator=(const DiskCachePathChangeFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskCachePathChangeFinishedEvent& operator=(DiskCachePathChangeFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskCachePathChangeFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskCachePathChangeFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const DiskCachePathChangeFinishedEvent*>(
               &_DiskCachePathChangeFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(DiskCachePathChangeFinishedEvent& a, DiskCachePathChangeFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskCachePathChangeFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskCachePathChangeFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskCachePathChangeFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskCachePathChangeFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DiskCachePathChangeFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DiskCachePathChangeFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.DiskCachePathChangeFinishedEvent";
  }
  protected:
  explicit DiskCachePathChangeFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.DiskCachePathChangeFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class MailServerSettingsEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.MailServerSettingsEvent) */ {
 public:
  inline MailServerSettingsEvent() : MailServerSettingsEvent(nullptr) {}
  ~MailServerSettingsEvent() override;
  explicit PROTOBUF_CONSTEXPR MailServerSettingsEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailServerSettingsEvent(const MailServerSettingsEvent& from);
  MailServerSettingsEvent(MailServerSettingsEvent&& from) noexcept
    : MailServerSettingsEvent() {
    *this = ::std::move(from);
  }

  inline MailServerSettingsEvent& operator=(const MailServerSettingsEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailServerSettingsEvent& operator=(MailServerSettingsEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailServerSettingsEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kMailServerSettingsChanged = 2,
    kChangeMailServerSettingsFinished = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const MailServerSettingsEvent* internal_default_instance() {
    return reinterpret_cast<const MailServerSettingsEvent*>(
               &_MailServerSettingsEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MailServerSettingsEvent& a, MailServerSettingsEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MailServerSettingsEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailServerSettingsEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailServerSettingsEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailServerSettingsEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailServerSettingsEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailServerSettingsEvent& from) {
    MailServerSettingsEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailServerSettingsEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.MailServerSettingsEvent";
  }
  protected:
  explicit MailServerSettingsEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kMailServerSettingsChangedFieldNumber = 2,
    kChangeMailServerSettingsFinishedFieldNumber = 3,
  };
  // .grpc.MailServerSettingsErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::MailServerSettingsErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::MailServerSettingsErrorEvent* release_error();
  ::grpc::MailServerSettingsErrorEvent* mutable_error();
  void set_allocated_error(::grpc::MailServerSettingsErrorEvent* error);
  private:
  const ::grpc::MailServerSettingsErrorEvent& _internal_error() const;
  ::grpc::MailServerSettingsErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::MailServerSettingsErrorEvent* error);
  ::grpc::MailServerSettingsErrorEvent* unsafe_arena_release_error();

  // .grpc.MailServerSettingsChangedEvent mailServerSettingsChanged = 2;
  bool has_mailserversettingschanged() const;
  private:
  bool _internal_has_mailserversettingschanged() const;
  public:
  void clear_mailserversettingschanged();
  const ::grpc::MailServerSettingsChangedEvent& mailserversettingschanged() const;
  PROTOBUF_NODISCARD ::grpc::MailServerSettingsChangedEvent* release_mailserversettingschanged();
  ::grpc::MailServerSettingsChangedEvent* mutable_mailserversettingschanged();
  void set_allocated_mailserversettingschanged(::grpc::MailServerSettingsChangedEvent* mailserversettingschanged);
  private:
  const ::grpc::MailServerSettingsChangedEvent& _internal_mailserversettingschanged() const;
  ::grpc::MailServerSettingsChangedEvent* _internal_mutable_mailserversettingschanged();
  public:
  void unsafe_arena_set_allocated_mailserversettingschanged(
      ::grpc::MailServerSettingsChangedEvent* mailserversettingschanged);
  ::grpc::MailServerSettingsChangedEvent* unsafe_arena_release_mailserversettingschanged();

  // .grpc.ChangeMailServerSettingsFinishedEvent changeMailServerSettingsFinished = 3;
  bool has_changemailserversettingsfinished() const;
  private:
  bool _internal_has_changemailserversettingsfinished() const;
  public:
  void clear_changemailserversettingsfinished();
  const ::grpc::ChangeMailServerSettingsFinishedEvent& changemailserversettingsfinished() const;
  PROTOBUF_NODISCARD ::grpc::ChangeMailServerSettingsFinishedEvent* release_changemailserversettingsfinished();
  ::grpc::ChangeMailServerSettingsFinishedEvent* mutable_changemailserversettingsfinished();
  void set_allocated_changemailserversettingsfinished(::grpc::ChangeMailServerSettingsFinishedEvent* changemailserversettingsfinished);
  private:
  const ::grpc::ChangeMailServerSettingsFinishedEvent& _internal_changemailserversettingsfinished() const;
  ::grpc::ChangeMailServerSettingsFinishedEvent* _internal_mutable_changemailserversettingsfinished();
  public:
  void unsafe_arena_set_allocated_changemailserversettingsfinished(
      ::grpc::ChangeMailServerSettingsFinishedEvent* changemailserversettingsfinished);
  ::grpc::ChangeMailServerSettingsFinishedEvent* unsafe_arena_release_changemailserversettingsfinished();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.MailServerSettingsEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_mailserversettingschanged();
  void set_has_changemailserversettingsfinished();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::MailServerSettingsErrorEvent* error_;
      ::grpc::MailServerSettingsChangedEvent* mailserversettingschanged_;
      ::grpc::ChangeMailServerSettingsFinishedEvent* changemailserversettingsfinished_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class MailServerSettingsErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.MailServerSettingsErrorEvent) */ {
 public:
  inline MailServerSettingsErrorEvent() : MailServerSettingsErrorEvent(nullptr) {}
  ~MailServerSettingsErrorEvent() override;
  explicit PROTOBUF_CONSTEXPR MailServerSettingsErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailServerSettingsErrorEvent(const MailServerSettingsErrorEvent& from);
  MailServerSettingsErrorEvent(MailServerSettingsErrorEvent&& from) noexcept
    : MailServerSettingsErrorEvent() {
    *this = ::std::move(from);
  }

  inline MailServerSettingsErrorEvent& operator=(const MailServerSettingsErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailServerSettingsErrorEvent& operator=(MailServerSettingsErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailServerSettingsErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailServerSettingsErrorEvent* internal_default_instance() {
    return reinterpret_cast<const MailServerSettingsErrorEvent*>(
               &_MailServerSettingsErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(MailServerSettingsErrorEvent& a, MailServerSettingsErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MailServerSettingsErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailServerSettingsErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailServerSettingsErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailServerSettingsErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailServerSettingsErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailServerSettingsErrorEvent& from) {
    MailServerSettingsErrorEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailServerSettingsErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.MailServerSettingsErrorEvent";
  }
  protected:
  explicit MailServerSettingsErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .grpc.MailServerSettingsErrorType type = 1;
  void clear_type();
  ::grpc::MailServerSettingsErrorType type() const;
  void set_type(::grpc::MailServerSettingsErrorType value);
  private:
  ::grpc::MailServerSettingsErrorType _internal_type() const;
  void _internal_set_type(::grpc::MailServerSettingsErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.MailServerSettingsErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class MailServerSettingsChangedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.MailServerSettingsChangedEvent) */ {
 public:
  inline MailServerSettingsChangedEvent() : MailServerSettingsChangedEvent(nullptr) {}
  ~MailServerSettingsChangedEvent() override;
  explicit PROTOBUF_CONSTEXPR MailServerSettingsChangedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailServerSettingsChangedEvent(const MailServerSettingsChangedEvent& from);
  MailServerSettingsChangedEvent(MailServerSettingsChangedEvent&& from) noexcept
    : MailServerSettingsChangedEvent() {
    *this = ::std::move(from);
  }

  inline MailServerSettingsChangedEvent& operator=(const MailServerSettingsChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailServerSettingsChangedEvent& operator=(MailServerSettingsChangedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailServerSettingsChangedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailServerSettingsChangedEvent* internal_default_instance() {
    return reinterpret_cast<const MailServerSettingsChangedEvent*>(
               &_MailServerSettingsChangedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(MailServerSettingsChangedEvent& a, MailServerSettingsChangedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MailServerSettingsChangedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailServerSettingsChangedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailServerSettingsChangedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailServerSettingsChangedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailServerSettingsChangedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailServerSettingsChangedEvent& from) {
    MailServerSettingsChangedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailServerSettingsChangedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.MailServerSettingsChangedEvent";
  }
  protected:
  explicit MailServerSettingsChangedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
  };
  // .grpc.ImapSmtpSettings settings = 1;
  bool has_settings() const;
  private:
  bool _internal_has_settings() const;
  public:
  void clear_settings();
  const ::grpc::ImapSmtpSettings& settings() const;
  PROTOBUF_NODISCARD ::grpc::ImapSmtpSettings* release_settings();
  ::grpc::ImapSmtpSettings* mutable_settings();
  void set_allocated_settings(::grpc::ImapSmtpSettings* settings);
  private:
  const ::grpc::ImapSmtpSettings& _internal_settings() const;
  ::grpc::ImapSmtpSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::grpc::ImapSmtpSettings* settings);
  ::grpc::ImapSmtpSettings* unsafe_arena_release_settings();

  // @@protoc_insertion_point(class_scope:grpc.MailServerSettingsChangedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::grpc::ImapSmtpSettings* settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ChangeMailServerSettingsFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ChangeMailServerSettingsFinishedEvent) */ {
 public:
  inline ChangeMailServerSettingsFinishedEvent() : ChangeMailServerSettingsFinishedEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ChangeMailServerSettingsFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeMailServerSettingsFinishedEvent(const ChangeMailServerSettingsFinishedEvent& from);
  ChangeMailServerSettingsFinishedEvent(ChangeMailServerSettingsFinishedEvent&& from) noexcept
    : ChangeMailServerSettingsFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ChangeMailServerSettingsFinishedEvent& operator=(const ChangeMailServerSettingsFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeMailServerSettingsFinishedEvent& operator=(ChangeMailServerSettingsFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeMailServerSettingsFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeMailServerSettingsFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ChangeMailServerSettingsFinishedEvent*>(
               &_ChangeMailServerSettingsFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ChangeMailServerSettingsFinishedEvent& a, ChangeMailServerSettingsFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeMailServerSettingsFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeMailServerSettingsFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeMailServerSettingsFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeMailServerSettingsFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChangeMailServerSettingsFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChangeMailServerSettingsFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ChangeMailServerSettingsFinishedEvent";
  }
  protected:
  explicit ChangeMailServerSettingsFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ChangeMailServerSettingsFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class KeychainEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.KeychainEvent) */ {
 public:
  inline KeychainEvent() : KeychainEvent(nullptr) {}
  ~KeychainEvent() override;
  explicit PROTOBUF_CONSTEXPR KeychainEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeychainEvent(const KeychainEvent& from);
  KeychainEvent(KeychainEvent&& from) noexcept
    : KeychainEvent() {
    *this = ::std::move(from);
  }

  inline KeychainEvent& operator=(const KeychainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeychainEvent& operator=(KeychainEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeychainEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kChangeKeychainFinished = 1,
    kHasNoKeychain = 2,
    kRebuildKeychain = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const KeychainEvent* internal_default_instance() {
    return reinterpret_cast<const KeychainEvent*>(
               &_KeychainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(KeychainEvent& a, KeychainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeychainEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeychainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeychainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeychainEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeychainEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeychainEvent& from) {
    KeychainEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeychainEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.KeychainEvent";
  }
  protected:
  explicit KeychainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeKeychainFinishedFieldNumber = 1,
    kHasNoKeychainFieldNumber = 2,
    kRebuildKeychainFieldNumber = 3,
  };
  // .grpc.ChangeKeychainFinishedEvent changeKeychainFinished = 1;
  bool has_changekeychainfinished() const;
  private:
  bool _internal_has_changekeychainfinished() const;
  public:
  void clear_changekeychainfinished();
  const ::grpc::ChangeKeychainFinishedEvent& changekeychainfinished() const;
  PROTOBUF_NODISCARD ::grpc::ChangeKeychainFinishedEvent* release_changekeychainfinished();
  ::grpc::ChangeKeychainFinishedEvent* mutable_changekeychainfinished();
  void set_allocated_changekeychainfinished(::grpc::ChangeKeychainFinishedEvent* changekeychainfinished);
  private:
  const ::grpc::ChangeKeychainFinishedEvent& _internal_changekeychainfinished() const;
  ::grpc::ChangeKeychainFinishedEvent* _internal_mutable_changekeychainfinished();
  public:
  void unsafe_arena_set_allocated_changekeychainfinished(
      ::grpc::ChangeKeychainFinishedEvent* changekeychainfinished);
  ::grpc::ChangeKeychainFinishedEvent* unsafe_arena_release_changekeychainfinished();

  // .grpc.HasNoKeychainEvent hasNoKeychain = 2;
  bool has_hasnokeychain() const;
  private:
  bool _internal_has_hasnokeychain() const;
  public:
  void clear_hasnokeychain();
  const ::grpc::HasNoKeychainEvent& hasnokeychain() const;
  PROTOBUF_NODISCARD ::grpc::HasNoKeychainEvent* release_hasnokeychain();
  ::grpc::HasNoKeychainEvent* mutable_hasnokeychain();
  void set_allocated_hasnokeychain(::grpc::HasNoKeychainEvent* hasnokeychain);
  private:
  const ::grpc::HasNoKeychainEvent& _internal_hasnokeychain() const;
  ::grpc::HasNoKeychainEvent* _internal_mutable_hasnokeychain();
  public:
  void unsafe_arena_set_allocated_hasnokeychain(
      ::grpc::HasNoKeychainEvent* hasnokeychain);
  ::grpc::HasNoKeychainEvent* unsafe_arena_release_hasnokeychain();

  // .grpc.RebuildKeychainEvent rebuildKeychain = 3;
  bool has_rebuildkeychain() const;
  private:
  bool _internal_has_rebuildkeychain() const;
  public:
  void clear_rebuildkeychain();
  const ::grpc::RebuildKeychainEvent& rebuildkeychain() const;
  PROTOBUF_NODISCARD ::grpc::RebuildKeychainEvent* release_rebuildkeychain();
  ::grpc::RebuildKeychainEvent* mutable_rebuildkeychain();
  void set_allocated_rebuildkeychain(::grpc::RebuildKeychainEvent* rebuildkeychain);
  private:
  const ::grpc::RebuildKeychainEvent& _internal_rebuildkeychain() const;
  ::grpc::RebuildKeychainEvent* _internal_mutable_rebuildkeychain();
  public:
  void unsafe_arena_set_allocated_rebuildkeychain(
      ::grpc::RebuildKeychainEvent* rebuildkeychain);
  ::grpc::RebuildKeychainEvent* unsafe_arena_release_rebuildkeychain();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.KeychainEvent)
 private:
  class _Internal;
  void set_has_changekeychainfinished();
  void set_has_hasnokeychain();
  void set_has_rebuildkeychain();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::ChangeKeychainFinishedEvent* changekeychainfinished_;
      ::grpc::HasNoKeychainEvent* hasnokeychain_;
      ::grpc::RebuildKeychainEvent* rebuildkeychain_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ChangeKeychainFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ChangeKeychainFinishedEvent) */ {
 public:
  inline ChangeKeychainFinishedEvent() : ChangeKeychainFinishedEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ChangeKeychainFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeKeychainFinishedEvent(const ChangeKeychainFinishedEvent& from);
  ChangeKeychainFinishedEvent(ChangeKeychainFinishedEvent&& from) noexcept
    : ChangeKeychainFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ChangeKeychainFinishedEvent& operator=(const ChangeKeychainFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeKeychainFinishedEvent& operator=(ChangeKeychainFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeKeychainFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeKeychainFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ChangeKeychainFinishedEvent*>(
               &_ChangeKeychainFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ChangeKeychainFinishedEvent& a, ChangeKeychainFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeKeychainFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeKeychainFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeKeychainFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeKeychainFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChangeKeychainFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChangeKeychainFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ChangeKeychainFinishedEvent";
  }
  protected:
  explicit ChangeKeychainFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ChangeKeychainFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class HasNoKeychainEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.HasNoKeychainEvent) */ {
 public:
  inline HasNoKeychainEvent() : HasNoKeychainEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HasNoKeychainEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HasNoKeychainEvent(const HasNoKeychainEvent& from);
  HasNoKeychainEvent(HasNoKeychainEvent&& from) noexcept
    : HasNoKeychainEvent() {
    *this = ::std::move(from);
  }

  inline HasNoKeychainEvent& operator=(const HasNoKeychainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HasNoKeychainEvent& operator=(HasNoKeychainEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HasNoKeychainEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const HasNoKeychainEvent* internal_default_instance() {
    return reinterpret_cast<const HasNoKeychainEvent*>(
               &_HasNoKeychainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(HasNoKeychainEvent& a, HasNoKeychainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(HasNoKeychainEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HasNoKeychainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HasNoKeychainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HasNoKeychainEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HasNoKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HasNoKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.HasNoKeychainEvent";
  }
  protected:
  explicit HasNoKeychainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.HasNoKeychainEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class RebuildKeychainEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.RebuildKeychainEvent) */ {
 public:
  inline RebuildKeychainEvent() : RebuildKeychainEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RebuildKeychainEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RebuildKeychainEvent(const RebuildKeychainEvent& from);
  RebuildKeychainEvent(RebuildKeychainEvent&& from) noexcept
    : RebuildKeychainEvent() {
    *this = ::std::move(from);
  }

  inline RebuildKeychainEvent& operator=(const RebuildKeychainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RebuildKeychainEvent& operator=(RebuildKeychainEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RebuildKeychainEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RebuildKeychainEvent* internal_default_instance() {
    return reinterpret_cast<const RebuildKeychainEvent*>(
               &_RebuildKeychainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(RebuildKeychainEvent& a, RebuildKeychainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RebuildKeychainEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RebuildKeychainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RebuildKeychainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RebuildKeychainEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RebuildKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RebuildKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.RebuildKeychainEvent";
  }
  protected:
  explicit RebuildKeychainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.RebuildKeychainEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class MailEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.MailEvent) */ {
 public:
  inline MailEvent() : MailEvent(nullptr) {}
  ~MailEvent() override;
  explicit PROTOBUF_CONSTEXPR MailEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailEvent(const MailEvent& from);
  MailEvent(MailEvent&& from) noexcept
    : MailEvent() {
    *this = ::std::move(from);
  }

  inline MailEvent& operator=(const MailEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailEvent& operator=(MailEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kNoActiveKeyForRecipientEvent = 1,
    kAddressChanged = 2,
    kAddressChangedLogout = 3,
    kApiCertIssue = 6,
    EVENT_NOT_SET = 0,
  };

  static inline const MailEvent* internal_default_instance() {
    return reinterpret_cast<const MailEvent*>(
               &_MailEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(MailEvent& a, MailEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MailEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MailEvent& from) {
    MailEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.MailEvent";
  }
  protected:
  explicit MailEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoActiveKeyForRecipientEventFieldNumber = 1,
    kAddressChangedFieldNumber = 2,
    kAddressChangedLogoutFieldNumber = 3,
    kApiCertIssueFieldNumber = 6,
  };
  // .grpc.NoActiveKeyForRecipientEvent noActiveKeyForRecipientEvent = 1;
  bool has_noactivekeyforrecipientevent() const;
  private:
  bool _internal_has_noactivekeyforrecipientevent() const;
  public:
  void clear_noactivekeyforrecipientevent();
  const ::grpc::NoActiveKeyForRecipientEvent& noactivekeyforrecipientevent() const;
  PROTOBUF_NODISCARD ::grpc::NoActiveKeyForRecipientEvent* release_noactivekeyforrecipientevent();
  ::grpc::NoActiveKeyForRecipientEvent* mutable_noactivekeyforrecipientevent();
  void set_allocated_noactivekeyforrecipientevent(::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent);
  private:
  const ::grpc::NoActiveKeyForRecipientEvent& _internal_noactivekeyforrecipientevent() const;
  ::grpc::NoActiveKeyForRecipientEvent* _internal_mutable_noactivekeyforrecipientevent();
  public:
  void unsafe_arena_set_allocated_noactivekeyforrecipientevent(
      ::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent);
  ::grpc::NoActiveKeyForRecipientEvent* unsafe_arena_release_noactivekeyforrecipientevent();

  // .grpc.AddressChangedEvent addressChanged = 2;
  bool has_addresschanged() const;
  private:
  bool _internal_has_addresschanged() const;
  public:
  void clear_addresschanged();
  const ::grpc::AddressChangedEvent& addresschanged() const;
  PROTOBUF_NODISCARD ::grpc::AddressChangedEvent* release_addresschanged();
  ::grpc::AddressChangedEvent* mutable_addresschanged();
  void set_allocated_addresschanged(::grpc::AddressChangedEvent* addresschanged);
  private:
  const ::grpc::AddressChangedEvent& _internal_addresschanged() const;
  ::grpc::AddressChangedEvent* _internal_mutable_addresschanged();
  public:
  void unsafe_arena_set_allocated_addresschanged(
      ::grpc::AddressChangedEvent* addresschanged);
  ::grpc::AddressChangedEvent* unsafe_arena_release_addresschanged();

  // .grpc.AddressChangedLogoutEvent addressChangedLogout = 3;
  bool has_addresschangedlogout() const;
  private:
  bool _internal_has_addresschangedlogout() const;
  public:
  void clear_addresschangedlogout();
  const ::grpc::AddressChangedLogoutEvent& addresschangedlogout() const;
  PROTOBUF_NODISCARD ::grpc::AddressChangedLogoutEvent* release_addresschangedlogout();
  ::grpc::AddressChangedLogoutEvent* mutable_addresschangedlogout();
  void set_allocated_addresschangedlogout(::grpc::AddressChangedLogoutEvent* addresschangedlogout);
  private:
  const ::grpc::AddressChangedLogoutEvent& _internal_addresschangedlogout() const;
  ::grpc::AddressChangedLogoutEvent* _internal_mutable_addresschangedlogout();
  public:
  void unsafe_arena_set_allocated_addresschangedlogout(
      ::grpc::AddressChangedLogoutEvent* addresschangedlogout);
  ::grpc::AddressChangedLogoutEvent* unsafe_arena_release_addresschangedlogout();

  // .grpc.ApiCertIssueEvent apiCertIssue = 6;
  bool has_apicertissue() const;
  private:
  bool _internal_has_apicertissue() const;
  public:
  void clear_apicertissue();
  const ::grpc::ApiCertIssueEvent& apicertissue() const;
  PROTOBUF_NODISCARD ::grpc::ApiCertIssueEvent* release_apicertissue();
  ::grpc::ApiCertIssueEvent* mutable_apicertissue();
  void set_allocated_apicertissue(::grpc::ApiCertIssueEvent* apicertissue);
  private:
  const ::grpc::ApiCertIssueEvent& _internal_apicertissue() const;
  ::grpc::ApiCertIssueEvent* _internal_mutable_apicertissue();
  public:
  void unsafe_arena_set_allocated_apicertissue(
      ::grpc::ApiCertIssueEvent* apicertissue);
  ::grpc::ApiCertIssueEvent* unsafe_arena_release_apicertissue();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.MailEvent)
 private:
  class _Internal;
  void set_has_noactivekeyforrecipientevent();
  void set_has_addresschanged();
  void set_has_addresschangedlogout();
  void set_has_apicertissue();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent_;
      ::grpc::AddressChangedEvent* addresschanged_;
      ::grpc::AddressChangedLogoutEvent* addresschangedlogout_;
      ::grpc::ApiCertIssueEvent* apicertissue_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class NoActiveKeyForRecipientEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.NoActiveKeyForRecipientEvent) */ {
 public:
  inline NoActiveKeyForRecipientEvent() : NoActiveKeyForRecipientEvent(nullptr) {}
  ~NoActiveKeyForRecipientEvent() override;
  explicit PROTOBUF_CONSTEXPR NoActiveKeyForRecipientEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoActiveKeyForRecipientEvent(const NoActiveKeyForRecipientEvent& from);
  NoActiveKeyForRecipientEvent(NoActiveKeyForRecipientEvent&& from) noexcept
    : NoActiveKeyForRecipientEvent() {
    *this = ::std::move(from);
  }

  inline NoActiveKeyForRecipientEvent& operator=(const NoActiveKeyForRecipientEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoActiveKeyForRecipientEvent& operator=(NoActiveKeyForRecipientEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoActiveKeyForRecipientEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoActiveKeyForRecipientEvent* internal_default_instance() {
    return reinterpret_cast<const NoActiveKeyForRecipientEvent*>(
               &_NoActiveKeyForRecipientEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(NoActiveKeyForRecipientEvent& a, NoActiveKeyForRecipientEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(NoActiveKeyForRecipientEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoActiveKeyForRecipientEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoActiveKeyForRecipientEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoActiveKeyForRecipientEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoActiveKeyForRecipientEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NoActiveKeyForRecipientEvent& from) {
    NoActiveKeyForRecipientEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoActiveKeyForRecipientEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.NoActiveKeyForRecipientEvent";
  }
  protected:
  explicit NoActiveKeyForRecipientEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:grpc.NoActiveKeyForRecipientEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AddressChangedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AddressChangedEvent) */ {
 public:
  inline AddressChangedEvent() : AddressChangedEvent(nullptr) {}
  ~AddressChangedEvent() override;
  explicit PROTOBUF_CONSTEXPR AddressChangedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressChangedEvent(const AddressChangedEvent& from);
  AddressChangedEvent(AddressChangedEvent&& from) noexcept
    : AddressChangedEvent() {
    *this = ::std::move(from);
  }

  inline AddressChangedEvent& operator=(const AddressChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressChangedEvent& operator=(AddressChangedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressChangedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressChangedEvent* internal_default_instance() {
    return reinterpret_cast<const AddressChangedEvent*>(
               &_AddressChangedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(AddressChangedEvent& a, AddressChangedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressChangedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressChangedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddressChangedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddressChangedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressChangedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddressChangedEvent& from) {
    AddressChangedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressChangedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AddressChangedEvent";
  }
  protected:
  explicit AddressChangedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:grpc.AddressChangedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AddressChangedLogoutEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AddressChangedLogoutEvent) */ {
 public:
  inline AddressChangedLogoutEvent() : AddressChangedLogoutEvent(nullptr) {}
  ~AddressChangedLogoutEvent() override;
  explicit PROTOBUF_CONSTEXPR AddressChangedLogoutEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressChangedLogoutEvent(const AddressChangedLogoutEvent& from);
  AddressChangedLogoutEvent(AddressChangedLogoutEvent&& from) noexcept
    : AddressChangedLogoutEvent() {
    *this = ::std::move(from);
  }

  inline AddressChangedLogoutEvent& operator=(const AddressChangedLogoutEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressChangedLogoutEvent& operator=(AddressChangedLogoutEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressChangedLogoutEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressChangedLogoutEvent* internal_default_instance() {
    return reinterpret_cast<const AddressChangedLogoutEvent*>(
               &_AddressChangedLogoutEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(AddressChangedLogoutEvent& a, AddressChangedLogoutEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressChangedLogoutEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressChangedLogoutEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddressChangedLogoutEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddressChangedLogoutEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressChangedLogoutEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddressChangedLogoutEvent& from) {
    AddressChangedLogoutEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressChangedLogoutEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AddressChangedLogoutEvent";
  }
  protected:
  explicit AddressChangedLogoutEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:grpc.AddressChangedLogoutEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ApiCertIssueEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ApiCertIssueEvent) */ {
 public:
  inline ApiCertIssueEvent() : ApiCertIssueEvent(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ApiCertIssueEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiCertIssueEvent(const ApiCertIssueEvent& from);
  ApiCertIssueEvent(ApiCertIssueEvent&& from) noexcept
    : ApiCertIssueEvent() {
    *this = ::std::move(from);
  }

  inline ApiCertIssueEvent& operator=(const ApiCertIssueEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiCertIssueEvent& operator=(ApiCertIssueEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiCertIssueEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiCertIssueEvent* internal_default_instance() {
    return reinterpret_cast<const ApiCertIssueEvent*>(
               &_ApiCertIssueEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ApiCertIssueEvent& a, ApiCertIssueEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiCertIssueEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiCertIssueEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiCertIssueEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApiCertIssueEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ApiCertIssueEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ApiCertIssueEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ApiCertIssueEvent";
  }
  protected:
  explicit ApiCertIssueEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ApiCertIssueEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserEvent) */ {
 public:
  inline UserEvent() : UserEvent(nullptr) {}
  ~UserEvent() override;
  explicit PROTOBUF_CONSTEXPR UserEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserEvent(const UserEvent& from);
  UserEvent(UserEvent&& from) noexcept
    : UserEvent() {
    *this = ::std::move(from);
  }

  inline UserEvent& operator=(const UserEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserEvent& operator=(UserEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kToggleSplitModeFinished = 1,
    kUserDisconnected = 2,
    kUserChanged = 3,
    kUserBadEvent = 4,
    kUsedBytesChangedEvent = 5,
    kImapLoginFailedEvent = 6,
    kSyncStartedEvent = 7,
    kSyncFinishedEvent = 8,
    kSyncProgressEvent = 9,
    EVENT_NOT_SET = 0,
  };

  static inline const UserEvent* internal_default_instance() {
    return reinterpret_cast<const UserEvent*>(
               &_UserEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(UserEvent& a, UserEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserEvent& from) {
    UserEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserEvent";
  }
  protected:
  explicit UserEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToggleSplitModeFinishedFieldNumber = 1,
    kUserDisconnectedFieldNumber = 2,
    kUserChangedFieldNumber = 3,
    kUserBadEventFieldNumber = 4,
    kUsedBytesChangedEventFieldNumber = 5,
    kImapLoginFailedEventFieldNumber = 6,
    kSyncStartedEventFieldNumber = 7,
    kSyncFinishedEventFieldNumber = 8,
    kSyncProgressEventFieldNumber = 9,
  };
  // .grpc.ToggleSplitModeFinishedEvent toggleSplitModeFinished = 1;
  bool has_togglesplitmodefinished() const;
  private:
  bool _internal_has_togglesplitmodefinished() const;
  public:
  void clear_togglesplitmodefinished();
  const ::grpc::ToggleSplitModeFinishedEvent& togglesplitmodefinished() const;
  PROTOBUF_NODISCARD ::grpc::ToggleSplitModeFinishedEvent* release_togglesplitmodefinished();
  ::grpc::ToggleSplitModeFinishedEvent* mutable_togglesplitmodefinished();
  void set_allocated_togglesplitmodefinished(::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished);
  private:
  const ::grpc::ToggleSplitModeFinishedEvent& _internal_togglesplitmodefinished() const;
  ::grpc::ToggleSplitModeFinishedEvent* _internal_mutable_togglesplitmodefinished();
  public:
  void unsafe_arena_set_allocated_togglesplitmodefinished(
      ::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished);
  ::grpc::ToggleSplitModeFinishedEvent* unsafe_arena_release_togglesplitmodefinished();

  // .grpc.UserDisconnectedEvent userDisconnected = 2;
  bool has_userdisconnected() const;
  private:
  bool _internal_has_userdisconnected() const;
  public:
  void clear_userdisconnected();
  const ::grpc::UserDisconnectedEvent& userdisconnected() const;
  PROTOBUF_NODISCARD ::grpc::UserDisconnectedEvent* release_userdisconnected();
  ::grpc::UserDisconnectedEvent* mutable_userdisconnected();
  void set_allocated_userdisconnected(::grpc::UserDisconnectedEvent* userdisconnected);
  private:
  const ::grpc::UserDisconnectedEvent& _internal_userdisconnected() const;
  ::grpc::UserDisconnectedEvent* _internal_mutable_userdisconnected();
  public:
  void unsafe_arena_set_allocated_userdisconnected(
      ::grpc::UserDisconnectedEvent* userdisconnected);
  ::grpc::UserDisconnectedEvent* unsafe_arena_release_userdisconnected();

  // .grpc.UserChangedEvent userChanged = 3;
  bool has_userchanged() const;
  private:
  bool _internal_has_userchanged() const;
  public:
  void clear_userchanged();
  const ::grpc::UserChangedEvent& userchanged() const;
  PROTOBUF_NODISCARD ::grpc::UserChangedEvent* release_userchanged();
  ::grpc::UserChangedEvent* mutable_userchanged();
  void set_allocated_userchanged(::grpc::UserChangedEvent* userchanged);
  private:
  const ::grpc::UserChangedEvent& _internal_userchanged() const;
  ::grpc::UserChangedEvent* _internal_mutable_userchanged();
  public:
  void unsafe_arena_set_allocated_userchanged(
      ::grpc::UserChangedEvent* userchanged);
  ::grpc::UserChangedEvent* unsafe_arena_release_userchanged();

  // .grpc.UserBadEvent userBadEvent = 4;
  bool has_userbadevent() const;
  private:
  bool _internal_has_userbadevent() const;
  public:
  void clear_userbadevent();
  const ::grpc::UserBadEvent& userbadevent() const;
  PROTOBUF_NODISCARD ::grpc::UserBadEvent* release_userbadevent();
  ::grpc::UserBadEvent* mutable_userbadevent();
  void set_allocated_userbadevent(::grpc::UserBadEvent* userbadevent);
  private:
  const ::grpc::UserBadEvent& _internal_userbadevent() const;
  ::grpc::UserBadEvent* _internal_mutable_userbadevent();
  public:
  void unsafe_arena_set_allocated_userbadevent(
      ::grpc::UserBadEvent* userbadevent);
  ::grpc::UserBadEvent* unsafe_arena_release_userbadevent();

  // .grpc.UsedBytesChangedEvent usedBytesChangedEvent = 5;
  bool has_usedbyteschangedevent() const;
  private:
  bool _internal_has_usedbyteschangedevent() const;
  public:
  void clear_usedbyteschangedevent();
  const ::grpc::UsedBytesChangedEvent& usedbyteschangedevent() const;
  PROTOBUF_NODISCARD ::grpc::UsedBytesChangedEvent* release_usedbyteschangedevent();
  ::grpc::UsedBytesChangedEvent* mutable_usedbyteschangedevent();
  void set_allocated_usedbyteschangedevent(::grpc::UsedBytesChangedEvent* usedbyteschangedevent);
  private:
  const ::grpc::UsedBytesChangedEvent& _internal_usedbyteschangedevent() const;
  ::grpc::UsedBytesChangedEvent* _internal_mutable_usedbyteschangedevent();
  public:
  void unsafe_arena_set_allocated_usedbyteschangedevent(
      ::grpc::UsedBytesChangedEvent* usedbyteschangedevent);
  ::grpc::UsedBytesChangedEvent* unsafe_arena_release_usedbyteschangedevent();

  // .grpc.ImapLoginFailedEvent imapLoginFailedEvent = 6;
  bool has_imaploginfailedevent() const;
  private:
  bool _internal_has_imaploginfailedevent() const;
  public:
  void clear_imaploginfailedevent();
  const ::grpc::ImapLoginFailedEvent& imaploginfailedevent() const;
  PROTOBUF_NODISCARD ::grpc::ImapLoginFailedEvent* release_imaploginfailedevent();
  ::grpc::ImapLoginFailedEvent* mutable_imaploginfailedevent();
  void set_allocated_imaploginfailedevent(::grpc::ImapLoginFailedEvent* imaploginfailedevent);
  private:
  const ::grpc::ImapLoginFailedEvent& _internal_imaploginfailedevent() const;
  ::grpc::ImapLoginFailedEvent* _internal_mutable_imaploginfailedevent();
  public:
  void unsafe_arena_set_allocated_imaploginfailedevent(
      ::grpc::ImapLoginFailedEvent* imaploginfailedevent);
  ::grpc::ImapLoginFailedEvent* unsafe_arena_release_imaploginfailedevent();

  // .grpc.SyncStartedEvent syncStartedEvent = 7;
  bool has_syncstartedevent() const;
  private:
  bool _internal_has_syncstartedevent() const;
  public:
  void clear_syncstartedevent();
  const ::grpc::SyncStartedEvent& syncstartedevent() const;
  PROTOBUF_NODISCARD ::grpc::SyncStartedEvent* release_syncstartedevent();
  ::grpc::SyncStartedEvent* mutable_syncstartedevent();
  void set_allocated_syncstartedevent(::grpc::SyncStartedEvent* syncstartedevent);
  private:
  const ::grpc::SyncStartedEvent& _internal_syncstartedevent() const;
  ::grpc::SyncStartedEvent* _internal_mutable_syncstartedevent();
  public:
  void unsafe_arena_set_allocated_syncstartedevent(
      ::grpc::SyncStartedEvent* syncstartedevent);
  ::grpc::SyncStartedEvent* unsafe_arena_release_syncstartedevent();

  // .grpc.SyncFinishedEvent syncFinishedEvent = 8;
  bool has_syncfinishedevent() const;
  private:
  bool _internal_has_syncfinishedevent() const;
  public:
  void clear_syncfinishedevent();
  const ::grpc::SyncFinishedEvent& syncfinishedevent() const;
  PROTOBUF_NODISCARD ::grpc::SyncFinishedEvent* release_syncfinishedevent();
  ::grpc::SyncFinishedEvent* mutable_syncfinishedevent();
  void set_allocated_syncfinishedevent(::grpc::SyncFinishedEvent* syncfinishedevent);
  private:
  const ::grpc::SyncFinishedEvent& _internal_syncfinishedevent() const;
  ::grpc::SyncFinishedEvent* _internal_mutable_syncfinishedevent();
  public:
  void unsafe_arena_set_allocated_syncfinishedevent(
      ::grpc::SyncFinishedEvent* syncfinishedevent);
  ::grpc::SyncFinishedEvent* unsafe_arena_release_syncfinishedevent();

  // .grpc.SyncProgressEvent syncProgressEvent = 9;
  bool has_syncprogressevent() const;
  private:
  bool _internal_has_syncprogressevent() const;
  public:
  void clear_syncprogressevent();
  const ::grpc::SyncProgressEvent& syncprogressevent() const;
  PROTOBUF_NODISCARD ::grpc::SyncProgressEvent* release_syncprogressevent();
  ::grpc::SyncProgressEvent* mutable_syncprogressevent();
  void set_allocated_syncprogressevent(::grpc::SyncProgressEvent* syncprogressevent);
  private:
  const ::grpc::SyncProgressEvent& _internal_syncprogressevent() const;
  ::grpc::SyncProgressEvent* _internal_mutable_syncprogressevent();
  public:
  void unsafe_arena_set_allocated_syncprogressevent(
      ::grpc::SyncProgressEvent* syncprogressevent);
  ::grpc::SyncProgressEvent* unsafe_arena_release_syncprogressevent();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.UserEvent)
 private:
  class _Internal;
  void set_has_togglesplitmodefinished();
  void set_has_userdisconnected();
  void set_has_userchanged();
  void set_has_userbadevent();
  void set_has_usedbyteschangedevent();
  void set_has_imaploginfailedevent();
  void set_has_syncstartedevent();
  void set_has_syncfinishedevent();
  void set_has_syncprogressevent();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished_;
      ::grpc::UserDisconnectedEvent* userdisconnected_;
      ::grpc::UserChangedEvent* userchanged_;
      ::grpc::UserBadEvent* userbadevent_;
      ::grpc::UsedBytesChangedEvent* usedbyteschangedevent_;
      ::grpc::ImapLoginFailedEvent* imaploginfailedevent_;
      ::grpc::SyncStartedEvent* syncstartedevent_;
      ::grpc::SyncFinishedEvent* syncfinishedevent_;
      ::grpc::SyncProgressEvent* syncprogressevent_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ToggleSplitModeFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ToggleSplitModeFinishedEvent) */ {
 public:
  inline ToggleSplitModeFinishedEvent() : ToggleSplitModeFinishedEvent(nullptr) {}
  ~ToggleSplitModeFinishedEvent() override;
  explicit PROTOBUF_CONSTEXPR ToggleSplitModeFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleSplitModeFinishedEvent(const ToggleSplitModeFinishedEvent& from);
  ToggleSplitModeFinishedEvent(ToggleSplitModeFinishedEvent&& from) noexcept
    : ToggleSplitModeFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ToggleSplitModeFinishedEvent& operator=(const ToggleSplitModeFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleSplitModeFinishedEvent& operator=(ToggleSplitModeFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToggleSplitModeFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleSplitModeFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ToggleSplitModeFinishedEvent*>(
               &_ToggleSplitModeFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ToggleSplitModeFinishedEvent& a, ToggleSplitModeFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ToggleSplitModeFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleSplitModeFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleSplitModeFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleSplitModeFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToggleSplitModeFinishedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ToggleSplitModeFinishedEvent& from) {
    ToggleSplitModeFinishedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToggleSplitModeFinishedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ToggleSplitModeFinishedEvent";
  }
  protected:
  explicit ToggleSplitModeFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:grpc.ToggleSplitModeFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserDisconnectedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserDisconnectedEvent) */ {
 public:
  inline UserDisconnectedEvent() : UserDisconnectedEvent(nullptr) {}
  ~UserDisconnectedEvent() override;
  explicit PROTOBUF_CONSTEXPR UserDisconnectedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDisconnectedEvent(const UserDisconnectedEvent& from);
  UserDisconnectedEvent(UserDisconnectedEvent&& from) noexcept
    : UserDisconnectedEvent() {
    *this = ::std::move(from);
  }

  inline UserDisconnectedEvent& operator=(const UserDisconnectedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDisconnectedEvent& operator=(UserDisconnectedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDisconnectedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDisconnectedEvent* internal_default_instance() {
    return reinterpret_cast<const UserDisconnectedEvent*>(
               &_UserDisconnectedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(UserDisconnectedEvent& a, UserDisconnectedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDisconnectedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDisconnectedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDisconnectedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDisconnectedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserDisconnectedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserDisconnectedEvent& from) {
    UserDisconnectedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDisconnectedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserDisconnectedEvent";
  }
  protected:
  explicit UserDisconnectedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserDisconnectedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserChangedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserChangedEvent) */ {
 public:
  inline UserChangedEvent() : UserChangedEvent(nullptr) {}
  ~UserChangedEvent() override;
  explicit PROTOBUF_CONSTEXPR UserChangedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserChangedEvent(const UserChangedEvent& from);
  UserChangedEvent(UserChangedEvent&& from) noexcept
    : UserChangedEvent() {
    *this = ::std::move(from);
  }

  inline UserChangedEvent& operator=(const UserChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserChangedEvent& operator=(UserChangedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserChangedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserChangedEvent* internal_default_instance() {
    return reinterpret_cast<const UserChangedEvent*>(
               &_UserChangedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(UserChangedEvent& a, UserChangedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserChangedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserChangedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserChangedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserChangedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserChangedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserChangedEvent& from) {
    UserChangedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserChangedEvent";
  }
  protected:
  explicit UserChangedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserChangedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserBadEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserBadEvent) */ {
 public:
  inline UserBadEvent() : UserBadEvent(nullptr) {}
  ~UserBadEvent() override;
  explicit PROTOBUF_CONSTEXPR UserBadEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserBadEvent(const UserBadEvent& from);
  UserBadEvent(UserBadEvent&& from) noexcept
    : UserBadEvent() {
    *this = ::std::move(from);
  }

  inline UserBadEvent& operator=(const UserBadEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserBadEvent& operator=(UserBadEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserBadEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserBadEvent* internal_default_instance() {
    return reinterpret_cast<const UserBadEvent*>(
               &_UserBadEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(UserBadEvent& a, UserBadEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserBadEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserBadEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserBadEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserBadEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserBadEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserBadEvent& from) {
    UserBadEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserBadEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserBadEvent";
  }
  protected:
  explicit UserBadEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string errorMessage = 2;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserBadEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UsedBytesChangedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UsedBytesChangedEvent) */ {
 public:
  inline UsedBytesChangedEvent() : UsedBytesChangedEvent(nullptr) {}
  ~UsedBytesChangedEvent() override;
  explicit PROTOBUF_CONSTEXPR UsedBytesChangedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsedBytesChangedEvent(const UsedBytesChangedEvent& from);
  UsedBytesChangedEvent(UsedBytesChangedEvent&& from) noexcept
    : UsedBytesChangedEvent() {
    *this = ::std::move(from);
  }

  inline UsedBytesChangedEvent& operator=(const UsedBytesChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsedBytesChangedEvent& operator=(UsedBytesChangedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsedBytesChangedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsedBytesChangedEvent* internal_default_instance() {
    return reinterpret_cast<const UsedBytesChangedEvent*>(
               &_UsedBytesChangedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(UsedBytesChangedEvent& a, UsedBytesChangedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UsedBytesChangedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsedBytesChangedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsedBytesChangedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsedBytesChangedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsedBytesChangedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsedBytesChangedEvent& from) {
    UsedBytesChangedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsedBytesChangedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UsedBytesChangedEvent";
  }
  protected:
  explicit UsedBytesChangedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kUsedBytesFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // int64 usedBytes = 2;
  void clear_usedbytes();
  int64_t usedbytes() const;
  void set_usedbytes(int64_t value);
  private:
  int64_t _internal_usedbytes() const;
  void _internal_set_usedbytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.UsedBytesChangedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    int64_t usedbytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ImapLoginFailedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ImapLoginFailedEvent) */ {
 public:
  inline ImapLoginFailedEvent() : ImapLoginFailedEvent(nullptr) {}
  ~ImapLoginFailedEvent() override;
  explicit PROTOBUF_CONSTEXPR ImapLoginFailedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImapLoginFailedEvent(const ImapLoginFailedEvent& from);
  ImapLoginFailedEvent(ImapLoginFailedEvent&& from) noexcept
    : ImapLoginFailedEvent() {
    *this = ::std::move(from);
  }

  inline ImapLoginFailedEvent& operator=(const ImapLoginFailedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImapLoginFailedEvent& operator=(ImapLoginFailedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImapLoginFailedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImapLoginFailedEvent* internal_default_instance() {
    return reinterpret_cast<const ImapLoginFailedEvent*>(
               &_ImapLoginFailedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ImapLoginFailedEvent& a, ImapLoginFailedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ImapLoginFailedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImapLoginFailedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImapLoginFailedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImapLoginFailedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImapLoginFailedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImapLoginFailedEvent& from) {
    ImapLoginFailedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImapLoginFailedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ImapLoginFailedEvent";
  }
  protected:
  explicit ImapLoginFailedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:grpc.ImapLoginFailedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class SyncStartedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.SyncStartedEvent) */ {
 public:
  inline SyncStartedEvent() : SyncStartedEvent(nullptr) {}
  ~SyncStartedEvent() override;
  explicit PROTOBUF_CONSTEXPR SyncStartedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncStartedEvent(const SyncStartedEvent& from);
  SyncStartedEvent(SyncStartedEvent&& from) noexcept
    : SyncStartedEvent() {
    *this = ::std::move(from);
  }

  inline SyncStartedEvent& operator=(const SyncStartedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncStartedEvent& operator=(SyncStartedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncStartedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncStartedEvent* internal_default_instance() {
    return reinterpret_cast<const SyncStartedEvent*>(
               &_SyncStartedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(SyncStartedEvent& a, SyncStartedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncStartedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncStartedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncStartedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncStartedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncStartedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncStartedEvent& from) {
    SyncStartedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncStartedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.SyncStartedEvent";
  }
  protected:
  explicit SyncStartedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:grpc.SyncStartedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class SyncFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.SyncFinishedEvent) */ {
 public:
  inline SyncFinishedEvent() : SyncFinishedEvent(nullptr) {}
  ~SyncFinishedEvent() override;
  explicit PROTOBUF_CONSTEXPR SyncFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncFinishedEvent(const SyncFinishedEvent& from);
  SyncFinishedEvent(SyncFinishedEvent&& from) noexcept
    : SyncFinishedEvent() {
    *this = ::std::move(from);
  }

  inline SyncFinishedEvent& operator=(const SyncFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncFinishedEvent& operator=(SyncFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const SyncFinishedEvent*>(
               &_SyncFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(SyncFinishedEvent& a, SyncFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncFinishedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncFinishedEvent& from) {
    SyncFinishedEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncFinishedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.SyncFinishedEvent";
  }
  protected:
  explicit SyncFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:grpc.SyncFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class SyncProgressEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.SyncProgressEvent) */ {
 public:
  inline SyncProgressEvent() : SyncProgressEvent(nullptr) {}
  ~SyncProgressEvent() override;
  explicit PROTOBUF_CONSTEXPR SyncProgressEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncProgressEvent(const SyncProgressEvent& from);
  SyncProgressEvent(SyncProgressEvent&& from) noexcept
    : SyncProgressEvent() {
    *this = ::std::move(from);
  }

  inline SyncProgressEvent& operator=(const SyncProgressEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncProgressEvent& operator=(SyncProgressEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncProgressEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncProgressEvent* internal_default_instance() {
    return reinterpret_cast<const SyncProgressEvent*>(
               &_SyncProgressEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(SyncProgressEvent& a, SyncProgressEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncProgressEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncProgressEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncProgressEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncProgressEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncProgressEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncProgressEvent& from) {
    SyncProgressEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncProgressEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.SyncProgressEvent";
  }
  protected:
  explicit SyncProgressEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kProgressFieldNumber = 2,
    kElapsedMsFieldNumber = 3,
    kRemainingMsFieldNumber = 4,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // double progress = 2;
  void clear_progress();
  double progress() const;
  void set_progress(double value);
  private:
  double _internal_progress() const;
  void _internal_set_progress(double value);
  public:

  // int64 elapsedMs = 3;
  void clear_elapsedms();
  int64_t elapsedms() const;
  void set_elapsedms(int64_t value);
  private:
  int64_t _internal_elapsedms() const;
  void _internal_set_elapsedms(int64_t value);
  public:

  // int64 remainingMs = 4;
  void clear_remainingms();
  int64_t remainingms() const;
  void set_remainingms(int64_t value);
  private:
  int64_t _internal_remainingms() const;
  void _internal_set_remainingms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.SyncProgressEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    double progress_;
    int64_t elapsedms_;
    int64_t remainingms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class GenericErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.GenericErrorEvent) */ {
 public:
  inline GenericErrorEvent() : GenericErrorEvent(nullptr) {}
  ~GenericErrorEvent() override;
  explicit PROTOBUF_CONSTEXPR GenericErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenericErrorEvent(const GenericErrorEvent& from);
  GenericErrorEvent(GenericErrorEvent&& from) noexcept
    : GenericErrorEvent() {
    *this = ::std::move(from);
  }

  inline GenericErrorEvent& operator=(const GenericErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericErrorEvent& operator=(GenericErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenericErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenericErrorEvent* internal_default_instance() {
    return reinterpret_cast<const GenericErrorEvent*>(
               &_GenericErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(GenericErrorEvent& a, GenericErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenericErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenericErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenericErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GenericErrorEvent& from) {
    GenericErrorEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.GenericErrorEvent";
  }
  protected:
  explicit GenericErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // .grpc.ErrorCode code = 1;
  void clear_code();
  ::grpc::ErrorCode code() const;
  void set_code(::grpc::ErrorCode value);
  private:
  ::grpc::ErrorCode _internal_code() const;
  void _internal_set_code(::grpc::ErrorCode value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.GenericErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bridge_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddLogEntryRequest

// .grpc.LogLevel level = 1;
inline void AddLogEntryRequest::clear_level() {
  _impl_.level_ = 0;
}
inline ::grpc::LogLevel AddLogEntryRequest::_internal_level() const {
  return static_cast< ::grpc::LogLevel >(_impl_.level_);
}
inline ::grpc::LogLevel AddLogEntryRequest::level() const {
  // @@protoc_insertion_point(field_get:grpc.AddLogEntryRequest.level)
  return _internal_level();
}
inline void AddLogEntryRequest::_internal_set_level(::grpc::LogLevel value) {
  
  _impl_.level_ = value;
}
inline void AddLogEntryRequest::set_level(::grpc::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:grpc.AddLogEntryRequest.level)
}

// string package = 2;
inline void AddLogEntryRequest::clear_package() {
  _impl_.package_.ClearToEmpty();
}
inline const std::string& AddLogEntryRequest::package() const {
  // @@protoc_insertion_point(field_get:grpc.AddLogEntryRequest.package)
  return _internal_package();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddLogEntryRequest::set_package(ArgT0&& arg0, ArgT... args) {
 
 _impl_.package_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.AddLogEntryRequest.package)
}
inline std::string* AddLogEntryRequest::mutable_package() {
  std::string* _s = _internal_mutable_package();
  // @@protoc_insertion_point(field_mutable:grpc.AddLogEntryRequest.package)
  return _s;
}
inline const std::string& AddLogEntryRequest::_internal_package() const {
  return _impl_.package_.Get();
}
inline void AddLogEntryRequest::_internal_set_package(const std::string& value) {
  
  _impl_.package_.Set(value, GetArenaForAllocation());
}
inline std::string* AddLogEntryRequest::_internal_mutable_package() {
  
  return _impl_.package_.Mutable(GetArenaForAllocation());
}
inline std::string* AddLogEntryRequest::release_package() {
  // @@protoc_insertion_point(field_release:grpc.AddLogEntryRequest.package)
  return _impl_.package_.Release();
}
inline void AddLogEntryRequest::set_allocated_package(std::string* package) {
  if (package != nullptr) {
    
  } else {
    
  }
  _impl_.package_.SetAllocated(package, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.package_.IsDefault()) {
    _impl_.package_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.AddLogEntryRequest.package)
}

// string message = 3;
inline void AddLogEntryRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AddLogEntryRequest::message() const {
  // @@protoc_insertion_point(field_get:grpc.AddLogEntryRequest.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddLogEntryRequest::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.AddLogEntryRequest.message)
}
inline std::string* AddLogEntryRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:grpc.AddLogEntryRequest.message)
  return _s;
}
inline const std::string& AddLogEntryRequest::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AddLogEntryRequest::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AddLogEntryRequest::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AddLogEntryRequest::release_message() {
  // @@protoc_insertion_point(field_release:grpc.AddLogEntryRequest.message)
  return _impl_.message_.Release();
}
inline void AddLogEntryRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.AddLogEntryRequest.message)
}

// -------------------------------------------------------------------

// GuiReadyResponse

// bool showSplashScreen = 1;
inline void GuiReadyResponse::clear_showsplashscreen() {
  _impl_.showsplashscreen_ = false;
}
inline bool GuiReadyResponse::_internal_showsplashscreen() const {
  return _impl_.showsplashscreen_;
}
inline bool GuiReadyResponse::showsplashscreen() const {
  // @@protoc_insertion_point(field_get:grpc.GuiReadyResponse.showSplashScreen)
  return _internal_showsplashscreen();
}
inline void GuiReadyResponse::_internal_set_showsplashscreen(bool value) {
  
  _impl_.showsplashscreen_ = value;
}
inline void GuiReadyResponse::set_showsplashscreen(bool value) {
  _internal_set_showsplashscreen(value);
  // @@protoc_insertion_point(field_set:grpc.GuiReadyResponse.showSplashScreen)
}

// -------------------------------------------------------------------

// ReportBugRequest

// string osType = 1;
inline void ReportBugRequest::clear_ostype() {
  _impl_.ostype_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::ostype() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.osType)
  return _internal_ostype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_ostype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ostype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.osType)
}
inline std::string* ReportBugRequest::mutable_ostype() {
  std::string* _s = _internal_mutable_ostype();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.osType)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_ostype() const {
  return _impl_.ostype_.Get();
}
inline void ReportBugRequest::_internal_set_ostype(const std::string& value) {
  
  _impl_.ostype_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_ostype() {
  
  return _impl_.ostype_.Mutable(GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_ostype() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.osType)
  return _impl_.ostype_.Release();
}
inline void ReportBugRequest::set_allocated_ostype(std::string* ostype) {
  if (ostype != nullptr) {
    
  } else {
    
  }
  _impl_.ostype_.SetAllocated(ostype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ostype_.IsDefault()) {
    _impl_.ostype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.osType)
}

// string osVersion = 2;
inline void ReportBugRequest::clear_osversion() {
  _impl_.osversion_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::osversion() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.osVersion)
  return _internal_osversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_osversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.osversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.osVersion)
}
inline std::string* ReportBugRequest::mutable_osversion() {
  std::string* _s = _internal_mutable_osversion();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.osVersion)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_osversion() const {
  return _impl_.osversion_.Get();
}
inline void ReportBugRequest::_internal_set_osversion(const std::string& value) {
  
  _impl_.osversion_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_osversion() {
  
  return _impl_.osversion_.Mutable(GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_osversion() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.osVersion)
  return _impl_.osversion_.Release();
}
inline void ReportBugRequest::set_allocated_osversion(std::string* osversion) {
  if (osversion != nullptr) {
    
  } else {
    
  }
  _impl_.osversion_.SetAllocated(osversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.osversion_.IsDefault()) {
    _impl_.osversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.osVersion)
}

// string description = 3;
inline void ReportBugRequest::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::description() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.description)
}
inline std::string* ReportBugRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.description)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ReportBugRequest::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_description() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.description)
  return _impl_.description_.Release();
}
inline void ReportBugRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.description)
}

// string address = 4;
inline void ReportBugRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::address() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.address)
}
inline std::string* ReportBugRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.address)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void ReportBugRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_address() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.address)
  return _impl_.address_.Release();
}
inline void ReportBugRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.address)
}

// string emailClient = 5;
inline void ReportBugRequest::clear_emailclient() {
  _impl_.emailclient_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::emailclient() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.emailClient)
  return _internal_emailclient();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_emailclient(ArgT0&& arg0, ArgT... args) {
 
 _impl_.emailclient_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.emailClient)
}
inline std::string* ReportBugRequest::mutable_emailclient() {
  std::string* _s = _internal_mutable_emailclient();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.emailClient)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_emailclient() const {
  return _impl_.emailclient_.Get();
}
inline void ReportBugRequest::_internal_set_emailclient(const std::string& value) {
  
  _impl_.emailclient_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_emailclient() {
  
  return _impl_.emailclient_.Mutable(GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_emailclient() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.emailClient)
  return _impl_.emailclient_.Release();
}
inline void ReportBugRequest::set_allocated_emailclient(std::string* emailclient) {
  if (emailclient != nullptr) {
    
  } else {
    
  }
  _impl_.emailclient_.SetAllocated(emailclient, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.emailclient_.IsDefault()) {
    _impl_.emailclient_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.emailClient)
}

// bool includeLogs = 6;
inline void ReportBugRequest::clear_includelogs() {
  _impl_.includelogs_ = false;
}
inline bool ReportBugRequest::_internal_includelogs() const {
  return _impl_.includelogs_;
}
inline bool ReportBugRequest::includelogs() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.includeLogs)
  return _internal_includelogs();
}
inline void ReportBugRequest::_internal_set_includelogs(bool value) {
  
  _impl_.includelogs_ = value;
}
inline void ReportBugRequest::set_includelogs(bool value) {
  _internal_set_includelogs(value);
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.includeLogs)
}

// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:grpc.LoginRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:grpc.LoginRequest.username)
  return _impl_.username_.Release();
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginRequest.username)
}

// bytes password = 2;
inline void LoginRequest::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:grpc.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:grpc.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:grpc.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginAbortRequest

// string username = 1;
inline void LoginAbortRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginAbortRequest::username() const {
  // @@protoc_insertion_point(field_get:grpc.LoginAbortRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginAbortRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginAbortRequest.username)
}
inline std::string* LoginAbortRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.LoginAbortRequest.username)
  return _s;
}
inline const std::string& LoginAbortRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginAbortRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginAbortRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginAbortRequest::release_username() {
  // @@protoc_insertion_point(field_release:grpc.LoginAbortRequest.username)
  return _impl_.username_.Release();
}
inline void LoginAbortRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginAbortRequest.username)
}

// -------------------------------------------------------------------

// ImapSmtpSettings

// int32 imapPort = 1;
inline void ImapSmtpSettings::clear_imapport() {
  _impl_.imapport_ = 0;
}
inline int32_t ImapSmtpSettings::_internal_imapport() const {
  return _impl_.imapport_;
}
inline int32_t ImapSmtpSettings::imapport() const {
  // @@protoc_insertion_point(field_get:grpc.ImapSmtpSettings.imapPort)
  return _internal_imapport();
}
inline void ImapSmtpSettings::_internal_set_imapport(int32_t value) {
  
  _impl_.imapport_ = value;
}
inline void ImapSmtpSettings::set_imapport(int32_t value) {
  _internal_set_imapport(value);
  // @@protoc_insertion_point(field_set:grpc.ImapSmtpSettings.imapPort)
}

// int32 smtpPort = 2;
inline void ImapSmtpSettings::clear_smtpport() {
  _impl_.smtpport_ = 0;
}
inline int32_t ImapSmtpSettings::_internal_smtpport() const {
  return _impl_.smtpport_;
}
inline int32_t ImapSmtpSettings::smtpport() const {
  // @@protoc_insertion_point(field_get:grpc.ImapSmtpSettings.smtpPort)
  return _internal_smtpport();
}
inline void ImapSmtpSettings::_internal_set_smtpport(int32_t value) {
  
  _impl_.smtpport_ = value;
}
inline void ImapSmtpSettings::set_smtpport(int32_t value) {
  _internal_set_smtpport(value);
  // @@protoc_insertion_point(field_set:grpc.ImapSmtpSettings.smtpPort)
}

// bool useSSLForImap = 3;
inline void ImapSmtpSettings::clear_usesslforimap() {
  _impl_.usesslforimap_ = false;
}
inline bool ImapSmtpSettings::_internal_usesslforimap() const {
  return _impl_.usesslforimap_;
}
inline bool ImapSmtpSettings::usesslforimap() const {
  // @@protoc_insertion_point(field_get:grpc.ImapSmtpSettings.useSSLForImap)
  return _internal_usesslforimap();
}
inline void ImapSmtpSettings::_internal_set_usesslforimap(bool value) {
  
  _impl_.usesslforimap_ = value;
}
inline void ImapSmtpSettings::set_usesslforimap(bool value) {
  _internal_set_usesslforimap(value);
  // @@protoc_insertion_point(field_set:grpc.ImapSmtpSettings.useSSLForImap)
}

// bool useSSLForSmtp = 4;
inline void ImapSmtpSettings::clear_usesslforsmtp() {
  _impl_.usesslforsmtp_ = false;
}
inline bool ImapSmtpSettings::_internal_usesslforsmtp() const {
  return _impl_.usesslforsmtp_;
}
inline bool ImapSmtpSettings::usesslforsmtp() const {
  // @@protoc_insertion_point(field_get:grpc.ImapSmtpSettings.useSSLForSmtp)
  return _internal_usesslforsmtp();
}
inline void ImapSmtpSettings::_internal_set_usesslforsmtp(bool value) {
  
  _impl_.usesslforsmtp_ = value;
}
inline void ImapSmtpSettings::set_usesslforsmtp(bool value) {
  _internal_set_usesslforsmtp(value);
  // @@protoc_insertion_point(field_set:grpc.ImapSmtpSettings.useSSLForSmtp)
}

// -------------------------------------------------------------------

// AvailableKeychainsResponse

// repeated string keychains = 1;
inline int AvailableKeychainsResponse::_internal_keychains_size() const {
  return _impl_.keychains_.size();
}
inline int AvailableKeychainsResponse::keychains_size() const {
  return _internal_keychains_size();
}
inline void AvailableKeychainsResponse::clear_keychains() {
  _impl_.keychains_.Clear();
}
inline std::string* AvailableKeychainsResponse::add_keychains() {
  std::string* _s = _internal_add_keychains();
  // @@protoc_insertion_point(field_add_mutable:grpc.AvailableKeychainsResponse.keychains)
  return _s;
}
inline const std::string& AvailableKeychainsResponse::_internal_keychains(int index) const {
  return _impl_.keychains_.Get(index);
}
inline const std::string& AvailableKeychainsResponse::keychains(int index) const {
  // @@protoc_insertion_point(field_get:grpc.AvailableKeychainsResponse.keychains)
  return _internal_keychains(index);
}
inline std::string* AvailableKeychainsResponse::mutable_keychains(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.AvailableKeychainsResponse.keychains)
  return _impl_.keychains_.Mutable(index);
}
inline void AvailableKeychainsResponse::set_keychains(int index, const std::string& value) {
  _impl_.keychains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::set_keychains(int index, std::string&& value) {
  _impl_.keychains_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::set_keychains(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keychains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::set_keychains(int index, const char* value, size_t size) {
  _impl_.keychains_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.AvailableKeychainsResponse.keychains)
}
inline std::string* AvailableKeychainsResponse::_internal_add_keychains() {
  return _impl_.keychains_.Add();
}
inline void AvailableKeychainsResponse::add_keychains(const std::string& value) {
  _impl_.keychains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::add_keychains(std::string&& value) {
  _impl_.keychains_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::add_keychains(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.keychains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::add_keychains(const char* value, size_t size) {
  _impl_.keychains_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.AvailableKeychainsResponse.keychains)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AvailableKeychainsResponse::keychains() const {
  // @@protoc_insertion_point(field_list:grpc.AvailableKeychainsResponse.keychains)
  return _impl_.keychains_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AvailableKeychainsResponse::mutable_keychains() {
  // @@protoc_insertion_point(field_mutable_list:grpc.AvailableKeychainsResponse.keychains)
  return &_impl_.keychains_;
}

// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:grpc.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:grpc.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return _impl_.id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:grpc.User.id)
  return _impl_.id_.Release();
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.id)
}

// string username = 2;
inline void User::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:grpc.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.username)
}
inline std::string* User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  return _impl_.username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:grpc.User.username)
  return _impl_.username_.Release();
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.username)
}

// string avatarText = 3;
inline void User::clear_avatartext() {
  _impl_.avatartext_.ClearToEmpty();
}
inline const std::string& User::avatartext() const {
  // @@protoc_insertion_point(field_get:grpc.User.avatarText)
  return _internal_avatartext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_avatartext(ArgT0&& arg0, ArgT... args) {
 
 _impl_.avatartext_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.avatarText)
}
inline std::string* User::mutable_avatartext() {
  std::string* _s = _internal_mutable_avatartext();
  // @@protoc_insertion_point(field_mutable:grpc.User.avatarText)
  return _s;
}
inline const std::string& User::_internal_avatartext() const {
  return _impl_.avatartext_.Get();
}
inline void User::_internal_set_avatartext(const std::string& value) {
  
  _impl_.avatartext_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_avatartext() {
  
  return _impl_.avatartext_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_avatartext() {
  // @@protoc_insertion_point(field_release:grpc.User.avatarText)
  return _impl_.avatartext_.Release();
}
inline void User::set_allocated_avatartext(std::string* avatartext) {
  if (avatartext != nullptr) {
    
  } else {
    
  }
  _impl_.avatartext_.SetAllocated(avatartext, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatartext_.IsDefault()) {
    _impl_.avatartext_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.avatarText)
}

// .grpc.UserState state = 4;
inline void User::clear_state() {
  _impl_.state_ = 0;
}
inline ::grpc::UserState User::_internal_state() const {
  return static_cast< ::grpc::UserState >(_impl_.state_);
}
inline ::grpc::UserState User::state() const {
  // @@protoc_insertion_point(field_get:grpc.User.state)
  return _internal_state();
}
inline void User::_internal_set_state(::grpc::UserState value) {
  
  _impl_.state_ = value;
}
inline void User::set_state(::grpc::UserState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:grpc.User.state)
}

// bool splitMode = 5;
inline void User::clear_splitmode() {
  _impl_.splitmode_ = false;
}
inline bool User::_internal_splitmode() const {
  return _impl_.splitmode_;
}
inline bool User::splitmode() const {
  // @@protoc_insertion_point(field_get:grpc.User.splitMode)
  return _internal_splitmode();
}
inline void User::_internal_set_splitmode(bool value) {
  
  _impl_.splitmode_ = value;
}
inline void User::set_splitmode(bool value) {
  _internal_set_splitmode(value);
  // @@protoc_insertion_point(field_set:grpc.User.splitMode)
}

// int64 usedBytes = 6;
inline void User::clear_usedbytes() {
  _impl_.usedbytes_ = int64_t{0};
}
inline int64_t User::_internal_usedbytes() const {
  return _impl_.usedbytes_;
}
inline int64_t User::usedbytes() const {
  // @@protoc_insertion_point(field_get:grpc.User.usedBytes)
  return _internal_usedbytes();
}
inline void User::_internal_set_usedbytes(int64_t value) {
  
  _impl_.usedbytes_ = value;
}
inline void User::set_usedbytes(int64_t value) {
  _internal_set_usedbytes(value);
  // @@protoc_insertion_point(field_set:grpc.User.usedBytes)
}

// int64 totalBytes = 7;
inline void User::clear_totalbytes() {
  _impl_.totalbytes_ = int64_t{0};
}
inline int64_t User::_internal_totalbytes() const {
  return _impl_.totalbytes_;
}
inline int64_t User::totalbytes() const {
  // @@protoc_insertion_point(field_get:grpc.User.totalBytes)
  return _internal_totalbytes();
}
inline void User::_internal_set_totalbytes(int64_t value) {
  
  _impl_.totalbytes_ = value;
}
inline void User::set_totalbytes(int64_t value) {
  _internal_set_totalbytes(value);
  // @@protoc_insertion_point(field_set:grpc.User.totalBytes)
}

// bytes password = 8;
inline void User::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& User::password() const {
  // @@protoc_insertion_point(field_get:grpc.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.password)
}
inline std::string* User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:grpc.User.password)
  return _s;
}
inline const std::string& User::_internal_password() const {
  return _impl_.password_.Get();
}
inline void User::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_password() {
  // @@protoc_insertion_point(field_release:grpc.User.password)
  return _impl_.password_.Release();
}
inline void User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.password)
}

// repeated string addresses = 9;
inline int User::_internal_addresses_size() const {
  return _impl_.addresses_.size();
}
inline int User::addresses_size() const {
  return _internal_addresses_size();
}
inline void User::clear_addresses() {
  _impl_.addresses_.Clear();
}
inline std::string* User::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:grpc.User.addresses)
  return _s;
}
inline const std::string& User::_internal_addresses(int index) const {
  return _impl_.addresses_.Get(index);
}
inline const std::string& User::addresses(int index) const {
  // @@protoc_insertion_point(field_get:grpc.User.addresses)
  return _internal_addresses(index);
}
inline std::string* User::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.User.addresses)
  return _impl_.addresses_.Mutable(index);
}
inline void User::set_addresses(int index, const std::string& value) {
  _impl_.addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.User.addresses)
}
inline void User::set_addresses(int index, std::string&& value) {
  _impl_.addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.User.addresses)
}
inline void User::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.User.addresses)
}
inline void User::set_addresses(int index, const char* value, size_t size) {
  _impl_.addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.User.addresses)
}
inline std::string* User::_internal_add_addresses() {
  return _impl_.addresses_.Add();
}
inline void User::add_addresses(const std::string& value) {
  _impl_.addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.User.addresses)
}
inline void User::add_addresses(std::string&& value) {
  _impl_.addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.User.addresses)
}
inline void User::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.User.addresses)
}
inline void User::add_addresses(const char* value, size_t size) {
  _impl_.addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.User.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
User::addresses() const {
  // @@protoc_insertion_point(field_list:grpc.User.addresses)
  return _impl_.addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
User::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:grpc.User.addresses)
  return &_impl_.addresses_;
}

// -------------------------------------------------------------------

// UserSplitModeRequest

// string userID = 1;
inline void UserSplitModeRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserSplitModeRequest::userid() const {
  // @@protoc_insertion_point(field_get:grpc.UserSplitModeRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSplitModeRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserSplitModeRequest.userID)
}
inline std::string* UserSplitModeRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.UserSplitModeRequest.userID)
  return _s;
}
inline const std::string& UserSplitModeRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserSplitModeRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserSplitModeRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserSplitModeRequest::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.UserSplitModeRequest.userID)
  return _impl_.userid_.Release();
}
inline void UserSplitModeRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserSplitModeRequest.userID)
}

// bool active = 2;
inline void UserSplitModeRequest::clear_active() {
  _impl_.active_ = false;
}
inline bool UserSplitModeRequest::_internal_active() const {
  return _impl_.active_;
}
inline bool UserSplitModeRequest::active() const {
  // @@protoc_insertion_point(field_get:grpc.UserSplitModeRequest.active)
  return _internal_active();
}
inline void UserSplitModeRequest::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void UserSplitModeRequest::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:grpc.UserSplitModeRequest.active)
}

// -------------------------------------------------------------------

// UserBadEventFeedbackRequest

// string userID = 1;
inline void UserBadEventFeedbackRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserBadEventFeedbackRequest::userid() const {
  // @@protoc_insertion_point(field_get:grpc.UserBadEventFeedbackRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserBadEventFeedbackRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserBadEventFeedbackRequest.userID)
}
inline std::string* UserBadEventFeedbackRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.UserBadEventFeedbackRequest.userID)
  return _s;
}
inline const std::string& UserBadEventFeedbackRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserBadEventFeedbackRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserBadEventFeedbackRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserBadEventFeedbackRequest::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.UserBadEventFeedbackRequest.userID)
  return _impl_.userid_.Release();
}
inline void UserBadEventFeedbackRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserBadEventFeedbackRequest.userID)
}

// bool doResync = 2;
inline void UserBadEventFeedbackRequest::clear_doresync() {
  _impl_.doresync_ = false;
}
inline bool UserBadEventFeedbackRequest::_internal_doresync() const {
  return _impl_.doresync_;
}
inline bool UserBadEventFeedbackRequest::doresync() const {
  // @@protoc_insertion_point(field_get:grpc.UserBadEventFeedbackRequest.doResync)
  return _internal_doresync();
}
inline void UserBadEventFeedbackRequest::_internal_set_doresync(bool value) {
  
  _impl_.doresync_ = value;
}
inline void UserBadEventFeedbackRequest::set_doresync(bool value) {
  _internal_set_doresync(value);
  // @@protoc_insertion_point(field_set:grpc.UserBadEventFeedbackRequest.doResync)
}

// -------------------------------------------------------------------

// UserListResponse

// repeated .grpc.User users = 1;
inline int UserListResponse::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int UserListResponse::users_size() const {
  return _internal_users_size();
}
inline void UserListResponse::clear_users() {
  _impl_.users_.Clear();
}
inline ::grpc::User* UserListResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.UserListResponse.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >*
UserListResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:grpc.UserListResponse.users)
  return &_impl_.users_;
}
inline const ::grpc::User& UserListResponse::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::grpc::User& UserListResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:grpc.UserListResponse.users)
  return _internal_users(index);
}
inline ::grpc::User* UserListResponse::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::grpc::User* UserListResponse::add_users() {
  ::grpc::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:grpc.UserListResponse.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >&
UserListResponse::users() const {
  // @@protoc_insertion_point(field_list:grpc.UserListResponse.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// ConfigureAppleMailRequest

// string userID = 1;
inline void ConfigureAppleMailRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& ConfigureAppleMailRequest::userid() const {
  // @@protoc_insertion_point(field_get:grpc.ConfigureAppleMailRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigureAppleMailRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ConfigureAppleMailRequest.userID)
}
inline std::string* ConfigureAppleMailRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.ConfigureAppleMailRequest.userID)
  return _s;
}
inline const std::string& ConfigureAppleMailRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ConfigureAppleMailRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.ConfigureAppleMailRequest.userID)
  return _impl_.userid_.Release();
}
inline void ConfigureAppleMailRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ConfigureAppleMailRequest.userID)
}

// string address = 2;
inline void ConfigureAppleMailRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& ConfigureAppleMailRequest::address() const {
  // @@protoc_insertion_point(field_get:grpc.ConfigureAppleMailRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigureAppleMailRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ConfigureAppleMailRequest.address)
}
inline std::string* ConfigureAppleMailRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.ConfigureAppleMailRequest.address)
  return _s;
}
inline const std::string& ConfigureAppleMailRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void ConfigureAppleMailRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::release_address() {
  // @@protoc_insertion_point(field_release:grpc.ConfigureAppleMailRequest.address)
  return _impl_.address_.Release();
}
inline void ConfigureAppleMailRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ConfigureAppleMailRequest.address)
}

// -------------------------------------------------------------------

// EventStreamRequest

// string ClientPlatform = 1;
inline void EventStreamRequest::clear_clientplatform() {
  _impl_.clientplatform_.ClearToEmpty();
}
inline const std::string& EventStreamRequest::clientplatform() const {
  // @@protoc_insertion_point(field_get:grpc.EventStreamRequest.ClientPlatform)
  return _internal_clientplatform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventStreamRequest::set_clientplatform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientplatform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.EventStreamRequest.ClientPlatform)
}
inline std::string* EventStreamRequest::mutable_clientplatform() {
  std::string* _s = _internal_mutable_clientplatform();
  // @@protoc_insertion_point(field_mutable:grpc.EventStreamRequest.ClientPlatform)
  return _s;
}
inline const std::string& EventStreamRequest::_internal_clientplatform() const {
  return _impl_.clientplatform_.Get();
}
inline void EventStreamRequest::_internal_set_clientplatform(const std::string& value) {
  
  _impl_.clientplatform_.Set(value, GetArenaForAllocation());
}
inline std::string* EventStreamRequest::_internal_mutable_clientplatform() {
  
  return _impl_.clientplatform_.Mutable(GetArenaForAllocation());
}
inline std::string* EventStreamRequest::release_clientplatform() {
  // @@protoc_insertion_point(field_release:grpc.EventStreamRequest.ClientPlatform)
  return _impl_.clientplatform_.Release();
}
inline void EventStreamRequest::set_allocated_clientplatform(std::string* clientplatform) {
  if (clientplatform != nullptr) {
    
  } else {
    
  }
  _impl_.clientplatform_.SetAllocated(clientplatform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientplatform_.IsDefault()) {
    _impl_.clientplatform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.EventStreamRequest.ClientPlatform)
}

// -------------------------------------------------------------------

// StreamEvent

// .grpc.AppEvent app = 1;
inline bool StreamEvent::_internal_has_app() const {
  return event_case() == kApp;
}
inline bool StreamEvent::has_app() const {
  return _internal_has_app();
}
inline void StreamEvent::set_has_app() {
  _impl_._oneof_case_[0] = kApp;
}
inline void StreamEvent::clear_app() {
  if (_internal_has_app()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.app_;
    }
    clear_has_event();
  }
}
inline ::grpc::AppEvent* StreamEvent::release_app() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.app)
  if (_internal_has_app()) {
    clear_has_event();
    ::grpc::AppEvent* temp = _impl_.event_.app_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.app_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::AppEvent& StreamEvent::_internal_app() const {
  return _internal_has_app()
      ? *_impl_.event_.app_
      : reinterpret_cast< ::grpc::AppEvent&>(::grpc::_AppEvent_default_instance_);
}
inline const ::grpc::AppEvent& StreamEvent::app() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.app)
  return _internal_app();
}
inline ::grpc::AppEvent* StreamEvent::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.app)
  if (_internal_has_app()) {
    clear_has_event();
    ::grpc::AppEvent* temp = _impl_.event_.app_;
    _impl_.event_.app_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_app(::grpc::AppEvent* app) {
  clear_event();
  if (app) {
    set_has_app();
    _impl_.event_.app_ = app;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.app)
}
inline ::grpc::AppEvent* StreamEvent::_internal_mutable_app() {
  if (!_internal_has_app()) {
    clear_event();
    set_has_app();
    _impl_.event_.app_ = CreateMaybeMessage< ::grpc::AppEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.app_;
}
inline ::grpc::AppEvent* StreamEvent::mutable_app() {
  ::grpc::AppEvent* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.app)
  return _msg;
}

// .grpc.LoginEvent login = 2;
inline bool StreamEvent::_internal_has_login() const {
  return event_case() == kLogin;
}
inline bool StreamEvent::has_login() const {
  return _internal_has_login();
}
inline void StreamEvent::set_has_login() {
  _impl_._oneof_case_[0] = kLogin;
}
inline void StreamEvent::clear_login() {
  if (_internal_has_login()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.login_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginEvent* StreamEvent::release_login() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.login)
  if (_internal_has_login()) {
    clear_has_event();
    ::grpc::LoginEvent* temp = _impl_.event_.login_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginEvent& StreamEvent::_internal_login() const {
  return _internal_has_login()
      ? *_impl_.event_.login_
      : reinterpret_cast< ::grpc::LoginEvent&>(::grpc::_LoginEvent_default_instance_);
}
inline const ::grpc::LoginEvent& StreamEvent::login() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.login)
  return _internal_login();
}
inline ::grpc::LoginEvent* StreamEvent::unsafe_arena_release_login() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.login)
  if (_internal_has_login()) {
    clear_has_event();
    ::grpc::LoginEvent* temp = _impl_.event_.login_;
    _impl_.event_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_login(::grpc::LoginEvent* login) {
  clear_event();
  if (login) {
    set_has_login();
    _impl_.event_.login_ = login;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.login)
}
inline ::grpc::LoginEvent* StreamEvent::_internal_mutable_login() {
  if (!_internal_has_login()) {
    clear_event();
    set_has_login();
    _impl_.event_.login_ = CreateMaybeMessage< ::grpc::LoginEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.login_;
}
inline ::grpc::LoginEvent* StreamEvent::mutable_login() {
  ::grpc::LoginEvent* _msg = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.login)
  return _msg;
}

// .grpc.UpdateEvent update = 3;
inline bool StreamEvent::_internal_has_update() const {
  return event_case() == kUpdate;
}
inline bool StreamEvent::has_update() const {
  return _internal_has_update();
}
inline void StreamEvent::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void StreamEvent::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.update_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateEvent* StreamEvent::release_update() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.update)
  if (_internal_has_update()) {
    clear_has_event();
    ::grpc::UpdateEvent* temp = _impl_.event_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateEvent& StreamEvent::_internal_update() const {
  return _internal_has_update()
      ? *_impl_.event_.update_
      : reinterpret_cast< ::grpc::UpdateEvent&>(::grpc::_UpdateEvent_default_instance_);
}
inline const ::grpc::UpdateEvent& StreamEvent::update() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.update)
  return _internal_update();
}
inline ::grpc::UpdateEvent* StreamEvent::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.update)
  if (_internal_has_update()) {
    clear_has_event();
    ::grpc::UpdateEvent* temp = _impl_.event_.update_;
    _impl_.event_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_update(::grpc::UpdateEvent* update) {
  clear_event();
  if (update) {
    set_has_update();
    _impl_.event_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.update)
}
inline ::grpc::UpdateEvent* StreamEvent::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_event();
    set_has_update();
    _impl_.event_.update_ = CreateMaybeMessage< ::grpc::UpdateEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.update_;
}
inline ::grpc::UpdateEvent* StreamEvent::mutable_update() {
  ::grpc::UpdateEvent* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.update)
  return _msg;
}

// .grpc.DiskCacheEvent cache = 4;
inline bool StreamEvent::_internal_has_cache() const {
  return event_case() == kCache;
}
inline bool StreamEvent::has_cache() const {
  return _internal_has_cache();
}
inline void StreamEvent::set_has_cache() {
  _impl_._oneof_case_[0] = kCache;
}
inline void StreamEvent::clear_cache() {
  if (_internal_has_cache()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.cache_;
    }
    clear_has_event();
  }
}
inline ::grpc::DiskCacheEvent* StreamEvent::release_cache() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.cache)
  if (_internal_has_cache()) {
    clear_has_event();
    ::grpc::DiskCacheEvent* temp = _impl_.event_.cache_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.cache_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::DiskCacheEvent& StreamEvent::_internal_cache() const {
  return _internal_has_cache()
      ? *_impl_.event_.cache_
      : reinterpret_cast< ::grpc::DiskCacheEvent&>(::grpc::_DiskCacheEvent_default_instance_);
}
inline const ::grpc::DiskCacheEvent& StreamEvent::cache() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.cache)
  return _internal_cache();
}
inline ::grpc::DiskCacheEvent* StreamEvent::unsafe_arena_release_cache() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.cache)
  if (_internal_has_cache()) {
    clear_has_event();
    ::grpc::DiskCacheEvent* temp = _impl_.event_.cache_;
    _impl_.event_.cache_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_cache(::grpc::DiskCacheEvent* cache) {
  clear_event();
  if (cache) {
    set_has_cache();
    _impl_.event_.cache_ = cache;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.cache)
}
inline ::grpc::DiskCacheEvent* StreamEvent::_internal_mutable_cache() {
  if (!_internal_has_cache()) {
    clear_event();
    set_has_cache();
    _impl_.event_.cache_ = CreateMaybeMessage< ::grpc::DiskCacheEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.cache_;
}
inline ::grpc::DiskCacheEvent* StreamEvent::mutable_cache() {
  ::grpc::DiskCacheEvent* _msg = _internal_mutable_cache();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.cache)
  return _msg;
}

// .grpc.MailServerSettingsEvent mailServerSettings = 5;
inline bool StreamEvent::_internal_has_mailserversettings() const {
  return event_case() == kMailServerSettings;
}
inline bool StreamEvent::has_mailserversettings() const {
  return _internal_has_mailserversettings();
}
inline void StreamEvent::set_has_mailserversettings() {
  _impl_._oneof_case_[0] = kMailServerSettings;
}
inline void StreamEvent::clear_mailserversettings() {
  if (_internal_has_mailserversettings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.mailserversettings_;
    }
    clear_has_event();
  }
}
inline ::grpc::MailServerSettingsEvent* StreamEvent::release_mailserversettings() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.mailServerSettings)
  if (_internal_has_mailserversettings()) {
    clear_has_event();
    ::grpc::MailServerSettingsEvent* temp = _impl_.event_.mailserversettings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.mailserversettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::MailServerSettingsEvent& StreamEvent::_internal_mailserversettings() const {
  return _internal_has_mailserversettings()
      ? *_impl_.event_.mailserversettings_
      : reinterpret_cast< ::grpc::MailServerSettingsEvent&>(::grpc::_MailServerSettingsEvent_default_instance_);
}
inline const ::grpc::MailServerSettingsEvent& StreamEvent::mailserversettings() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.mailServerSettings)
  return _internal_mailserversettings();
}
inline ::grpc::MailServerSettingsEvent* StreamEvent::unsafe_arena_release_mailserversettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.mailServerSettings)
  if (_internal_has_mailserversettings()) {
    clear_has_event();
    ::grpc::MailServerSettingsEvent* temp = _impl_.event_.mailserversettings_;
    _impl_.event_.mailserversettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_mailserversettings(::grpc::MailServerSettingsEvent* mailserversettings) {
  clear_event();
  if (mailserversettings) {
    set_has_mailserversettings();
    _impl_.event_.mailserversettings_ = mailserversettings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.mailServerSettings)
}
inline ::grpc::MailServerSettingsEvent* StreamEvent::_internal_mutable_mailserversettings() {
  if (!_internal_has_mailserversettings()) {
    clear_event();
    set_has_mailserversettings();
    _impl_.event_.mailserversettings_ = CreateMaybeMessage< ::grpc::MailServerSettingsEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.mailserversettings_;
}
inline ::grpc::MailServerSettingsEvent* StreamEvent::mutable_mailserversettings() {
  ::grpc::MailServerSettingsEvent* _msg = _internal_mutable_mailserversettings();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.mailServerSettings)
  return _msg;
}

// .grpc.KeychainEvent keychain = 6;
inline bool StreamEvent::_internal_has_keychain() const {
  return event_case() == kKeychain;
}
inline bool StreamEvent::has_keychain() const {
  return _internal_has_keychain();
}
inline void StreamEvent::set_has_keychain() {
  _impl_._oneof_case_[0] = kKeychain;
}
inline void StreamEvent::clear_keychain() {
  if (_internal_has_keychain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.keychain_;
    }
    clear_has_event();
  }
}
inline ::grpc::KeychainEvent* StreamEvent::release_keychain() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.keychain)
  if (_internal_has_keychain()) {
    clear_has_event();
    ::grpc::KeychainEvent* temp = _impl_.event_.keychain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.keychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::KeychainEvent& StreamEvent::_internal_keychain() const {
  return _internal_has_keychain()
      ? *_impl_.event_.keychain_
      : reinterpret_cast< ::grpc::KeychainEvent&>(::grpc::_KeychainEvent_default_instance_);
}
inline const ::grpc::KeychainEvent& StreamEvent::keychain() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.keychain)
  return _internal_keychain();
}
inline ::grpc::KeychainEvent* StreamEvent::unsafe_arena_release_keychain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.keychain)
  if (_internal_has_keychain()) {
    clear_has_event();
    ::grpc::KeychainEvent* temp = _impl_.event_.keychain_;
    _impl_.event_.keychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_keychain(::grpc::KeychainEvent* keychain) {
  clear_event();
  if (keychain) {
    set_has_keychain();
    _impl_.event_.keychain_ = keychain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.keychain)
}
inline ::grpc::KeychainEvent* StreamEvent::_internal_mutable_keychain() {
  if (!_internal_has_keychain()) {
    clear_event();
    set_has_keychain();
    _impl_.event_.keychain_ = CreateMaybeMessage< ::grpc::KeychainEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.keychain_;
}
inline ::grpc::KeychainEvent* StreamEvent::mutable_keychain() {
  ::grpc::KeychainEvent* _msg = _internal_mutable_keychain();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.keychain)
  return _msg;
}

// .grpc.MailEvent mail = 7;
inline bool StreamEvent::_internal_has_mail() const {
  return event_case() == kMail;
}
inline bool StreamEvent::has_mail() const {
  return _internal_has_mail();
}
inline void StreamEvent::set_has_mail() {
  _impl_._oneof_case_[0] = kMail;
}
inline void StreamEvent::clear_mail() {
  if (_internal_has_mail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.mail_;
    }
    clear_has_event();
  }
}
inline ::grpc::MailEvent* StreamEvent::release_mail() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.mail)
  if (_internal_has_mail()) {
    clear_has_event();
    ::grpc::MailEvent* temp = _impl_.event_.mail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.mail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::MailEvent& StreamEvent::_internal_mail() const {
  return _internal_has_mail()
      ? *_impl_.event_.mail_
      : reinterpret_cast< ::grpc::MailEvent&>(::grpc::_MailEvent_default_instance_);
}
inline const ::grpc::MailEvent& StreamEvent::mail() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.mail)
  return _internal_mail();
}
inline ::grpc::MailEvent* StreamEvent::unsafe_arena_release_mail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.mail)
  if (_internal_has_mail()) {
    clear_has_event();
    ::grpc::MailEvent* temp = _impl_.event_.mail_;
    _impl_.event_.mail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_mail(::grpc::MailEvent* mail) {
  clear_event();
  if (mail) {
    set_has_mail();
    _impl_.event_.mail_ = mail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.mail)
}
inline ::grpc::MailEvent* StreamEvent::_internal_mutable_mail() {
  if (!_internal_has_mail()) {
    clear_event();
    set_has_mail();
    _impl_.event_.mail_ = CreateMaybeMessage< ::grpc::MailEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.mail_;
}
inline ::grpc::MailEvent* StreamEvent::mutable_mail() {
  ::grpc::MailEvent* _msg = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.mail)
  return _msg;
}

// .grpc.UserEvent user = 8;
inline bool StreamEvent::_internal_has_user() const {
  return event_case() == kUser;
}
inline bool StreamEvent::has_user() const {
  return _internal_has_user();
}
inline void StreamEvent::set_has_user() {
  _impl_._oneof_case_[0] = kUser;
}
inline void StreamEvent::clear_user() {
  if (_internal_has_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.user_;
    }
    clear_has_event();
  }
}
inline ::grpc::UserEvent* StreamEvent::release_user() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.user)
  if (_internal_has_user()) {
    clear_has_event();
    ::grpc::UserEvent* temp = _impl_.event_.user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UserEvent& StreamEvent::_internal_user() const {
  return _internal_has_user()
      ? *_impl_.event_.user_
      : reinterpret_cast< ::grpc::UserEvent&>(::grpc::_UserEvent_default_instance_);
}
inline const ::grpc::UserEvent& StreamEvent::user() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.user)
  return _internal_user();
}
inline ::grpc::UserEvent* StreamEvent::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.user)
  if (_internal_has_user()) {
    clear_has_event();
    ::grpc::UserEvent* temp = _impl_.event_.user_;
    _impl_.event_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_user(::grpc::UserEvent* user) {
  clear_event();
  if (user) {
    set_has_user();
    _impl_.event_.user_ = user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.user)
}
inline ::grpc::UserEvent* StreamEvent::_internal_mutable_user() {
  if (!_internal_has_user()) {
    clear_event();
    set_has_user();
    _impl_.event_.user_ = CreateMaybeMessage< ::grpc::UserEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.user_;
}
inline ::grpc::UserEvent* StreamEvent::mutable_user() {
  ::grpc::UserEvent* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.user)
  return _msg;
}

// .grpc.GenericErrorEvent genericError = 9;
inline bool StreamEvent::_internal_has_genericerror() const {
  return event_case() == kGenericError;
}
inline bool StreamEvent::has_genericerror() const {
  return _internal_has_genericerror();
}
inline void StreamEvent::set_has_genericerror() {
  _impl_._oneof_case_[0] = kGenericError;
}
inline void StreamEvent::clear_genericerror() {
  if (_internal_has_genericerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.genericerror_;
    }
    clear_has_event();
  }
}
inline ::grpc::GenericErrorEvent* StreamEvent::release_genericerror() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.genericError)
  if (_internal_has_genericerror()) {
    clear_has_event();
    ::grpc::GenericErrorEvent* temp = _impl_.event_.genericerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.genericerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::GenericErrorEvent& StreamEvent::_internal_genericerror() const {
  return _internal_has_genericerror()
      ? *_impl_.event_.genericerror_
      : reinterpret_cast< ::grpc::GenericErrorEvent&>(::grpc::_GenericErrorEvent_default_instance_);
}
inline const ::grpc::GenericErrorEvent& StreamEvent::genericerror() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.genericError)
  return _internal_genericerror();
}
inline ::grpc::GenericErrorEvent* StreamEvent::unsafe_arena_release_genericerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.genericError)
  if (_internal_has_genericerror()) {
    clear_has_event();
    ::grpc::GenericErrorEvent* temp = _impl_.event_.genericerror_;
    _impl_.event_.genericerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_genericerror(::grpc::GenericErrorEvent* genericerror) {
  clear_event();
  if (genericerror) {
    set_has_genericerror();
    _impl_.event_.genericerror_ = genericerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.genericError)
}
inline ::grpc::GenericErrorEvent* StreamEvent::_internal_mutable_genericerror() {
  if (!_internal_has_genericerror()) {
    clear_event();
    set_has_genericerror();
    _impl_.event_.genericerror_ = CreateMaybeMessage< ::grpc::GenericErrorEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.genericerror_;
}
inline ::grpc::GenericErrorEvent* StreamEvent::mutable_genericerror() {
  ::grpc::GenericErrorEvent* _msg = _internal_mutable_genericerror();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.genericError)
  return _msg;
}

inline bool StreamEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void StreamEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline StreamEvent::EventCase StreamEvent::event_case() const {
  return StreamEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AppEvent

// .grpc.InternetStatusEvent internetStatus = 1;
inline bool AppEvent::_internal_has_internetstatus() const {
  return event_case() == kInternetStatus;
}
inline bool AppEvent::has_internetstatus() const {
  return _internal_has_internetstatus();
}
inline void AppEvent::set_has_internetstatus() {
  _impl_._oneof_case_[0] = kInternetStatus;
}
inline void AppEvent::clear_internetstatus() {
  if (_internal_has_internetstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.internetstatus_;
    }
    clear_has_event();
  }
}
inline ::grpc::InternetStatusEvent* AppEvent::release_internetstatus() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.internetStatus)
  if (_internal_has_internetstatus()) {
    clear_has_event();
    ::grpc::InternetStatusEvent* temp = _impl_.event_.internetstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.internetstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::InternetStatusEvent& AppEvent::_internal_internetstatus() const {
  return _internal_has_internetstatus()
      ? *_impl_.event_.internetstatus_
      : reinterpret_cast< ::grpc::InternetStatusEvent&>(::grpc::_InternetStatusEvent_default_instance_);
}
inline const ::grpc::InternetStatusEvent& AppEvent::internetstatus() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.internetStatus)
  return _internal_internetstatus();
}
inline ::grpc::InternetStatusEvent* AppEvent::unsafe_arena_release_internetstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.internetStatus)
  if (_internal_has_internetstatus()) {
    clear_has_event();
    ::grpc::InternetStatusEvent* temp = _impl_.event_.internetstatus_;
    _impl_.event_.internetstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_internetstatus(::grpc::InternetStatusEvent* internetstatus) {
  clear_event();
  if (internetstatus) {
    set_has_internetstatus();
    _impl_.event_.internetstatus_ = internetstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.internetStatus)
}
inline ::grpc::InternetStatusEvent* AppEvent::_internal_mutable_internetstatus() {
  if (!_internal_has_internetstatus()) {
    clear_event();
    set_has_internetstatus();
    _impl_.event_.internetstatus_ = CreateMaybeMessage< ::grpc::InternetStatusEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.internetstatus_;
}
inline ::grpc::InternetStatusEvent* AppEvent::mutable_internetstatus() {
  ::grpc::InternetStatusEvent* _msg = _internal_mutable_internetstatus();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.internetStatus)
  return _msg;
}

// .grpc.ToggleAutostartFinishedEvent toggleAutostartFinished = 2;
inline bool AppEvent::_internal_has_toggleautostartfinished() const {
  return event_case() == kToggleAutostartFinished;
}
inline bool AppEvent::has_toggleautostartfinished() const {
  return _internal_has_toggleautostartfinished();
}
inline void AppEvent::set_has_toggleautostartfinished() {
  _impl_._oneof_case_[0] = kToggleAutostartFinished;
}
inline void AppEvent::clear_toggleautostartfinished() {
  if (_internal_has_toggleautostartfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.toggleautostartfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::release_toggleautostartfinished() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.toggleAutostartFinished)
  if (_internal_has_toggleautostartfinished()) {
    clear_has_event();
    ::grpc::ToggleAutostartFinishedEvent* temp = _impl_.event_.toggleautostartfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.toggleautostartfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ToggleAutostartFinishedEvent& AppEvent::_internal_toggleautostartfinished() const {
  return _internal_has_toggleautostartfinished()
      ? *_impl_.event_.toggleautostartfinished_
      : reinterpret_cast< ::grpc::ToggleAutostartFinishedEvent&>(::grpc::_ToggleAutostartFinishedEvent_default_instance_);
}
inline const ::grpc::ToggleAutostartFinishedEvent& AppEvent::toggleautostartfinished() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.toggleAutostartFinished)
  return _internal_toggleautostartfinished();
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::unsafe_arena_release_toggleautostartfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.toggleAutostartFinished)
  if (_internal_has_toggleautostartfinished()) {
    clear_has_event();
    ::grpc::ToggleAutostartFinishedEvent* temp = _impl_.event_.toggleautostartfinished_;
    _impl_.event_.toggleautostartfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_toggleautostartfinished(::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished) {
  clear_event();
  if (toggleautostartfinished) {
    set_has_toggleautostartfinished();
    _impl_.event_.toggleautostartfinished_ = toggleautostartfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.toggleAutostartFinished)
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::_internal_mutable_toggleautostartfinished() {
  if (!_internal_has_toggleautostartfinished()) {
    clear_event();
    set_has_toggleautostartfinished();
    _impl_.event_.toggleautostartfinished_ = CreateMaybeMessage< ::grpc::ToggleAutostartFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.toggleautostartfinished_;
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::mutable_toggleautostartfinished() {
  ::grpc::ToggleAutostartFinishedEvent* _msg = _internal_mutable_toggleautostartfinished();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.toggleAutostartFinished)
  return _msg;
}

// .grpc.ResetFinishedEvent resetFinished = 3;
inline bool AppEvent::_internal_has_resetfinished() const {
  return event_case() == kResetFinished;
}
inline bool AppEvent::has_resetfinished() const {
  return _internal_has_resetfinished();
}
inline void AppEvent::set_has_resetfinished() {
  _impl_._oneof_case_[0] = kResetFinished;
}
inline void AppEvent::clear_resetfinished() {
  if (_internal_has_resetfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.resetfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ResetFinishedEvent* AppEvent::release_resetfinished() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.resetFinished)
  if (_internal_has_resetfinished()) {
    clear_has_event();
    ::grpc::ResetFinishedEvent* temp = _impl_.event_.resetfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.resetfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ResetFinishedEvent& AppEvent::_internal_resetfinished() const {
  return _internal_has_resetfinished()
      ? *_impl_.event_.resetfinished_
      : reinterpret_cast< ::grpc::ResetFinishedEvent&>(::grpc::_ResetFinishedEvent_default_instance_);
}
inline const ::grpc::ResetFinishedEvent& AppEvent::resetfinished() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.resetFinished)
  return _internal_resetfinished();
}
inline ::grpc::ResetFinishedEvent* AppEvent::unsafe_arena_release_resetfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.resetFinished)
  if (_internal_has_resetfinished()) {
    clear_has_event();
    ::grpc::ResetFinishedEvent* temp = _impl_.event_.resetfinished_;
    _impl_.event_.resetfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_resetfinished(::grpc::ResetFinishedEvent* resetfinished) {
  clear_event();
  if (resetfinished) {
    set_has_resetfinished();
    _impl_.event_.resetfinished_ = resetfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.resetFinished)
}
inline ::grpc::ResetFinishedEvent* AppEvent::_internal_mutable_resetfinished() {
  if (!_internal_has_resetfinished()) {
    clear_event();
    set_has_resetfinished();
    _impl_.event_.resetfinished_ = CreateMaybeMessage< ::grpc::ResetFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.resetfinished_;
}
inline ::grpc::ResetFinishedEvent* AppEvent::mutable_resetfinished() {
  ::grpc::ResetFinishedEvent* _msg = _internal_mutable_resetfinished();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.resetFinished)
  return _msg;
}

// .grpc.ReportBugFinishedEvent reportBugFinished = 4;
inline bool AppEvent::_internal_has_reportbugfinished() const {
  return event_case() == kReportBugFinished;
}
inline bool AppEvent::has_reportbugfinished() const {
  return _internal_has_reportbugfinished();
}
inline void AppEvent::set_has_reportbugfinished() {
  _impl_._oneof_case_[0] = kReportBugFinished;
}
inline void AppEvent::clear_reportbugfinished() {
  if (_internal_has_reportbugfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.reportbugfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::release_reportbugfinished() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.reportBugFinished)
  if (_internal_has_reportbugfinished()) {
    clear_has_event();
    ::grpc::ReportBugFinishedEvent* temp = _impl_.event_.reportbugfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.reportbugfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ReportBugFinishedEvent& AppEvent::_internal_reportbugfinished() const {
  return _internal_has_reportbugfinished()
      ? *_impl_.event_.reportbugfinished_
      : reinterpret_cast< ::grpc::ReportBugFinishedEvent&>(::grpc::_ReportBugFinishedEvent_default_instance_);
}
inline const ::grpc::ReportBugFinishedEvent& AppEvent::reportbugfinished() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.reportBugFinished)
  return _internal_reportbugfinished();
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::unsafe_arena_release_reportbugfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.reportBugFinished)
  if (_internal_has_reportbugfinished()) {
    clear_has_event();
    ::grpc::ReportBugFinishedEvent* temp = _impl_.event_.reportbugfinished_;
    _impl_.event_.reportbugfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_reportbugfinished(::grpc::ReportBugFinishedEvent* reportbugfinished) {
  clear_event();
  if (reportbugfinished) {
    set_has_reportbugfinished();
    _impl_.event_.reportbugfinished_ = reportbugfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.reportBugFinished)
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::_internal_mutable_reportbugfinished() {
  if (!_internal_has_reportbugfinished()) {
    clear_event();
    set_has_reportbugfinished();
    _impl_.event_.reportbugfinished_ = CreateMaybeMessage< ::grpc::ReportBugFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.reportbugfinished_;
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::mutable_reportbugfinished() {
  ::grpc::ReportBugFinishedEvent* _msg = _internal_mutable_reportbugfinished();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.reportBugFinished)
  return _msg;
}

// .grpc.ReportBugSuccessEvent reportBugSuccess = 5;
inline bool AppEvent::_internal_has_reportbugsuccess() const {
  return event_case() == kReportBugSuccess;
}
inline bool AppEvent::has_reportbugsuccess() const {
  return _internal_has_reportbugsuccess();
}
inline void AppEvent::set_has_reportbugsuccess() {
  _impl_._oneof_case_[0] = kReportBugSuccess;
}
inline void AppEvent::clear_reportbugsuccess() {
  if (_internal_has_reportbugsuccess()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.reportbugsuccess_;
    }
    clear_has_event();
  }
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::release_reportbugsuccess() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.reportBugSuccess)
  if (_internal_has_reportbugsuccess()) {
    clear_has_event();
    ::grpc::ReportBugSuccessEvent* temp = _impl_.event_.reportbugsuccess_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.reportbugsuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ReportBugSuccessEvent& AppEvent::_internal_reportbugsuccess() const {
  return _internal_has_reportbugsuccess()
      ? *_impl_.event_.reportbugsuccess_
      : reinterpret_cast< ::grpc::ReportBugSuccessEvent&>(::grpc::_ReportBugSuccessEvent_default_instance_);
}
inline const ::grpc::ReportBugSuccessEvent& AppEvent::reportbugsuccess() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.reportBugSuccess)
  return _internal_reportbugsuccess();
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::unsafe_arena_release_reportbugsuccess() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.reportBugSuccess)
  if (_internal_has_reportbugsuccess()) {
    clear_has_event();
    ::grpc::ReportBugSuccessEvent* temp = _impl_.event_.reportbugsuccess_;
    _impl_.event_.reportbugsuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_reportbugsuccess(::grpc::ReportBugSuccessEvent* reportbugsuccess) {
  clear_event();
  if (reportbugsuccess) {
    set_has_reportbugsuccess();
    _impl_.event_.reportbugsuccess_ = reportbugsuccess;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.reportBugSuccess)
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::_internal_mutable_reportbugsuccess() {
  if (!_internal_has_reportbugsuccess()) {
    clear_event();
    set_has_reportbugsuccess();
    _impl_.event_.reportbugsuccess_ = CreateMaybeMessage< ::grpc::ReportBugSuccessEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.reportbugsuccess_;
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::mutable_reportbugsuccess() {
  ::grpc::ReportBugSuccessEvent* _msg = _internal_mutable_reportbugsuccess();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.reportBugSuccess)
  return _msg;
}

// .grpc.ReportBugErrorEvent reportBugError = 6;
inline bool AppEvent::_internal_has_reportbugerror() const {
  return event_case() == kReportBugError;
}
inline bool AppEvent::has_reportbugerror() const {
  return _internal_has_reportbugerror();
}
inline void AppEvent::set_has_reportbugerror() {
  _impl_._oneof_case_[0] = kReportBugError;
}
inline void AppEvent::clear_reportbugerror() {
  if (_internal_has_reportbugerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.reportbugerror_;
    }
    clear_has_event();
  }
}
inline ::grpc::ReportBugErrorEvent* AppEvent::release_reportbugerror() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.reportBugError)
  if (_internal_has_reportbugerror()) {
    clear_has_event();
    ::grpc::ReportBugErrorEvent* temp = _impl_.event_.reportbugerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.reportbugerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ReportBugErrorEvent& AppEvent::_internal_reportbugerror() const {
  return _internal_has_reportbugerror()
      ? *_impl_.event_.reportbugerror_
      : reinterpret_cast< ::grpc::ReportBugErrorEvent&>(::grpc::_ReportBugErrorEvent_default_instance_);
}
inline const ::grpc::ReportBugErrorEvent& AppEvent::reportbugerror() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.reportBugError)
  return _internal_reportbugerror();
}
inline ::grpc::ReportBugErrorEvent* AppEvent::unsafe_arena_release_reportbugerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.reportBugError)
  if (_internal_has_reportbugerror()) {
    clear_has_event();
    ::grpc::ReportBugErrorEvent* temp = _impl_.event_.reportbugerror_;
    _impl_.event_.reportbugerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_reportbugerror(::grpc::ReportBugErrorEvent* reportbugerror) {
  clear_event();
  if (reportbugerror) {
    set_has_reportbugerror();
    _impl_.event_.reportbugerror_ = reportbugerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.reportBugError)
}
inline ::grpc::ReportBugErrorEvent* AppEvent::_internal_mutable_reportbugerror() {
  if (!_internal_has_reportbugerror()) {
    clear_event();
    set_has_reportbugerror();
    _impl_.event_.reportbugerror_ = CreateMaybeMessage< ::grpc::ReportBugErrorEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.reportbugerror_;
}
inline ::grpc::ReportBugErrorEvent* AppEvent::mutable_reportbugerror() {
  ::grpc::ReportBugErrorEvent* _msg = _internal_mutable_reportbugerror();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.reportBugError)
  return _msg;
}

// .grpc.ShowMainWindowEvent showMainWindow = 7;
inline bool AppEvent::_internal_has_showmainwindow() const {
  return event_case() == kShowMainWindow;
}
inline bool AppEvent::has_showmainwindow() const {
  return _internal_has_showmainwindow();
}
inline void AppEvent::set_has_showmainwindow() {
  _impl_._oneof_case_[0] = kShowMainWindow;
}
inline void AppEvent::clear_showmainwindow() {
  if (_internal_has_showmainwindow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.showmainwindow_;
    }
    clear_has_event();
  }
}
inline ::grpc::ShowMainWindowEvent* AppEvent::release_showmainwindow() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.showMainWindow)
  if (_internal_has_showmainwindow()) {
    clear_has_event();
    ::grpc::ShowMainWindowEvent* temp = _impl_.event_.showmainwindow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.showmainwindow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ShowMainWindowEvent& AppEvent::_internal_showmainwindow() const {
  return _internal_has_showmainwindow()
      ? *_impl_.event_.showmainwindow_
      : reinterpret_cast< ::grpc::ShowMainWindowEvent&>(::grpc::_ShowMainWindowEvent_default_instance_);
}
inline const ::grpc::ShowMainWindowEvent& AppEvent::showmainwindow() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.showMainWindow)
  return _internal_showmainwindow();
}
inline ::grpc::ShowMainWindowEvent* AppEvent::unsafe_arena_release_showmainwindow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.showMainWindow)
  if (_internal_has_showmainwindow()) {
    clear_has_event();
    ::grpc::ShowMainWindowEvent* temp = _impl_.event_.showmainwindow_;
    _impl_.event_.showmainwindow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_showmainwindow(::grpc::ShowMainWindowEvent* showmainwindow) {
  clear_event();
  if (showmainwindow) {
    set_has_showmainwindow();
    _impl_.event_.showmainwindow_ = showmainwindow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.showMainWindow)
}
inline ::grpc::ShowMainWindowEvent* AppEvent::_internal_mutable_showmainwindow() {
  if (!_internal_has_showmainwindow()) {
    clear_event();
    set_has_showmainwindow();
    _impl_.event_.showmainwindow_ = CreateMaybeMessage< ::grpc::ShowMainWindowEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.showmainwindow_;
}
inline ::grpc::ShowMainWindowEvent* AppEvent::mutable_showmainwindow() {
  ::grpc::ShowMainWindowEvent* _msg = _internal_mutable_showmainwindow();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.showMainWindow)
  return _msg;
}

inline bool AppEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void AppEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline AppEvent::EventCase AppEvent::event_case() const {
  return AppEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternetStatusEvent

// bool connected = 1;
inline void InternetStatusEvent::clear_connected() {
  _impl_.connected_ = false;
}
inline bool InternetStatusEvent::_internal_connected() const {
  return _impl_.connected_;
}
inline bool InternetStatusEvent::connected() const {
  // @@protoc_insertion_point(field_get:grpc.InternetStatusEvent.connected)
  return _internal_connected();
}
inline void InternetStatusEvent::_internal_set_connected(bool value) {
  
  _impl_.connected_ = value;
}
inline void InternetStatusEvent::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:grpc.InternetStatusEvent.connected)
}

// -------------------------------------------------------------------

// ToggleAutostartFinishedEvent

// -------------------------------------------------------------------

// ResetFinishedEvent

// -------------------------------------------------------------------

// ReportBugFinishedEvent

// -------------------------------------------------------------------

// ReportBugSuccessEvent

// -------------------------------------------------------------------

// ReportBugErrorEvent

// -------------------------------------------------------------------

// ShowMainWindowEvent

// -------------------------------------------------------------------

// LoginEvent

// .grpc.LoginErrorEvent error = 1;
inline bool LoginEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool LoginEvent::has_error() const {
  return _internal_has_error();
}
inline void LoginEvent::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void LoginEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginErrorEvent* LoginEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::LoginErrorEvent* temp = _impl_.event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginErrorEvent& LoginEvent::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.event_.error_
      : reinterpret_cast< ::grpc::LoginErrorEvent&>(::grpc::_LoginErrorEvent_default_instance_);
}
inline const ::grpc::LoginErrorEvent& LoginEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.error)
  return _internal_error();
}
inline ::grpc::LoginErrorEvent* LoginEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::LoginErrorEvent* temp = _impl_.event_.error_;
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_error(::grpc::LoginErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    _impl_.event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.error)
}
inline ::grpc::LoginErrorEvent* LoginEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    _impl_.event_.error_ = CreateMaybeMessage< ::grpc::LoginErrorEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.error_;
}
inline ::grpc::LoginErrorEvent* LoginEvent::mutable_error() {
  ::grpc::LoginErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.error)
  return _msg;
}

// .grpc.LoginTfaRequestedEvent tfaRequested = 2;
inline bool LoginEvent::_internal_has_tfarequested() const {
  return event_case() == kTfaRequested;
}
inline bool LoginEvent::has_tfarequested() const {
  return _internal_has_tfarequested();
}
inline void LoginEvent::set_has_tfarequested() {
  _impl_._oneof_case_[0] = kTfaRequested;
}
inline void LoginEvent::clear_tfarequested() {
  if (_internal_has_tfarequested()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.tfarequested_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::release_tfarequested() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.tfaRequested)
  if (_internal_has_tfarequested()) {
    clear_has_event();
    ::grpc::LoginTfaRequestedEvent* temp = _impl_.event_.tfarequested_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.tfarequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginTfaRequestedEvent& LoginEvent::_internal_tfarequested() const {
  return _internal_has_tfarequested()
      ? *_impl_.event_.tfarequested_
      : reinterpret_cast< ::grpc::LoginTfaRequestedEvent&>(::grpc::_LoginTfaRequestedEvent_default_instance_);
}
inline const ::grpc::LoginTfaRequestedEvent& LoginEvent::tfarequested() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.tfaRequested)
  return _internal_tfarequested();
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::unsafe_arena_release_tfarequested() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.tfaRequested)
  if (_internal_has_tfarequested()) {
    clear_has_event();
    ::grpc::LoginTfaRequestedEvent* temp = _impl_.event_.tfarequested_;
    _impl_.event_.tfarequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_tfarequested(::grpc::LoginTfaRequestedEvent* tfarequested) {
  clear_event();
  if (tfarequested) {
    set_has_tfarequested();
    _impl_.event_.tfarequested_ = tfarequested;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.tfaRequested)
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::_internal_mutable_tfarequested() {
  if (!_internal_has_tfarequested()) {
    clear_event();
    set_has_tfarequested();
    _impl_.event_.tfarequested_ = CreateMaybeMessage< ::grpc::LoginTfaRequestedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.tfarequested_;
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::mutable_tfarequested() {
  ::grpc::LoginTfaRequestedEvent* _msg = _internal_mutable_tfarequested();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.tfaRequested)
  return _msg;
}

// .grpc.LoginTwoPasswordsRequestedEvent twoPasswordRequested = 3;
inline bool LoginEvent::_internal_has_twopasswordrequested() const {
  return event_case() == kTwoPasswordRequested;
}
inline bool LoginEvent::has_twopasswordrequested() const {
  return _internal_has_twopasswordrequested();
}
inline void LoginEvent::set_has_twopasswordrequested() {
  _impl_._oneof_case_[0] = kTwoPasswordRequested;
}
inline void LoginEvent::clear_twopasswordrequested() {
  if (_internal_has_twopasswordrequested()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.twopasswordrequested_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::release_twopasswordrequested() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.twoPasswordRequested)
  if (_internal_has_twopasswordrequested()) {
    clear_has_event();
    ::grpc::LoginTwoPasswordsRequestedEvent* temp = _impl_.event_.twopasswordrequested_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.twopasswordrequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginTwoPasswordsRequestedEvent& LoginEvent::_internal_twopasswordrequested() const {
  return _internal_has_twopasswordrequested()
      ? *_impl_.event_.twopasswordrequested_
      : reinterpret_cast< ::grpc::LoginTwoPasswordsRequestedEvent&>(::grpc::_LoginTwoPasswordsRequestedEvent_default_instance_);
}
inline const ::grpc::LoginTwoPasswordsRequestedEvent& LoginEvent::twopasswordrequested() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.twoPasswordRequested)
  return _internal_twopasswordrequested();
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::unsafe_arena_release_twopasswordrequested() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.twoPasswordRequested)
  if (_internal_has_twopasswordrequested()) {
    clear_has_event();
    ::grpc::LoginTwoPasswordsRequestedEvent* temp = _impl_.event_.twopasswordrequested_;
    _impl_.event_.twopasswordrequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_twopasswordrequested(::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested) {
  clear_event();
  if (twopasswordrequested) {
    set_has_twopasswordrequested();
    _impl_.event_.twopasswordrequested_ = twopasswordrequested;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.twoPasswordRequested)
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::_internal_mutable_twopasswordrequested() {
  if (!_internal_has_twopasswordrequested()) {
    clear_event();
    set_has_twopasswordrequested();
    _impl_.event_.twopasswordrequested_ = CreateMaybeMessage< ::grpc::LoginTwoPasswordsRequestedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.twopasswordrequested_;
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::mutable_twopasswordrequested() {
  ::grpc::LoginTwoPasswordsRequestedEvent* _msg = _internal_mutable_twopasswordrequested();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.twoPasswordRequested)
  return _msg;
}

// .grpc.LoginFinishedEvent finished = 4;
inline bool LoginEvent::_internal_has_finished() const {
  return event_case() == kFinished;
}
inline bool LoginEvent::has_finished() const {
  return _internal_has_finished();
}
inline void LoginEvent::set_has_finished() {
  _impl_._oneof_case_[0] = kFinished;
}
inline void LoginEvent::clear_finished() {
  if (_internal_has_finished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.finished_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginFinishedEvent* LoginEvent::release_finished() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.finished)
  if (_internal_has_finished()) {
    clear_has_event();
    ::grpc::LoginFinishedEvent* temp = _impl_.event_.finished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.finished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::_internal_finished() const {
  return _internal_has_finished()
      ? *_impl_.event_.finished_
      : reinterpret_cast< ::grpc::LoginFinishedEvent&>(::grpc::_LoginFinishedEvent_default_instance_);
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::finished() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.finished)
  return _internal_finished();
}
inline ::grpc::LoginFinishedEvent* LoginEvent::unsafe_arena_release_finished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.finished)
  if (_internal_has_finished()) {
    clear_has_event();
    ::grpc::LoginFinishedEvent* temp = _impl_.event_.finished_;
    _impl_.event_.finished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_finished(::grpc::LoginFinishedEvent* finished) {
  clear_event();
  if (finished) {
    set_has_finished();
    _impl_.event_.finished_ = finished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.finished)
}
inline ::grpc::LoginFinishedEvent* LoginEvent::_internal_mutable_finished() {
  if (!_internal_has_finished()) {
    clear_event();
    set_has_finished();
    _impl_.event_.finished_ = CreateMaybeMessage< ::grpc::LoginFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.finished_;
}
inline ::grpc::LoginFinishedEvent* LoginEvent::mutable_finished() {
  ::grpc::LoginFinishedEvent* _msg = _internal_mutable_finished();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.finished)
  return _msg;
}

// .grpc.LoginFinishedEvent alreadyLoggedIn = 5;
inline bool LoginEvent::_internal_has_alreadyloggedin() const {
  return event_case() == kAlreadyLoggedIn;
}
inline bool LoginEvent::has_alreadyloggedin() const {
  return _internal_has_alreadyloggedin();
}
inline void LoginEvent::set_has_alreadyloggedin() {
  _impl_._oneof_case_[0] = kAlreadyLoggedIn;
}
inline void LoginEvent::clear_alreadyloggedin() {
  if (_internal_has_alreadyloggedin()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.alreadyloggedin_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginFinishedEvent* LoginEvent::release_alreadyloggedin() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.alreadyLoggedIn)
  if (_internal_has_alreadyloggedin()) {
    clear_has_event();
    ::grpc::LoginFinishedEvent* temp = _impl_.event_.alreadyloggedin_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.alreadyloggedin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::_internal_alreadyloggedin() const {
  return _internal_has_alreadyloggedin()
      ? *_impl_.event_.alreadyloggedin_
      : reinterpret_cast< ::grpc::LoginFinishedEvent&>(::grpc::_LoginFinishedEvent_default_instance_);
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::alreadyloggedin() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.alreadyLoggedIn)
  return _internal_alreadyloggedin();
}
inline ::grpc::LoginFinishedEvent* LoginEvent::unsafe_arena_release_alreadyloggedin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.alreadyLoggedIn)
  if (_internal_has_alreadyloggedin()) {
    clear_has_event();
    ::grpc::LoginFinishedEvent* temp = _impl_.event_.alreadyloggedin_;
    _impl_.event_.alreadyloggedin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_alreadyloggedin(::grpc::LoginFinishedEvent* alreadyloggedin) {
  clear_event();
  if (alreadyloggedin) {
    set_has_alreadyloggedin();
    _impl_.event_.alreadyloggedin_ = alreadyloggedin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.alreadyLoggedIn)
}
inline ::grpc::LoginFinishedEvent* LoginEvent::_internal_mutable_alreadyloggedin() {
  if (!_internal_has_alreadyloggedin()) {
    clear_event();
    set_has_alreadyloggedin();
    _impl_.event_.alreadyloggedin_ = CreateMaybeMessage< ::grpc::LoginFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.alreadyloggedin_;
}
inline ::grpc::LoginFinishedEvent* LoginEvent::mutable_alreadyloggedin() {
  ::grpc::LoginFinishedEvent* _msg = _internal_mutable_alreadyloggedin();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.alreadyLoggedIn)
  return _msg;
}

inline bool LoginEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void LoginEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline LoginEvent::EventCase LoginEvent::event_case() const {
  return LoginEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginErrorEvent

// .grpc.LoginErrorType type = 1;
inline void LoginErrorEvent::clear_type() {
  _impl_.type_ = 0;
}
inline ::grpc::LoginErrorType LoginErrorEvent::_internal_type() const {
  return static_cast< ::grpc::LoginErrorType >(_impl_.type_);
}
inline ::grpc::LoginErrorType LoginErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.LoginErrorEvent.type)
  return _internal_type();
}
inline void LoginErrorEvent::_internal_set_type(::grpc::LoginErrorType value) {
  
  _impl_.type_ = value;
}
inline void LoginErrorEvent::set_type(::grpc::LoginErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.LoginErrorEvent.type)
}

// string message = 2;
inline void LoginErrorEvent::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LoginErrorEvent::message() const {
  // @@protoc_insertion_point(field_get:grpc.LoginErrorEvent.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginErrorEvent::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginErrorEvent.message)
}
inline std::string* LoginErrorEvent::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:grpc.LoginErrorEvent.message)
  return _s;
}
inline const std::string& LoginErrorEvent::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LoginErrorEvent::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginErrorEvent::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginErrorEvent::release_message() {
  // @@protoc_insertion_point(field_release:grpc.LoginErrorEvent.message)
  return _impl_.message_.Release();
}
inline void LoginErrorEvent::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginErrorEvent.message)
}

// -------------------------------------------------------------------

// LoginTfaRequestedEvent

// string username = 1;
inline void LoginTfaRequestedEvent::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginTfaRequestedEvent::username() const {
  // @@protoc_insertion_point(field_get:grpc.LoginTfaRequestedEvent.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginTfaRequestedEvent::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginTfaRequestedEvent.username)
}
inline std::string* LoginTfaRequestedEvent::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.LoginTfaRequestedEvent.username)
  return _s;
}
inline const std::string& LoginTfaRequestedEvent::_internal_username() const {
  return _impl_.username_.Get();
}
inline void LoginTfaRequestedEvent::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginTfaRequestedEvent::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginTfaRequestedEvent::release_username() {
  // @@protoc_insertion_point(field_release:grpc.LoginTfaRequestedEvent.username)
  return _impl_.username_.Release();
}
inline void LoginTfaRequestedEvent::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginTfaRequestedEvent.username)
}

// -------------------------------------------------------------------

// LoginTwoPasswordsRequestedEvent

// -------------------------------------------------------------------

// LoginFinishedEvent

// string userID = 1;
inline void LoginFinishedEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& LoginFinishedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.LoginFinishedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginFinishedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginFinishedEvent.userID)
}
inline std::string* LoginFinishedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.LoginFinishedEvent.userID)
  return _s;
}
inline const std::string& LoginFinishedEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void LoginFinishedEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginFinishedEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginFinishedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.LoginFinishedEvent.userID)
  return _impl_.userid_.Release();
}
inline void LoginFinishedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginFinishedEvent.userID)
}

// bool wasSignedOut = 2;
inline void LoginFinishedEvent::clear_wassignedout() {
  _impl_.wassignedout_ = false;
}
inline bool LoginFinishedEvent::_internal_wassignedout() const {
  return _impl_.wassignedout_;
}
inline bool LoginFinishedEvent::wassignedout() const {
  // @@protoc_insertion_point(field_get:grpc.LoginFinishedEvent.wasSignedOut)
  return _internal_wassignedout();
}
inline void LoginFinishedEvent::_internal_set_wassignedout(bool value) {
  
  _impl_.wassignedout_ = value;
}
inline void LoginFinishedEvent::set_wassignedout(bool value) {
  _internal_set_wassignedout(value);
  // @@protoc_insertion_point(field_set:grpc.LoginFinishedEvent.wasSignedOut)
}

// -------------------------------------------------------------------

// UpdateEvent

// .grpc.UpdateErrorEvent error = 1;
inline bool UpdateEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool UpdateEvent::has_error() const {
  return _internal_has_error();
}
inline void UpdateEvent::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void UpdateEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::UpdateErrorEvent* temp = _impl_.event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateErrorEvent& UpdateEvent::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.event_.error_
      : reinterpret_cast< ::grpc::UpdateErrorEvent&>(::grpc::_UpdateErrorEvent_default_instance_);
}
inline const ::grpc::UpdateErrorEvent& UpdateEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.error)
  return _internal_error();
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::UpdateErrorEvent* temp = _impl_.event_.error_;
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_error(::grpc::UpdateErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    _impl_.event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.error)
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    _impl_.event_.error_ = CreateMaybeMessage< ::grpc::UpdateErrorEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.error_;
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::mutable_error() {
  ::grpc::UpdateErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.error)
  return _msg;
}

// .grpc.UpdateManualReadyEvent manualReady = 2;
inline bool UpdateEvent::_internal_has_manualready() const {
  return event_case() == kManualReady;
}
inline bool UpdateEvent::has_manualready() const {
  return _internal_has_manualready();
}
inline void UpdateEvent::set_has_manualready() {
  _impl_._oneof_case_[0] = kManualReady;
}
inline void UpdateEvent::clear_manualready() {
  if (_internal_has_manualready()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.manualready_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::release_manualready() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.manualReady)
  if (_internal_has_manualready()) {
    clear_has_event();
    ::grpc::UpdateManualReadyEvent* temp = _impl_.event_.manualready_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.manualready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateManualReadyEvent& UpdateEvent::_internal_manualready() const {
  return _internal_has_manualready()
      ? *_impl_.event_.manualready_
      : reinterpret_cast< ::grpc::UpdateManualReadyEvent&>(::grpc::_UpdateManualReadyEvent_default_instance_);
}
inline const ::grpc::UpdateManualReadyEvent& UpdateEvent::manualready() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.manualReady)
  return _internal_manualready();
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::unsafe_arena_release_manualready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.manualReady)
  if (_internal_has_manualready()) {
    clear_has_event();
    ::grpc::UpdateManualReadyEvent* temp = _impl_.event_.manualready_;
    _impl_.event_.manualready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_manualready(::grpc::UpdateManualReadyEvent* manualready) {
  clear_event();
  if (manualready) {
    set_has_manualready();
    _impl_.event_.manualready_ = manualready;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.manualReady)
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::_internal_mutable_manualready() {
  if (!_internal_has_manualready()) {
    clear_event();
    set_has_manualready();
    _impl_.event_.manualready_ = CreateMaybeMessage< ::grpc::UpdateManualReadyEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.manualready_;
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::mutable_manualready() {
  ::grpc::UpdateManualReadyEvent* _msg = _internal_mutable_manualready();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.manualReady)
  return _msg;
}

// .grpc.UpdateManualRestartNeededEvent manualRestartNeeded = 3;
inline bool UpdateEvent::_internal_has_manualrestartneeded() const {
  return event_case() == kManualRestartNeeded;
}
inline bool UpdateEvent::has_manualrestartneeded() const {
  return _internal_has_manualrestartneeded();
}
inline void UpdateEvent::set_has_manualrestartneeded() {
  _impl_._oneof_case_[0] = kManualRestartNeeded;
}
inline void UpdateEvent::clear_manualrestartneeded() {
  if (_internal_has_manualrestartneeded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.manualrestartneeded_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::release_manualrestartneeded() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.manualRestartNeeded)
  if (_internal_has_manualrestartneeded()) {
    clear_has_event();
    ::grpc::UpdateManualRestartNeededEvent* temp = _impl_.event_.manualrestartneeded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.manualrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateManualRestartNeededEvent& UpdateEvent::_internal_manualrestartneeded() const {
  return _internal_has_manualrestartneeded()
      ? *_impl_.event_.manualrestartneeded_
      : reinterpret_cast< ::grpc::UpdateManualRestartNeededEvent&>(::grpc::_UpdateManualRestartNeededEvent_default_instance_);
}
inline const ::grpc::UpdateManualRestartNeededEvent& UpdateEvent::manualrestartneeded() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.manualRestartNeeded)
  return _internal_manualrestartneeded();
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::unsafe_arena_release_manualrestartneeded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.manualRestartNeeded)
  if (_internal_has_manualrestartneeded()) {
    clear_has_event();
    ::grpc::UpdateManualRestartNeededEvent* temp = _impl_.event_.manualrestartneeded_;
    _impl_.event_.manualrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_manualrestartneeded(::grpc::UpdateManualRestartNeededEvent* manualrestartneeded) {
  clear_event();
  if (manualrestartneeded) {
    set_has_manualrestartneeded();
    _impl_.event_.manualrestartneeded_ = manualrestartneeded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.manualRestartNeeded)
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::_internal_mutable_manualrestartneeded() {
  if (!_internal_has_manualrestartneeded()) {
    clear_event();
    set_has_manualrestartneeded();
    _impl_.event_.manualrestartneeded_ = CreateMaybeMessage< ::grpc::UpdateManualRestartNeededEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.manualrestartneeded_;
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::mutable_manualrestartneeded() {
  ::grpc::UpdateManualRestartNeededEvent* _msg = _internal_mutable_manualrestartneeded();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.manualRestartNeeded)
  return _msg;
}

// .grpc.UpdateForceEvent force = 4;
inline bool UpdateEvent::_internal_has_force() const {
  return event_case() == kForce;
}
inline bool UpdateEvent::has_force() const {
  return _internal_has_force();
}
inline void UpdateEvent::set_has_force() {
  _impl_._oneof_case_[0] = kForce;
}
inline void UpdateEvent::clear_force() {
  if (_internal_has_force()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.force_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateForceEvent* UpdateEvent::release_force() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.force)
  if (_internal_has_force()) {
    clear_has_event();
    ::grpc::UpdateForceEvent* temp = _impl_.event_.force_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.force_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateForceEvent& UpdateEvent::_internal_force() const {
  return _internal_has_force()
      ? *_impl_.event_.force_
      : reinterpret_cast< ::grpc::UpdateForceEvent&>(::grpc::_UpdateForceEvent_default_instance_);
}
inline const ::grpc::UpdateForceEvent& UpdateEvent::force() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.force)
  return _internal_force();
}
inline ::grpc::UpdateForceEvent* UpdateEvent::unsafe_arena_release_force() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.force)
  if (_internal_has_force()) {
    clear_has_event();
    ::grpc::UpdateForceEvent* temp = _impl_.event_.force_;
    _impl_.event_.force_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_force(::grpc::UpdateForceEvent* force) {
  clear_event();
  if (force) {
    set_has_force();
    _impl_.event_.force_ = force;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.force)
}
inline ::grpc::UpdateForceEvent* UpdateEvent::_internal_mutable_force() {
  if (!_internal_has_force()) {
    clear_event();
    set_has_force();
    _impl_.event_.force_ = CreateMaybeMessage< ::grpc::UpdateForceEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.force_;
}
inline ::grpc::UpdateForceEvent* UpdateEvent::mutable_force() {
  ::grpc::UpdateForceEvent* _msg = _internal_mutable_force();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.force)
  return _msg;
}

// .grpc.UpdateSilentRestartNeeded silentRestartNeeded = 5;
inline bool UpdateEvent::_internal_has_silentrestartneeded() const {
  return event_case() == kSilentRestartNeeded;
}
inline bool UpdateEvent::has_silentrestartneeded() const {
  return _internal_has_silentrestartneeded();
}
inline void UpdateEvent::set_has_silentrestartneeded() {
  _impl_._oneof_case_[0] = kSilentRestartNeeded;
}
inline void UpdateEvent::clear_silentrestartneeded() {
  if (_internal_has_silentrestartneeded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.silentrestartneeded_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::release_silentrestartneeded() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.silentRestartNeeded)
  if (_internal_has_silentrestartneeded()) {
    clear_has_event();
    ::grpc::UpdateSilentRestartNeeded* temp = _impl_.event_.silentrestartneeded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.silentrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateSilentRestartNeeded& UpdateEvent::_internal_silentrestartneeded() const {
  return _internal_has_silentrestartneeded()
      ? *_impl_.event_.silentrestartneeded_
      : reinterpret_cast< ::grpc::UpdateSilentRestartNeeded&>(::grpc::_UpdateSilentRestartNeeded_default_instance_);
}
inline const ::grpc::UpdateSilentRestartNeeded& UpdateEvent::silentrestartneeded() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.silentRestartNeeded)
  return _internal_silentrestartneeded();
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::unsafe_arena_release_silentrestartneeded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.silentRestartNeeded)
  if (_internal_has_silentrestartneeded()) {
    clear_has_event();
    ::grpc::UpdateSilentRestartNeeded* temp = _impl_.event_.silentrestartneeded_;
    _impl_.event_.silentrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_silentrestartneeded(::grpc::UpdateSilentRestartNeeded* silentrestartneeded) {
  clear_event();
  if (silentrestartneeded) {
    set_has_silentrestartneeded();
    _impl_.event_.silentrestartneeded_ = silentrestartneeded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.silentRestartNeeded)
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::_internal_mutable_silentrestartneeded() {
  if (!_internal_has_silentrestartneeded()) {
    clear_event();
    set_has_silentrestartneeded();
    _impl_.event_.silentrestartneeded_ = CreateMaybeMessage< ::grpc::UpdateSilentRestartNeeded >(GetArenaForAllocation());
  }
  return _impl_.event_.silentrestartneeded_;
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::mutable_silentrestartneeded() {
  ::grpc::UpdateSilentRestartNeeded* _msg = _internal_mutable_silentrestartneeded();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.silentRestartNeeded)
  return _msg;
}

// .grpc.UpdateIsLatestVersion isLatestVersion = 6;
inline bool UpdateEvent::_internal_has_islatestversion() const {
  return event_case() == kIsLatestVersion;
}
inline bool UpdateEvent::has_islatestversion() const {
  return _internal_has_islatestversion();
}
inline void UpdateEvent::set_has_islatestversion() {
  _impl_._oneof_case_[0] = kIsLatestVersion;
}
inline void UpdateEvent::clear_islatestversion() {
  if (_internal_has_islatestversion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.islatestversion_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::release_islatestversion() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.isLatestVersion)
  if (_internal_has_islatestversion()) {
    clear_has_event();
    ::grpc::UpdateIsLatestVersion* temp = _impl_.event_.islatestversion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.islatestversion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateIsLatestVersion& UpdateEvent::_internal_islatestversion() const {
  return _internal_has_islatestversion()
      ? *_impl_.event_.islatestversion_
      : reinterpret_cast< ::grpc::UpdateIsLatestVersion&>(::grpc::_UpdateIsLatestVersion_default_instance_);
}
inline const ::grpc::UpdateIsLatestVersion& UpdateEvent::islatestversion() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.isLatestVersion)
  return _internal_islatestversion();
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::unsafe_arena_release_islatestversion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.isLatestVersion)
  if (_internal_has_islatestversion()) {
    clear_has_event();
    ::grpc::UpdateIsLatestVersion* temp = _impl_.event_.islatestversion_;
    _impl_.event_.islatestversion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_islatestversion(::grpc::UpdateIsLatestVersion* islatestversion) {
  clear_event();
  if (islatestversion) {
    set_has_islatestversion();
    _impl_.event_.islatestversion_ = islatestversion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.isLatestVersion)
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::_internal_mutable_islatestversion() {
  if (!_internal_has_islatestversion()) {
    clear_event();
    set_has_islatestversion();
    _impl_.event_.islatestversion_ = CreateMaybeMessage< ::grpc::UpdateIsLatestVersion >(GetArenaForAllocation());
  }
  return _impl_.event_.islatestversion_;
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::mutable_islatestversion() {
  ::grpc::UpdateIsLatestVersion* _msg = _internal_mutable_islatestversion();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.isLatestVersion)
  return _msg;
}

// .grpc.UpdateCheckFinished checkFinished = 7;
inline bool UpdateEvent::_internal_has_checkfinished() const {
  return event_case() == kCheckFinished;
}
inline bool UpdateEvent::has_checkfinished() const {
  return _internal_has_checkfinished();
}
inline void UpdateEvent::set_has_checkfinished() {
  _impl_._oneof_case_[0] = kCheckFinished;
}
inline void UpdateEvent::clear_checkfinished() {
  if (_internal_has_checkfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.checkfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::release_checkfinished() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.checkFinished)
  if (_internal_has_checkfinished()) {
    clear_has_event();
    ::grpc::UpdateCheckFinished* temp = _impl_.event_.checkfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.checkfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateCheckFinished& UpdateEvent::_internal_checkfinished() const {
  return _internal_has_checkfinished()
      ? *_impl_.event_.checkfinished_
      : reinterpret_cast< ::grpc::UpdateCheckFinished&>(::grpc::_UpdateCheckFinished_default_instance_);
}
inline const ::grpc::UpdateCheckFinished& UpdateEvent::checkfinished() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.checkFinished)
  return _internal_checkfinished();
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::unsafe_arena_release_checkfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.checkFinished)
  if (_internal_has_checkfinished()) {
    clear_has_event();
    ::grpc::UpdateCheckFinished* temp = _impl_.event_.checkfinished_;
    _impl_.event_.checkfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_checkfinished(::grpc::UpdateCheckFinished* checkfinished) {
  clear_event();
  if (checkfinished) {
    set_has_checkfinished();
    _impl_.event_.checkfinished_ = checkfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.checkFinished)
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::_internal_mutable_checkfinished() {
  if (!_internal_has_checkfinished()) {
    clear_event();
    set_has_checkfinished();
    _impl_.event_.checkfinished_ = CreateMaybeMessage< ::grpc::UpdateCheckFinished >(GetArenaForAllocation());
  }
  return _impl_.event_.checkfinished_;
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::mutable_checkfinished() {
  ::grpc::UpdateCheckFinished* _msg = _internal_mutable_checkfinished();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.checkFinished)
  return _msg;
}

// .grpc.UpdateVersionChanged versionChanged = 8;
inline bool UpdateEvent::_internal_has_versionchanged() const {
  return event_case() == kVersionChanged;
}
inline bool UpdateEvent::has_versionchanged() const {
  return _internal_has_versionchanged();
}
inline void UpdateEvent::set_has_versionchanged() {
  _impl_._oneof_case_[0] = kVersionChanged;
}
inline void UpdateEvent::clear_versionchanged() {
  if (_internal_has_versionchanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.versionchanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateVersionChanged* UpdateEvent::release_versionchanged() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.versionChanged)
  if (_internal_has_versionchanged()) {
    clear_has_event();
    ::grpc::UpdateVersionChanged* temp = _impl_.event_.versionchanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.versionchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateVersionChanged& UpdateEvent::_internal_versionchanged() const {
  return _internal_has_versionchanged()
      ? *_impl_.event_.versionchanged_
      : reinterpret_cast< ::grpc::UpdateVersionChanged&>(::grpc::_UpdateVersionChanged_default_instance_);
}
inline const ::grpc::UpdateVersionChanged& UpdateEvent::versionchanged() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.versionChanged)
  return _internal_versionchanged();
}
inline ::grpc::UpdateVersionChanged* UpdateEvent::unsafe_arena_release_versionchanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.versionChanged)
  if (_internal_has_versionchanged()) {
    clear_has_event();
    ::grpc::UpdateVersionChanged* temp = _impl_.event_.versionchanged_;
    _impl_.event_.versionchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_versionchanged(::grpc::UpdateVersionChanged* versionchanged) {
  clear_event();
  if (versionchanged) {
    set_has_versionchanged();
    _impl_.event_.versionchanged_ = versionchanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.versionChanged)
}
inline ::grpc::UpdateVersionChanged* UpdateEvent::_internal_mutable_versionchanged() {
  if (!_internal_has_versionchanged()) {
    clear_event();
    set_has_versionchanged();
    _impl_.event_.versionchanged_ = CreateMaybeMessage< ::grpc::UpdateVersionChanged >(GetArenaForAllocation());
  }
  return _impl_.event_.versionchanged_;
}
inline ::grpc::UpdateVersionChanged* UpdateEvent::mutable_versionchanged() {
  ::grpc::UpdateVersionChanged* _msg = _internal_mutable_versionchanged();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.versionChanged)
  return _msg;
}

inline bool UpdateEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void UpdateEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline UpdateEvent::EventCase UpdateEvent::event_case() const {
  return UpdateEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateErrorEvent

// .grpc.UpdateErrorType type = 1;
inline void UpdateErrorEvent::clear_type() {
  _impl_.type_ = 0;
}
inline ::grpc::UpdateErrorType UpdateErrorEvent::_internal_type() const {
  return static_cast< ::grpc::UpdateErrorType >(_impl_.type_);
}
inline ::grpc::UpdateErrorType UpdateErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateErrorEvent.type)
  return _internal_type();
}
inline void UpdateErrorEvent::_internal_set_type(::grpc::UpdateErrorType value) {
  
  _impl_.type_ = value;
}
inline void UpdateErrorEvent::set_type(::grpc::UpdateErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.UpdateErrorEvent.type)
}

// -------------------------------------------------------------------

// UpdateManualReadyEvent

// string version = 1;
inline void UpdateManualReadyEvent::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& UpdateManualReadyEvent::version() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateManualReadyEvent.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateManualReadyEvent::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UpdateManualReadyEvent.version)
}
inline std::string* UpdateManualReadyEvent::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateManualReadyEvent.version)
  return _s;
}
inline const std::string& UpdateManualReadyEvent::_internal_version() const {
  return _impl_.version_.Get();
}
inline void UpdateManualReadyEvent::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateManualReadyEvent::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateManualReadyEvent::release_version() {
  // @@protoc_insertion_point(field_release:grpc.UpdateManualReadyEvent.version)
  return _impl_.version_.Release();
}
inline void UpdateManualReadyEvent::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UpdateManualReadyEvent.version)
}

// -------------------------------------------------------------------

// UpdateManualRestartNeededEvent

// -------------------------------------------------------------------

// UpdateForceEvent

// string version = 1;
inline void UpdateForceEvent::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& UpdateForceEvent::version() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateForceEvent.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateForceEvent::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UpdateForceEvent.version)
}
inline std::string* UpdateForceEvent::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateForceEvent.version)
  return _s;
}
inline const std::string& UpdateForceEvent::_internal_version() const {
  return _impl_.version_.Get();
}
inline void UpdateForceEvent::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateForceEvent::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateForceEvent::release_version() {
  // @@protoc_insertion_point(field_release:grpc.UpdateForceEvent.version)
  return _impl_.version_.Release();
}
inline void UpdateForceEvent::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UpdateForceEvent.version)
}

// -------------------------------------------------------------------

// UpdateSilentRestartNeeded

// -------------------------------------------------------------------

// UpdateIsLatestVersion

// -------------------------------------------------------------------

// UpdateCheckFinished

// -------------------------------------------------------------------

// UpdateVersionChanged

// -------------------------------------------------------------------

// DiskCacheEvent

// .grpc.DiskCacheErrorEvent error = 1;
inline bool DiskCacheEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool DiskCacheEvent::has_error() const {
  return _internal_has_error();
}
inline void DiskCacheEvent::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void DiskCacheEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::DiskCacheErrorEvent* DiskCacheEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.DiskCacheEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::DiskCacheErrorEvent* temp = _impl_.event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::DiskCacheErrorEvent& DiskCacheEvent::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.event_.error_
      : reinterpret_cast< ::grpc::DiskCacheErrorEvent&>(::grpc::_DiskCacheErrorEvent_default_instance_);
}
inline const ::grpc::DiskCacheErrorEvent& DiskCacheEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.DiskCacheEvent.error)
  return _internal_error();
}
inline ::grpc::DiskCacheErrorEvent* DiskCacheEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.DiskCacheEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::DiskCacheErrorEvent* temp = _impl_.event_.error_;
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DiskCacheEvent::unsafe_arena_set_allocated_error(::grpc::DiskCacheErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    _impl_.event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.DiskCacheEvent.error)
}
inline ::grpc::DiskCacheErrorEvent* DiskCacheEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    _impl_.event_.error_ = CreateMaybeMessage< ::grpc::DiskCacheErrorEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.error_;
}
inline ::grpc::DiskCacheErrorEvent* DiskCacheEvent::mutable_error() {
  ::grpc::DiskCacheErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.DiskCacheEvent.error)
  return _msg;
}

// .grpc.DiskCachePathChangedEvent pathChanged = 2;
inline bool DiskCacheEvent::_internal_has_pathchanged() const {
  return event_case() == kPathChanged;
}
inline bool DiskCacheEvent::has_pathchanged() const {
  return _internal_has_pathchanged();
}
inline void DiskCacheEvent::set_has_pathchanged() {
  _impl_._oneof_case_[0] = kPathChanged;
}
inline void DiskCacheEvent::clear_pathchanged() {
  if (_internal_has_pathchanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.pathchanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::DiskCachePathChangedEvent* DiskCacheEvent::release_pathchanged() {
  // @@protoc_insertion_point(field_release:grpc.DiskCacheEvent.pathChanged)
  if (_internal_has_pathchanged()) {
    clear_has_event();
    ::grpc::DiskCachePathChangedEvent* temp = _impl_.event_.pathchanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.pathchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::DiskCachePathChangedEvent& DiskCacheEvent::_internal_pathchanged() const {
  return _internal_has_pathchanged()
      ? *_impl_.event_.pathchanged_
      : reinterpret_cast< ::grpc::DiskCachePathChangedEvent&>(::grpc::_DiskCachePathChangedEvent_default_instance_);
}
inline const ::grpc::DiskCachePathChangedEvent& DiskCacheEvent::pathchanged() const {
  // @@protoc_insertion_point(field_get:grpc.DiskCacheEvent.pathChanged)
  return _internal_pathchanged();
}
inline ::grpc::DiskCachePathChangedEvent* DiskCacheEvent::unsafe_arena_release_pathchanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.DiskCacheEvent.pathChanged)
  if (_internal_has_pathchanged()) {
    clear_has_event();
    ::grpc::DiskCachePathChangedEvent* temp = _impl_.event_.pathchanged_;
    _impl_.event_.pathchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DiskCacheEvent::unsafe_arena_set_allocated_pathchanged(::grpc::DiskCachePathChangedEvent* pathchanged) {
  clear_event();
  if (pathchanged) {
    set_has_pathchanged();
    _impl_.event_.pathchanged_ = pathchanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.DiskCacheEvent.pathChanged)
}
inline ::grpc::DiskCachePathChangedEvent* DiskCacheEvent::_internal_mutable_pathchanged() {
  if (!_internal_has_pathchanged()) {
    clear_event();
    set_has_pathchanged();
    _impl_.event_.pathchanged_ = CreateMaybeMessage< ::grpc::DiskCachePathChangedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.pathchanged_;
}
inline ::grpc::DiskCachePathChangedEvent* DiskCacheEvent::mutable_pathchanged() {
  ::grpc::DiskCachePathChangedEvent* _msg = _internal_mutable_pathchanged();
  // @@protoc_insertion_point(field_mutable:grpc.DiskCacheEvent.pathChanged)
  return _msg;
}

// .grpc.DiskCachePathChangeFinishedEvent pathChangeFinished = 3;
inline bool DiskCacheEvent::_internal_has_pathchangefinished() const {
  return event_case() == kPathChangeFinished;
}
inline bool DiskCacheEvent::has_pathchangefinished() const {
  return _internal_has_pathchangefinished();
}
inline void DiskCacheEvent::set_has_pathchangefinished() {
  _impl_._oneof_case_[0] = kPathChangeFinished;
}
inline void DiskCacheEvent::clear_pathchangefinished() {
  if (_internal_has_pathchangefinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.pathchangefinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::DiskCachePathChangeFinishedEvent* DiskCacheEvent::release_pathchangefinished() {
  // @@protoc_insertion_point(field_release:grpc.DiskCacheEvent.pathChangeFinished)
  if (_internal_has_pathchangefinished()) {
    clear_has_event();
    ::grpc::DiskCachePathChangeFinishedEvent* temp = _impl_.event_.pathchangefinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.pathchangefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::DiskCachePathChangeFinishedEvent& DiskCacheEvent::_internal_pathchangefinished() const {
  return _internal_has_pathchangefinished()
      ? *_impl_.event_.pathchangefinished_
      : reinterpret_cast< ::grpc::DiskCachePathChangeFinishedEvent&>(::grpc::_DiskCachePathChangeFinishedEvent_default_instance_);
}
inline const ::grpc::DiskCachePathChangeFinishedEvent& DiskCacheEvent::pathchangefinished() const {
  // @@protoc_insertion_point(field_get:grpc.DiskCacheEvent.pathChangeFinished)
  return _internal_pathchangefinished();
}
inline ::grpc::DiskCachePathChangeFinishedEvent* DiskCacheEvent::unsafe_arena_release_pathchangefinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.DiskCacheEvent.pathChangeFinished)
  if (_internal_has_pathchangefinished()) {
    clear_has_event();
    ::grpc::DiskCachePathChangeFinishedEvent* temp = _impl_.event_.pathchangefinished_;
    _impl_.event_.pathchangefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DiskCacheEvent::unsafe_arena_set_allocated_pathchangefinished(::grpc::DiskCachePathChangeFinishedEvent* pathchangefinished) {
  clear_event();
  if (pathchangefinished) {
    set_has_pathchangefinished();
    _impl_.event_.pathchangefinished_ = pathchangefinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.DiskCacheEvent.pathChangeFinished)
}
inline ::grpc::DiskCachePathChangeFinishedEvent* DiskCacheEvent::_internal_mutable_pathchangefinished() {
  if (!_internal_has_pathchangefinished()) {
    clear_event();
    set_has_pathchangefinished();
    _impl_.event_.pathchangefinished_ = CreateMaybeMessage< ::grpc::DiskCachePathChangeFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.pathchangefinished_;
}
inline ::grpc::DiskCachePathChangeFinishedEvent* DiskCacheEvent::mutable_pathchangefinished() {
  ::grpc::DiskCachePathChangeFinishedEvent* _msg = _internal_mutable_pathchangefinished();
  // @@protoc_insertion_point(field_mutable:grpc.DiskCacheEvent.pathChangeFinished)
  return _msg;
}

inline bool DiskCacheEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void DiskCacheEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline DiskCacheEvent::EventCase DiskCacheEvent::event_case() const {
  return DiskCacheEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DiskCacheErrorEvent

// .grpc.DiskCacheErrorType type = 1;
inline void DiskCacheErrorEvent::clear_type() {
  _impl_.type_ = 0;
}
inline ::grpc::DiskCacheErrorType DiskCacheErrorEvent::_internal_type() const {
  return static_cast< ::grpc::DiskCacheErrorType >(_impl_.type_);
}
inline ::grpc::DiskCacheErrorType DiskCacheErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.DiskCacheErrorEvent.type)
  return _internal_type();
}
inline void DiskCacheErrorEvent::_internal_set_type(::grpc::DiskCacheErrorType value) {
  
  _impl_.type_ = value;
}
inline void DiskCacheErrorEvent::set_type(::grpc::DiskCacheErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.DiskCacheErrorEvent.type)
}

// -------------------------------------------------------------------

// DiskCachePathChangedEvent

// string path = 1;
inline void DiskCachePathChangedEvent::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& DiskCachePathChangedEvent::path() const {
  // @@protoc_insertion_point(field_get:grpc.DiskCachePathChangedEvent.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskCachePathChangedEvent::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.DiskCachePathChangedEvent.path)
}
inline std::string* DiskCachePathChangedEvent::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:grpc.DiskCachePathChangedEvent.path)
  return _s;
}
inline const std::string& DiskCachePathChangedEvent::_internal_path() const {
  return _impl_.path_.Get();
}
inline void DiskCachePathChangedEvent::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* DiskCachePathChangedEvent::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* DiskCachePathChangedEvent::release_path() {
  // @@protoc_insertion_point(field_release:grpc.DiskCachePathChangedEvent.path)
  return _impl_.path_.Release();
}
inline void DiskCachePathChangedEvent::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.DiskCachePathChangedEvent.path)
}

// -------------------------------------------------------------------

// DiskCachePathChangeFinishedEvent

// -------------------------------------------------------------------

// MailServerSettingsEvent

// .grpc.MailServerSettingsErrorEvent error = 1;
inline bool MailServerSettingsEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool MailServerSettingsEvent::has_error() const {
  return _internal_has_error();
}
inline void MailServerSettingsEvent::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void MailServerSettingsEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::MailServerSettingsErrorEvent* MailServerSettingsEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.MailServerSettingsEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::MailServerSettingsErrorEvent* temp = _impl_.event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::MailServerSettingsErrorEvent& MailServerSettingsEvent::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.event_.error_
      : reinterpret_cast< ::grpc::MailServerSettingsErrorEvent&>(::grpc::_MailServerSettingsErrorEvent_default_instance_);
}
inline const ::grpc::MailServerSettingsErrorEvent& MailServerSettingsEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.MailServerSettingsEvent.error)
  return _internal_error();
}
inline ::grpc::MailServerSettingsErrorEvent* MailServerSettingsEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailServerSettingsEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::MailServerSettingsErrorEvent* temp = _impl_.event_.error_;
    _impl_.event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailServerSettingsEvent::unsafe_arena_set_allocated_error(::grpc::MailServerSettingsErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    _impl_.event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailServerSettingsEvent.error)
}
inline ::grpc::MailServerSettingsErrorEvent* MailServerSettingsEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    _impl_.event_.error_ = CreateMaybeMessage< ::grpc::MailServerSettingsErrorEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.error_;
}
inline ::grpc::MailServerSettingsErrorEvent* MailServerSettingsEvent::mutable_error() {
  ::grpc::MailServerSettingsErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.MailServerSettingsEvent.error)
  return _msg;
}

// .grpc.MailServerSettingsChangedEvent mailServerSettingsChanged = 2;
inline bool MailServerSettingsEvent::_internal_has_mailserversettingschanged() const {
  return event_case() == kMailServerSettingsChanged;
}
inline bool MailServerSettingsEvent::has_mailserversettingschanged() const {
  return _internal_has_mailserversettingschanged();
}
inline void MailServerSettingsEvent::set_has_mailserversettingschanged() {
  _impl_._oneof_case_[0] = kMailServerSettingsChanged;
}
inline void MailServerSettingsEvent::clear_mailserversettingschanged() {
  if (_internal_has_mailserversettingschanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.mailserversettingschanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::MailServerSettingsChangedEvent* MailServerSettingsEvent::release_mailserversettingschanged() {
  // @@protoc_insertion_point(field_release:grpc.MailServerSettingsEvent.mailServerSettingsChanged)
  if (_internal_has_mailserversettingschanged()) {
    clear_has_event();
    ::grpc::MailServerSettingsChangedEvent* temp = _impl_.event_.mailserversettingschanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.mailserversettingschanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::MailServerSettingsChangedEvent& MailServerSettingsEvent::_internal_mailserversettingschanged() const {
  return _internal_has_mailserversettingschanged()
      ? *_impl_.event_.mailserversettingschanged_
      : reinterpret_cast< ::grpc::MailServerSettingsChangedEvent&>(::grpc::_MailServerSettingsChangedEvent_default_instance_);
}
inline const ::grpc::MailServerSettingsChangedEvent& MailServerSettingsEvent::mailserversettingschanged() const {
  // @@protoc_insertion_point(field_get:grpc.MailServerSettingsEvent.mailServerSettingsChanged)
  return _internal_mailserversettingschanged();
}
inline ::grpc::MailServerSettingsChangedEvent* MailServerSettingsEvent::unsafe_arena_release_mailserversettingschanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailServerSettingsEvent.mailServerSettingsChanged)
  if (_internal_has_mailserversettingschanged()) {
    clear_has_event();
    ::grpc::MailServerSettingsChangedEvent* temp = _impl_.event_.mailserversettingschanged_;
    _impl_.event_.mailserversettingschanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailServerSettingsEvent::unsafe_arena_set_allocated_mailserversettingschanged(::grpc::MailServerSettingsChangedEvent* mailserversettingschanged) {
  clear_event();
  if (mailserversettingschanged) {
    set_has_mailserversettingschanged();
    _impl_.event_.mailserversettingschanged_ = mailserversettingschanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailServerSettingsEvent.mailServerSettingsChanged)
}
inline ::grpc::MailServerSettingsChangedEvent* MailServerSettingsEvent::_internal_mutable_mailserversettingschanged() {
  if (!_internal_has_mailserversettingschanged()) {
    clear_event();
    set_has_mailserversettingschanged();
    _impl_.event_.mailserversettingschanged_ = CreateMaybeMessage< ::grpc::MailServerSettingsChangedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.mailserversettingschanged_;
}
inline ::grpc::MailServerSettingsChangedEvent* MailServerSettingsEvent::mutable_mailserversettingschanged() {
  ::grpc::MailServerSettingsChangedEvent* _msg = _internal_mutable_mailserversettingschanged();
  // @@protoc_insertion_point(field_mutable:grpc.MailServerSettingsEvent.mailServerSettingsChanged)
  return _msg;
}

// .grpc.ChangeMailServerSettingsFinishedEvent changeMailServerSettingsFinished = 3;
inline bool MailServerSettingsEvent::_internal_has_changemailserversettingsfinished() const {
  return event_case() == kChangeMailServerSettingsFinished;
}
inline bool MailServerSettingsEvent::has_changemailserversettingsfinished() const {
  return _internal_has_changemailserversettingsfinished();
}
inline void MailServerSettingsEvent::set_has_changemailserversettingsfinished() {
  _impl_._oneof_case_[0] = kChangeMailServerSettingsFinished;
}
inline void MailServerSettingsEvent::clear_changemailserversettingsfinished() {
  if (_internal_has_changemailserversettingsfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.changemailserversettingsfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ChangeMailServerSettingsFinishedEvent* MailServerSettingsEvent::release_changemailserversettingsfinished() {
  // @@protoc_insertion_point(field_release:grpc.MailServerSettingsEvent.changeMailServerSettingsFinished)
  if (_internal_has_changemailserversettingsfinished()) {
    clear_has_event();
    ::grpc::ChangeMailServerSettingsFinishedEvent* temp = _impl_.event_.changemailserversettingsfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.changemailserversettingsfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ChangeMailServerSettingsFinishedEvent& MailServerSettingsEvent::_internal_changemailserversettingsfinished() const {
  return _internal_has_changemailserversettingsfinished()
      ? *_impl_.event_.changemailserversettingsfinished_
      : reinterpret_cast< ::grpc::ChangeMailServerSettingsFinishedEvent&>(::grpc::_ChangeMailServerSettingsFinishedEvent_default_instance_);
}
inline const ::grpc::ChangeMailServerSettingsFinishedEvent& MailServerSettingsEvent::changemailserversettingsfinished() const {
  // @@protoc_insertion_point(field_get:grpc.MailServerSettingsEvent.changeMailServerSettingsFinished)
  return _internal_changemailserversettingsfinished();
}
inline ::grpc::ChangeMailServerSettingsFinishedEvent* MailServerSettingsEvent::unsafe_arena_release_changemailserversettingsfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailServerSettingsEvent.changeMailServerSettingsFinished)
  if (_internal_has_changemailserversettingsfinished()) {
    clear_has_event();
    ::grpc::ChangeMailServerSettingsFinishedEvent* temp = _impl_.event_.changemailserversettingsfinished_;
    _impl_.event_.changemailserversettingsfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailServerSettingsEvent::unsafe_arena_set_allocated_changemailserversettingsfinished(::grpc::ChangeMailServerSettingsFinishedEvent* changemailserversettingsfinished) {
  clear_event();
  if (changemailserversettingsfinished) {
    set_has_changemailserversettingsfinished();
    _impl_.event_.changemailserversettingsfinished_ = changemailserversettingsfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailServerSettingsEvent.changeMailServerSettingsFinished)
}
inline ::grpc::ChangeMailServerSettingsFinishedEvent* MailServerSettingsEvent::_internal_mutable_changemailserversettingsfinished() {
  if (!_internal_has_changemailserversettingsfinished()) {
    clear_event();
    set_has_changemailserversettingsfinished();
    _impl_.event_.changemailserversettingsfinished_ = CreateMaybeMessage< ::grpc::ChangeMailServerSettingsFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.changemailserversettingsfinished_;
}
inline ::grpc::ChangeMailServerSettingsFinishedEvent* MailServerSettingsEvent::mutable_changemailserversettingsfinished() {
  ::grpc::ChangeMailServerSettingsFinishedEvent* _msg = _internal_mutable_changemailserversettingsfinished();
  // @@protoc_insertion_point(field_mutable:grpc.MailServerSettingsEvent.changeMailServerSettingsFinished)
  return _msg;
}

inline bool MailServerSettingsEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void MailServerSettingsEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline MailServerSettingsEvent::EventCase MailServerSettingsEvent::event_case() const {
  return MailServerSettingsEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MailServerSettingsErrorEvent

// .grpc.MailServerSettingsErrorType type = 1;
inline void MailServerSettingsErrorEvent::clear_type() {
  _impl_.type_ = 0;
}
inline ::grpc::MailServerSettingsErrorType MailServerSettingsErrorEvent::_internal_type() const {
  return static_cast< ::grpc::MailServerSettingsErrorType >(_impl_.type_);
}
inline ::grpc::MailServerSettingsErrorType MailServerSettingsErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.MailServerSettingsErrorEvent.type)
  return _internal_type();
}
inline void MailServerSettingsErrorEvent::_internal_set_type(::grpc::MailServerSettingsErrorType value) {
  
  _impl_.type_ = value;
}
inline void MailServerSettingsErrorEvent::set_type(::grpc::MailServerSettingsErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.MailServerSettingsErrorEvent.type)
}

// -------------------------------------------------------------------

// MailServerSettingsChangedEvent

// .grpc.ImapSmtpSettings settings = 1;
inline bool MailServerSettingsChangedEvent::_internal_has_settings() const {
  return this != internal_default_instance() && _impl_.settings_ != nullptr;
}
inline bool MailServerSettingsChangedEvent::has_settings() const {
  return _internal_has_settings();
}
inline void MailServerSettingsChangedEvent::clear_settings() {
  if (GetArenaForAllocation() == nullptr && _impl_.settings_ != nullptr) {
    delete _impl_.settings_;
  }
  _impl_.settings_ = nullptr;
}
inline const ::grpc::ImapSmtpSettings& MailServerSettingsChangedEvent::_internal_settings() const {
  const ::grpc::ImapSmtpSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::grpc::ImapSmtpSettings&>(
      ::grpc::_ImapSmtpSettings_default_instance_);
}
inline const ::grpc::ImapSmtpSettings& MailServerSettingsChangedEvent::settings() const {
  // @@protoc_insertion_point(field_get:grpc.MailServerSettingsChangedEvent.settings)
  return _internal_settings();
}
inline void MailServerSettingsChangedEvent::unsafe_arena_set_allocated_settings(
    ::grpc::ImapSmtpSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailServerSettingsChangedEvent.settings)
}
inline ::grpc::ImapSmtpSettings* MailServerSettingsChangedEvent::release_settings() {
  
  ::grpc::ImapSmtpSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::grpc::ImapSmtpSettings* MailServerSettingsChangedEvent::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:grpc.MailServerSettingsChangedEvent.settings)
  
  ::grpc::ImapSmtpSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::grpc::ImapSmtpSettings* MailServerSettingsChangedEvent::_internal_mutable_settings() {
  
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::grpc::ImapSmtpSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::grpc::ImapSmtpSettings* MailServerSettingsChangedEvent::mutable_settings() {
  ::grpc::ImapSmtpSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:grpc.MailServerSettingsChangedEvent.settings)
  return _msg;
}
inline void MailServerSettingsChangedEvent::set_allocated_settings(::grpc::ImapSmtpSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:grpc.MailServerSettingsChangedEvent.settings)
}

// -------------------------------------------------------------------

// ChangeMailServerSettingsFinishedEvent

// -------------------------------------------------------------------

// KeychainEvent

// .grpc.ChangeKeychainFinishedEvent changeKeychainFinished = 1;
inline bool KeychainEvent::_internal_has_changekeychainfinished() const {
  return event_case() == kChangeKeychainFinished;
}
inline bool KeychainEvent::has_changekeychainfinished() const {
  return _internal_has_changekeychainfinished();
}
inline void KeychainEvent::set_has_changekeychainfinished() {
  _impl_._oneof_case_[0] = kChangeKeychainFinished;
}
inline void KeychainEvent::clear_changekeychainfinished() {
  if (_internal_has_changekeychainfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.changekeychainfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::release_changekeychainfinished() {
  // @@protoc_insertion_point(field_release:grpc.KeychainEvent.changeKeychainFinished)
  if (_internal_has_changekeychainfinished()) {
    clear_has_event();
    ::grpc::ChangeKeychainFinishedEvent* temp = _impl_.event_.changekeychainfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.changekeychainfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ChangeKeychainFinishedEvent& KeychainEvent::_internal_changekeychainfinished() const {
  return _internal_has_changekeychainfinished()
      ? *_impl_.event_.changekeychainfinished_
      : reinterpret_cast< ::grpc::ChangeKeychainFinishedEvent&>(::grpc::_ChangeKeychainFinishedEvent_default_instance_);
}
inline const ::grpc::ChangeKeychainFinishedEvent& KeychainEvent::changekeychainfinished() const {
  // @@protoc_insertion_point(field_get:grpc.KeychainEvent.changeKeychainFinished)
  return _internal_changekeychainfinished();
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::unsafe_arena_release_changekeychainfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.KeychainEvent.changeKeychainFinished)
  if (_internal_has_changekeychainfinished()) {
    clear_has_event();
    ::grpc::ChangeKeychainFinishedEvent* temp = _impl_.event_.changekeychainfinished_;
    _impl_.event_.changekeychainfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KeychainEvent::unsafe_arena_set_allocated_changekeychainfinished(::grpc::ChangeKeychainFinishedEvent* changekeychainfinished) {
  clear_event();
  if (changekeychainfinished) {
    set_has_changekeychainfinished();
    _impl_.event_.changekeychainfinished_ = changekeychainfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.KeychainEvent.changeKeychainFinished)
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::_internal_mutable_changekeychainfinished() {
  if (!_internal_has_changekeychainfinished()) {
    clear_event();
    set_has_changekeychainfinished();
    _impl_.event_.changekeychainfinished_ = CreateMaybeMessage< ::grpc::ChangeKeychainFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.changekeychainfinished_;
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::mutable_changekeychainfinished() {
  ::grpc::ChangeKeychainFinishedEvent* _msg = _internal_mutable_changekeychainfinished();
  // @@protoc_insertion_point(field_mutable:grpc.KeychainEvent.changeKeychainFinished)
  return _msg;
}

// .grpc.HasNoKeychainEvent hasNoKeychain = 2;
inline bool KeychainEvent::_internal_has_hasnokeychain() const {
  return event_case() == kHasNoKeychain;
}
inline bool KeychainEvent::has_hasnokeychain() const {
  return _internal_has_hasnokeychain();
}
inline void KeychainEvent::set_has_hasnokeychain() {
  _impl_._oneof_case_[0] = kHasNoKeychain;
}
inline void KeychainEvent::clear_hasnokeychain() {
  if (_internal_has_hasnokeychain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.hasnokeychain_;
    }
    clear_has_event();
  }
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::release_hasnokeychain() {
  // @@protoc_insertion_point(field_release:grpc.KeychainEvent.hasNoKeychain)
  if (_internal_has_hasnokeychain()) {
    clear_has_event();
    ::grpc::HasNoKeychainEvent* temp = _impl_.event_.hasnokeychain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.hasnokeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::HasNoKeychainEvent& KeychainEvent::_internal_hasnokeychain() const {
  return _internal_has_hasnokeychain()
      ? *_impl_.event_.hasnokeychain_
      : reinterpret_cast< ::grpc::HasNoKeychainEvent&>(::grpc::_HasNoKeychainEvent_default_instance_);
}
inline const ::grpc::HasNoKeychainEvent& KeychainEvent::hasnokeychain() const {
  // @@protoc_insertion_point(field_get:grpc.KeychainEvent.hasNoKeychain)
  return _internal_hasnokeychain();
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::unsafe_arena_release_hasnokeychain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.KeychainEvent.hasNoKeychain)
  if (_internal_has_hasnokeychain()) {
    clear_has_event();
    ::grpc::HasNoKeychainEvent* temp = _impl_.event_.hasnokeychain_;
    _impl_.event_.hasnokeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KeychainEvent::unsafe_arena_set_allocated_hasnokeychain(::grpc::HasNoKeychainEvent* hasnokeychain) {
  clear_event();
  if (hasnokeychain) {
    set_has_hasnokeychain();
    _impl_.event_.hasnokeychain_ = hasnokeychain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.KeychainEvent.hasNoKeychain)
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::_internal_mutable_hasnokeychain() {
  if (!_internal_has_hasnokeychain()) {
    clear_event();
    set_has_hasnokeychain();
    _impl_.event_.hasnokeychain_ = CreateMaybeMessage< ::grpc::HasNoKeychainEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.hasnokeychain_;
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::mutable_hasnokeychain() {
  ::grpc::HasNoKeychainEvent* _msg = _internal_mutable_hasnokeychain();
  // @@protoc_insertion_point(field_mutable:grpc.KeychainEvent.hasNoKeychain)
  return _msg;
}

// .grpc.RebuildKeychainEvent rebuildKeychain = 3;
inline bool KeychainEvent::_internal_has_rebuildkeychain() const {
  return event_case() == kRebuildKeychain;
}
inline bool KeychainEvent::has_rebuildkeychain() const {
  return _internal_has_rebuildkeychain();
}
inline void KeychainEvent::set_has_rebuildkeychain() {
  _impl_._oneof_case_[0] = kRebuildKeychain;
}
inline void KeychainEvent::clear_rebuildkeychain() {
  if (_internal_has_rebuildkeychain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.rebuildkeychain_;
    }
    clear_has_event();
  }
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::release_rebuildkeychain() {
  // @@protoc_insertion_point(field_release:grpc.KeychainEvent.rebuildKeychain)
  if (_internal_has_rebuildkeychain()) {
    clear_has_event();
    ::grpc::RebuildKeychainEvent* temp = _impl_.event_.rebuildkeychain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.rebuildkeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::RebuildKeychainEvent& KeychainEvent::_internal_rebuildkeychain() const {
  return _internal_has_rebuildkeychain()
      ? *_impl_.event_.rebuildkeychain_
      : reinterpret_cast< ::grpc::RebuildKeychainEvent&>(::grpc::_RebuildKeychainEvent_default_instance_);
}
inline const ::grpc::RebuildKeychainEvent& KeychainEvent::rebuildkeychain() const {
  // @@protoc_insertion_point(field_get:grpc.KeychainEvent.rebuildKeychain)
  return _internal_rebuildkeychain();
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::unsafe_arena_release_rebuildkeychain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.KeychainEvent.rebuildKeychain)
  if (_internal_has_rebuildkeychain()) {
    clear_has_event();
    ::grpc::RebuildKeychainEvent* temp = _impl_.event_.rebuildkeychain_;
    _impl_.event_.rebuildkeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KeychainEvent::unsafe_arena_set_allocated_rebuildkeychain(::grpc::RebuildKeychainEvent* rebuildkeychain) {
  clear_event();
  if (rebuildkeychain) {
    set_has_rebuildkeychain();
    _impl_.event_.rebuildkeychain_ = rebuildkeychain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.KeychainEvent.rebuildKeychain)
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::_internal_mutable_rebuildkeychain() {
  if (!_internal_has_rebuildkeychain()) {
    clear_event();
    set_has_rebuildkeychain();
    _impl_.event_.rebuildkeychain_ = CreateMaybeMessage< ::grpc::RebuildKeychainEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.rebuildkeychain_;
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::mutable_rebuildkeychain() {
  ::grpc::RebuildKeychainEvent* _msg = _internal_mutable_rebuildkeychain();
  // @@protoc_insertion_point(field_mutable:grpc.KeychainEvent.rebuildKeychain)
  return _msg;
}

inline bool KeychainEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void KeychainEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline KeychainEvent::EventCase KeychainEvent::event_case() const {
  return KeychainEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ChangeKeychainFinishedEvent

// -------------------------------------------------------------------

// HasNoKeychainEvent

// -------------------------------------------------------------------

// RebuildKeychainEvent

// -------------------------------------------------------------------

// MailEvent

// .grpc.NoActiveKeyForRecipientEvent noActiveKeyForRecipientEvent = 1;
inline bool MailEvent::_internal_has_noactivekeyforrecipientevent() const {
  return event_case() == kNoActiveKeyForRecipientEvent;
}
inline bool MailEvent::has_noactivekeyforrecipientevent() const {
  return _internal_has_noactivekeyforrecipientevent();
}
inline void MailEvent::set_has_noactivekeyforrecipientevent() {
  _impl_._oneof_case_[0] = kNoActiveKeyForRecipientEvent;
}
inline void MailEvent::clear_noactivekeyforrecipientevent() {
  if (_internal_has_noactivekeyforrecipientevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.noactivekeyforrecipientevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::release_noactivekeyforrecipientevent() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.noActiveKeyForRecipientEvent)
  if (_internal_has_noactivekeyforrecipientevent()) {
    clear_has_event();
    ::grpc::NoActiveKeyForRecipientEvent* temp = _impl_.event_.noactivekeyforrecipientevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.noactivekeyforrecipientevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::NoActiveKeyForRecipientEvent& MailEvent::_internal_noactivekeyforrecipientevent() const {
  return _internal_has_noactivekeyforrecipientevent()
      ? *_impl_.event_.noactivekeyforrecipientevent_
      : reinterpret_cast< ::grpc::NoActiveKeyForRecipientEvent&>(::grpc::_NoActiveKeyForRecipientEvent_default_instance_);
}
inline const ::grpc::NoActiveKeyForRecipientEvent& MailEvent::noactivekeyforrecipientevent() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.noActiveKeyForRecipientEvent)
  return _internal_noactivekeyforrecipientevent();
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::unsafe_arena_release_noactivekeyforrecipientevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.noActiveKeyForRecipientEvent)
  if (_internal_has_noactivekeyforrecipientevent()) {
    clear_has_event();
    ::grpc::NoActiveKeyForRecipientEvent* temp = _impl_.event_.noactivekeyforrecipientevent_;
    _impl_.event_.noactivekeyforrecipientevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_noactivekeyforrecipientevent(::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent) {
  clear_event();
  if (noactivekeyforrecipientevent) {
    set_has_noactivekeyforrecipientevent();
    _impl_.event_.noactivekeyforrecipientevent_ = noactivekeyforrecipientevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.noActiveKeyForRecipientEvent)
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::_internal_mutable_noactivekeyforrecipientevent() {
  if (!_internal_has_noactivekeyforrecipientevent()) {
    clear_event();
    set_has_noactivekeyforrecipientevent();
    _impl_.event_.noactivekeyforrecipientevent_ = CreateMaybeMessage< ::grpc::NoActiveKeyForRecipientEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.noactivekeyforrecipientevent_;
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::mutable_noactivekeyforrecipientevent() {
  ::grpc::NoActiveKeyForRecipientEvent* _msg = _internal_mutable_noactivekeyforrecipientevent();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.noActiveKeyForRecipientEvent)
  return _msg;
}

// .grpc.AddressChangedEvent addressChanged = 2;
inline bool MailEvent::_internal_has_addresschanged() const {
  return event_case() == kAddressChanged;
}
inline bool MailEvent::has_addresschanged() const {
  return _internal_has_addresschanged();
}
inline void MailEvent::set_has_addresschanged() {
  _impl_._oneof_case_[0] = kAddressChanged;
}
inline void MailEvent::clear_addresschanged() {
  if (_internal_has_addresschanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.addresschanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::AddressChangedEvent* MailEvent::release_addresschanged() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.addressChanged)
  if (_internal_has_addresschanged()) {
    clear_has_event();
    ::grpc::AddressChangedEvent* temp = _impl_.event_.addresschanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.addresschanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::AddressChangedEvent& MailEvent::_internal_addresschanged() const {
  return _internal_has_addresschanged()
      ? *_impl_.event_.addresschanged_
      : reinterpret_cast< ::grpc::AddressChangedEvent&>(::grpc::_AddressChangedEvent_default_instance_);
}
inline const ::grpc::AddressChangedEvent& MailEvent::addresschanged() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.addressChanged)
  return _internal_addresschanged();
}
inline ::grpc::AddressChangedEvent* MailEvent::unsafe_arena_release_addresschanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.addressChanged)
  if (_internal_has_addresschanged()) {
    clear_has_event();
    ::grpc::AddressChangedEvent* temp = _impl_.event_.addresschanged_;
    _impl_.event_.addresschanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_addresschanged(::grpc::AddressChangedEvent* addresschanged) {
  clear_event();
  if (addresschanged) {
    set_has_addresschanged();
    _impl_.event_.addresschanged_ = addresschanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.addressChanged)
}
inline ::grpc::AddressChangedEvent* MailEvent::_internal_mutable_addresschanged() {
  if (!_internal_has_addresschanged()) {
    clear_event();
    set_has_addresschanged();
    _impl_.event_.addresschanged_ = CreateMaybeMessage< ::grpc::AddressChangedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.addresschanged_;
}
inline ::grpc::AddressChangedEvent* MailEvent::mutable_addresschanged() {
  ::grpc::AddressChangedEvent* _msg = _internal_mutable_addresschanged();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.addressChanged)
  return _msg;
}

// .grpc.AddressChangedLogoutEvent addressChangedLogout = 3;
inline bool MailEvent::_internal_has_addresschangedlogout() const {
  return event_case() == kAddressChangedLogout;
}
inline bool MailEvent::has_addresschangedlogout() const {
  return _internal_has_addresschangedlogout();
}
inline void MailEvent::set_has_addresschangedlogout() {
  _impl_._oneof_case_[0] = kAddressChangedLogout;
}
inline void MailEvent::clear_addresschangedlogout() {
  if (_internal_has_addresschangedlogout()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.addresschangedlogout_;
    }
    clear_has_event();
  }
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::release_addresschangedlogout() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.addressChangedLogout)
  if (_internal_has_addresschangedlogout()) {
    clear_has_event();
    ::grpc::AddressChangedLogoutEvent* temp = _impl_.event_.addresschangedlogout_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.addresschangedlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::AddressChangedLogoutEvent& MailEvent::_internal_addresschangedlogout() const {
  return _internal_has_addresschangedlogout()
      ? *_impl_.event_.addresschangedlogout_
      : reinterpret_cast< ::grpc::AddressChangedLogoutEvent&>(::grpc::_AddressChangedLogoutEvent_default_instance_);
}
inline const ::grpc::AddressChangedLogoutEvent& MailEvent::addresschangedlogout() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.addressChangedLogout)
  return _internal_addresschangedlogout();
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::unsafe_arena_release_addresschangedlogout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.addressChangedLogout)
  if (_internal_has_addresschangedlogout()) {
    clear_has_event();
    ::grpc::AddressChangedLogoutEvent* temp = _impl_.event_.addresschangedlogout_;
    _impl_.event_.addresschangedlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_addresschangedlogout(::grpc::AddressChangedLogoutEvent* addresschangedlogout) {
  clear_event();
  if (addresschangedlogout) {
    set_has_addresschangedlogout();
    _impl_.event_.addresschangedlogout_ = addresschangedlogout;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.addressChangedLogout)
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::_internal_mutable_addresschangedlogout() {
  if (!_internal_has_addresschangedlogout()) {
    clear_event();
    set_has_addresschangedlogout();
    _impl_.event_.addresschangedlogout_ = CreateMaybeMessage< ::grpc::AddressChangedLogoutEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.addresschangedlogout_;
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::mutable_addresschangedlogout() {
  ::grpc::AddressChangedLogoutEvent* _msg = _internal_mutable_addresschangedlogout();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.addressChangedLogout)
  return _msg;
}

// .grpc.ApiCertIssueEvent apiCertIssue = 6;
inline bool MailEvent::_internal_has_apicertissue() const {
  return event_case() == kApiCertIssue;
}
inline bool MailEvent::has_apicertissue() const {
  return _internal_has_apicertissue();
}
inline void MailEvent::set_has_apicertissue() {
  _impl_._oneof_case_[0] = kApiCertIssue;
}
inline void MailEvent::clear_apicertissue() {
  if (_internal_has_apicertissue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.apicertissue_;
    }
    clear_has_event();
  }
}
inline ::grpc::ApiCertIssueEvent* MailEvent::release_apicertissue() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.apiCertIssue)
  if (_internal_has_apicertissue()) {
    clear_has_event();
    ::grpc::ApiCertIssueEvent* temp = _impl_.event_.apicertissue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.apicertissue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ApiCertIssueEvent& MailEvent::_internal_apicertissue() const {
  return _internal_has_apicertissue()
      ? *_impl_.event_.apicertissue_
      : reinterpret_cast< ::grpc::ApiCertIssueEvent&>(::grpc::_ApiCertIssueEvent_default_instance_);
}
inline const ::grpc::ApiCertIssueEvent& MailEvent::apicertissue() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.apiCertIssue)
  return _internal_apicertissue();
}
inline ::grpc::ApiCertIssueEvent* MailEvent::unsafe_arena_release_apicertissue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.apiCertIssue)
  if (_internal_has_apicertissue()) {
    clear_has_event();
    ::grpc::ApiCertIssueEvent* temp = _impl_.event_.apicertissue_;
    _impl_.event_.apicertissue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_apicertissue(::grpc::ApiCertIssueEvent* apicertissue) {
  clear_event();
  if (apicertissue) {
    set_has_apicertissue();
    _impl_.event_.apicertissue_ = apicertissue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.apiCertIssue)
}
inline ::grpc::ApiCertIssueEvent* MailEvent::_internal_mutable_apicertissue() {
  if (!_internal_has_apicertissue()) {
    clear_event();
    set_has_apicertissue();
    _impl_.event_.apicertissue_ = CreateMaybeMessage< ::grpc::ApiCertIssueEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.apicertissue_;
}
inline ::grpc::ApiCertIssueEvent* MailEvent::mutable_apicertissue() {
  ::grpc::ApiCertIssueEvent* _msg = _internal_mutable_apicertissue();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.apiCertIssue)
  return _msg;
}

inline bool MailEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void MailEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline MailEvent::EventCase MailEvent::event_case() const {
  return MailEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NoActiveKeyForRecipientEvent

// string email = 1;
inline void NoActiveKeyForRecipientEvent::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& NoActiveKeyForRecipientEvent::email() const {
  // @@protoc_insertion_point(field_get:grpc.NoActiveKeyForRecipientEvent.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoActiveKeyForRecipientEvent::set_email(ArgT0&& arg0, ArgT... args) {
 
 _impl_.email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.NoActiveKeyForRecipientEvent.email)
}
inline std::string* NoActiveKeyForRecipientEvent::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:grpc.NoActiveKeyForRecipientEvent.email)
  return _s;
}
inline const std::string& NoActiveKeyForRecipientEvent::_internal_email() const {
  return _impl_.email_.Get();
}
inline void NoActiveKeyForRecipientEvent::_internal_set_email(const std::string& value) {
  
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* NoActiveKeyForRecipientEvent::_internal_mutable_email() {
  
  return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* NoActiveKeyForRecipientEvent::release_email() {
  // @@protoc_insertion_point(field_release:grpc.NoActiveKeyForRecipientEvent.email)
  return _impl_.email_.Release();
}
inline void NoActiveKeyForRecipientEvent::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.NoActiveKeyForRecipientEvent.email)
}

// -------------------------------------------------------------------

// AddressChangedEvent

// string address = 1;
inline void AddressChangedEvent::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& AddressChangedEvent::address() const {
  // @@protoc_insertion_point(field_get:grpc.AddressChangedEvent.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddressChangedEvent::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.AddressChangedEvent.address)
}
inline std::string* AddressChangedEvent::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.AddressChangedEvent.address)
  return _s;
}
inline const std::string& AddressChangedEvent::_internal_address() const {
  return _impl_.address_.Get();
}
inline void AddressChangedEvent::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* AddressChangedEvent::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* AddressChangedEvent::release_address() {
  // @@protoc_insertion_point(field_release:grpc.AddressChangedEvent.address)
  return _impl_.address_.Release();
}
inline void AddressChangedEvent::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.AddressChangedEvent.address)
}

// -------------------------------------------------------------------

// AddressChangedLogoutEvent

// string address = 1;
inline void AddressChangedLogoutEvent::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& AddressChangedLogoutEvent::address() const {
  // @@protoc_insertion_point(field_get:grpc.AddressChangedLogoutEvent.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddressChangedLogoutEvent::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.AddressChangedLogoutEvent.address)
}
inline std::string* AddressChangedLogoutEvent::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.AddressChangedLogoutEvent.address)
  return _s;
}
inline const std::string& AddressChangedLogoutEvent::_internal_address() const {
  return _impl_.address_.Get();
}
inline void AddressChangedLogoutEvent::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* AddressChangedLogoutEvent::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* AddressChangedLogoutEvent::release_address() {
  // @@protoc_insertion_point(field_release:grpc.AddressChangedLogoutEvent.address)
  return _impl_.address_.Release();
}
inline void AddressChangedLogoutEvent::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.AddressChangedLogoutEvent.address)
}

// -------------------------------------------------------------------

// ApiCertIssueEvent

// -------------------------------------------------------------------

// UserEvent

// .grpc.ToggleSplitModeFinishedEvent toggleSplitModeFinished = 1;
inline bool UserEvent::_internal_has_togglesplitmodefinished() const {
  return event_case() == kToggleSplitModeFinished;
}
inline bool UserEvent::has_togglesplitmodefinished() const {
  return _internal_has_togglesplitmodefinished();
}
inline void UserEvent::set_has_togglesplitmodefinished() {
  _impl_._oneof_case_[0] = kToggleSplitModeFinished;
}
inline void UserEvent::clear_togglesplitmodefinished() {
  if (_internal_has_togglesplitmodefinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.togglesplitmodefinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::release_togglesplitmodefinished() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.toggleSplitModeFinished)
  if (_internal_has_togglesplitmodefinished()) {
    clear_has_event();
    ::grpc::ToggleSplitModeFinishedEvent* temp = _impl_.event_.togglesplitmodefinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.togglesplitmodefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ToggleSplitModeFinishedEvent& UserEvent::_internal_togglesplitmodefinished() const {
  return _internal_has_togglesplitmodefinished()
      ? *_impl_.event_.togglesplitmodefinished_
      : reinterpret_cast< ::grpc::ToggleSplitModeFinishedEvent&>(::grpc::_ToggleSplitModeFinishedEvent_default_instance_);
}
inline const ::grpc::ToggleSplitModeFinishedEvent& UserEvent::togglesplitmodefinished() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.toggleSplitModeFinished)
  return _internal_togglesplitmodefinished();
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::unsafe_arena_release_togglesplitmodefinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.toggleSplitModeFinished)
  if (_internal_has_togglesplitmodefinished()) {
    clear_has_event();
    ::grpc::ToggleSplitModeFinishedEvent* temp = _impl_.event_.togglesplitmodefinished_;
    _impl_.event_.togglesplitmodefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_togglesplitmodefinished(::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished) {
  clear_event();
  if (togglesplitmodefinished) {
    set_has_togglesplitmodefinished();
    _impl_.event_.togglesplitmodefinished_ = togglesplitmodefinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.toggleSplitModeFinished)
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::_internal_mutable_togglesplitmodefinished() {
  if (!_internal_has_togglesplitmodefinished()) {
    clear_event();
    set_has_togglesplitmodefinished();
    _impl_.event_.togglesplitmodefinished_ = CreateMaybeMessage< ::grpc::ToggleSplitModeFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.togglesplitmodefinished_;
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::mutable_togglesplitmodefinished() {
  ::grpc::ToggleSplitModeFinishedEvent* _msg = _internal_mutable_togglesplitmodefinished();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.toggleSplitModeFinished)
  return _msg;
}

// .grpc.UserDisconnectedEvent userDisconnected = 2;
inline bool UserEvent::_internal_has_userdisconnected() const {
  return event_case() == kUserDisconnected;
}
inline bool UserEvent::has_userdisconnected() const {
  return _internal_has_userdisconnected();
}
inline void UserEvent::set_has_userdisconnected() {
  _impl_._oneof_case_[0] = kUserDisconnected;
}
inline void UserEvent::clear_userdisconnected() {
  if (_internal_has_userdisconnected()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.userdisconnected_;
    }
    clear_has_event();
  }
}
inline ::grpc::UserDisconnectedEvent* UserEvent::release_userdisconnected() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.userDisconnected)
  if (_internal_has_userdisconnected()) {
    clear_has_event();
    ::grpc::UserDisconnectedEvent* temp = _impl_.event_.userdisconnected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.userdisconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UserDisconnectedEvent& UserEvent::_internal_userdisconnected() const {
  return _internal_has_userdisconnected()
      ? *_impl_.event_.userdisconnected_
      : reinterpret_cast< ::grpc::UserDisconnectedEvent&>(::grpc::_UserDisconnectedEvent_default_instance_);
}
inline const ::grpc::UserDisconnectedEvent& UserEvent::userdisconnected() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.userDisconnected)
  return _internal_userdisconnected();
}
inline ::grpc::UserDisconnectedEvent* UserEvent::unsafe_arena_release_userdisconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.userDisconnected)
  if (_internal_has_userdisconnected()) {
    clear_has_event();
    ::grpc::UserDisconnectedEvent* temp = _impl_.event_.userdisconnected_;
    _impl_.event_.userdisconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_userdisconnected(::grpc::UserDisconnectedEvent* userdisconnected) {
  clear_event();
  if (userdisconnected) {
    set_has_userdisconnected();
    _impl_.event_.userdisconnected_ = userdisconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.userDisconnected)
}
inline ::grpc::UserDisconnectedEvent* UserEvent::_internal_mutable_userdisconnected() {
  if (!_internal_has_userdisconnected()) {
    clear_event();
    set_has_userdisconnected();
    _impl_.event_.userdisconnected_ = CreateMaybeMessage< ::grpc::UserDisconnectedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.userdisconnected_;
}
inline ::grpc::UserDisconnectedEvent* UserEvent::mutable_userdisconnected() {
  ::grpc::UserDisconnectedEvent* _msg = _internal_mutable_userdisconnected();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.userDisconnected)
  return _msg;
}

// .grpc.UserChangedEvent userChanged = 3;
inline bool UserEvent::_internal_has_userchanged() const {
  return event_case() == kUserChanged;
}
inline bool UserEvent::has_userchanged() const {
  return _internal_has_userchanged();
}
inline void UserEvent::set_has_userchanged() {
  _impl_._oneof_case_[0] = kUserChanged;
}
inline void UserEvent::clear_userchanged() {
  if (_internal_has_userchanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.userchanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::UserChangedEvent* UserEvent::release_userchanged() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.userChanged)
  if (_internal_has_userchanged()) {
    clear_has_event();
    ::grpc::UserChangedEvent* temp = _impl_.event_.userchanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.userchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UserChangedEvent& UserEvent::_internal_userchanged() const {
  return _internal_has_userchanged()
      ? *_impl_.event_.userchanged_
      : reinterpret_cast< ::grpc::UserChangedEvent&>(::grpc::_UserChangedEvent_default_instance_);
}
inline const ::grpc::UserChangedEvent& UserEvent::userchanged() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.userChanged)
  return _internal_userchanged();
}
inline ::grpc::UserChangedEvent* UserEvent::unsafe_arena_release_userchanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.userChanged)
  if (_internal_has_userchanged()) {
    clear_has_event();
    ::grpc::UserChangedEvent* temp = _impl_.event_.userchanged_;
    _impl_.event_.userchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_userchanged(::grpc::UserChangedEvent* userchanged) {
  clear_event();
  if (userchanged) {
    set_has_userchanged();
    _impl_.event_.userchanged_ = userchanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.userChanged)
}
inline ::grpc::UserChangedEvent* UserEvent::_internal_mutable_userchanged() {
  if (!_internal_has_userchanged()) {
    clear_event();
    set_has_userchanged();
    _impl_.event_.userchanged_ = CreateMaybeMessage< ::grpc::UserChangedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.userchanged_;
}
inline ::grpc::UserChangedEvent* UserEvent::mutable_userchanged() {
  ::grpc::UserChangedEvent* _msg = _internal_mutable_userchanged();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.userChanged)
  return _msg;
}

// .grpc.UserBadEvent userBadEvent = 4;
inline bool UserEvent::_internal_has_userbadevent() const {
  return event_case() == kUserBadEvent;
}
inline bool UserEvent::has_userbadevent() const {
  return _internal_has_userbadevent();
}
inline void UserEvent::set_has_userbadevent() {
  _impl_._oneof_case_[0] = kUserBadEvent;
}
inline void UserEvent::clear_userbadevent() {
  if (_internal_has_userbadevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.userbadevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::UserBadEvent* UserEvent::release_userbadevent() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.userBadEvent)
  if (_internal_has_userbadevent()) {
    clear_has_event();
    ::grpc::UserBadEvent* temp = _impl_.event_.userbadevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.userbadevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UserBadEvent& UserEvent::_internal_userbadevent() const {
  return _internal_has_userbadevent()
      ? *_impl_.event_.userbadevent_
      : reinterpret_cast< ::grpc::UserBadEvent&>(::grpc::_UserBadEvent_default_instance_);
}
inline const ::grpc::UserBadEvent& UserEvent::userbadevent() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.userBadEvent)
  return _internal_userbadevent();
}
inline ::grpc::UserBadEvent* UserEvent::unsafe_arena_release_userbadevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.userBadEvent)
  if (_internal_has_userbadevent()) {
    clear_has_event();
    ::grpc::UserBadEvent* temp = _impl_.event_.userbadevent_;
    _impl_.event_.userbadevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_userbadevent(::grpc::UserBadEvent* userbadevent) {
  clear_event();
  if (userbadevent) {
    set_has_userbadevent();
    _impl_.event_.userbadevent_ = userbadevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.userBadEvent)
}
inline ::grpc::UserBadEvent* UserEvent::_internal_mutable_userbadevent() {
  if (!_internal_has_userbadevent()) {
    clear_event();
    set_has_userbadevent();
    _impl_.event_.userbadevent_ = CreateMaybeMessage< ::grpc::UserBadEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.userbadevent_;
}
inline ::grpc::UserBadEvent* UserEvent::mutable_userbadevent() {
  ::grpc::UserBadEvent* _msg = _internal_mutable_userbadevent();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.userBadEvent)
  return _msg;
}

// .grpc.UsedBytesChangedEvent usedBytesChangedEvent = 5;
inline bool UserEvent::_internal_has_usedbyteschangedevent() const {
  return event_case() == kUsedBytesChangedEvent;
}
inline bool UserEvent::has_usedbyteschangedevent() const {
  return _internal_has_usedbyteschangedevent();
}
inline void UserEvent::set_has_usedbyteschangedevent() {
  _impl_._oneof_case_[0] = kUsedBytesChangedEvent;
}
inline void UserEvent::clear_usedbyteschangedevent() {
  if (_internal_has_usedbyteschangedevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.usedbyteschangedevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::UsedBytesChangedEvent* UserEvent::release_usedbyteschangedevent() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.usedBytesChangedEvent)
  if (_internal_has_usedbyteschangedevent()) {
    clear_has_event();
    ::grpc::UsedBytesChangedEvent* temp = _impl_.event_.usedbyteschangedevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.usedbyteschangedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UsedBytesChangedEvent& UserEvent::_internal_usedbyteschangedevent() const {
  return _internal_has_usedbyteschangedevent()
      ? *_impl_.event_.usedbyteschangedevent_
      : reinterpret_cast< ::grpc::UsedBytesChangedEvent&>(::grpc::_UsedBytesChangedEvent_default_instance_);
}
inline const ::grpc::UsedBytesChangedEvent& UserEvent::usedbyteschangedevent() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.usedBytesChangedEvent)
  return _internal_usedbyteschangedevent();
}
inline ::grpc::UsedBytesChangedEvent* UserEvent::unsafe_arena_release_usedbyteschangedevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.usedBytesChangedEvent)
  if (_internal_has_usedbyteschangedevent()) {
    clear_has_event();
    ::grpc::UsedBytesChangedEvent* temp = _impl_.event_.usedbyteschangedevent_;
    _impl_.event_.usedbyteschangedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_usedbyteschangedevent(::grpc::UsedBytesChangedEvent* usedbyteschangedevent) {
  clear_event();
  if (usedbyteschangedevent) {
    set_has_usedbyteschangedevent();
    _impl_.event_.usedbyteschangedevent_ = usedbyteschangedevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.usedBytesChangedEvent)
}
inline ::grpc::UsedBytesChangedEvent* UserEvent::_internal_mutable_usedbyteschangedevent() {
  if (!_internal_has_usedbyteschangedevent()) {
    clear_event();
    set_has_usedbyteschangedevent();
    _impl_.event_.usedbyteschangedevent_ = CreateMaybeMessage< ::grpc::UsedBytesChangedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.usedbyteschangedevent_;
}
inline ::grpc::UsedBytesChangedEvent* UserEvent::mutable_usedbyteschangedevent() {
  ::grpc::UsedBytesChangedEvent* _msg = _internal_mutable_usedbyteschangedevent();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.usedBytesChangedEvent)
  return _msg;
}

// .grpc.ImapLoginFailedEvent imapLoginFailedEvent = 6;
inline bool UserEvent::_internal_has_imaploginfailedevent() const {
  return event_case() == kImapLoginFailedEvent;
}
inline bool UserEvent::has_imaploginfailedevent() const {
  return _internal_has_imaploginfailedevent();
}
inline void UserEvent::set_has_imaploginfailedevent() {
  _impl_._oneof_case_[0] = kImapLoginFailedEvent;
}
inline void UserEvent::clear_imaploginfailedevent() {
  if (_internal_has_imaploginfailedevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.imaploginfailedevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::ImapLoginFailedEvent* UserEvent::release_imaploginfailedevent() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.imapLoginFailedEvent)
  if (_internal_has_imaploginfailedevent()) {
    clear_has_event();
    ::grpc::ImapLoginFailedEvent* temp = _impl_.event_.imaploginfailedevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.imaploginfailedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ImapLoginFailedEvent& UserEvent::_internal_imaploginfailedevent() const {
  return _internal_has_imaploginfailedevent()
      ? *_impl_.event_.imaploginfailedevent_
      : reinterpret_cast< ::grpc::ImapLoginFailedEvent&>(::grpc::_ImapLoginFailedEvent_default_instance_);
}
inline const ::grpc::ImapLoginFailedEvent& UserEvent::imaploginfailedevent() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.imapLoginFailedEvent)
  return _internal_imaploginfailedevent();
}
inline ::grpc::ImapLoginFailedEvent* UserEvent::unsafe_arena_release_imaploginfailedevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.imapLoginFailedEvent)
  if (_internal_has_imaploginfailedevent()) {
    clear_has_event();
    ::grpc::ImapLoginFailedEvent* temp = _impl_.event_.imaploginfailedevent_;
    _impl_.event_.imaploginfailedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_imaploginfailedevent(::grpc::ImapLoginFailedEvent* imaploginfailedevent) {
  clear_event();
  if (imaploginfailedevent) {
    set_has_imaploginfailedevent();
    _impl_.event_.imaploginfailedevent_ = imaploginfailedevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.imapLoginFailedEvent)
}
inline ::grpc::ImapLoginFailedEvent* UserEvent::_internal_mutable_imaploginfailedevent() {
  if (!_internal_has_imaploginfailedevent()) {
    clear_event();
    set_has_imaploginfailedevent();
    _impl_.event_.imaploginfailedevent_ = CreateMaybeMessage< ::grpc::ImapLoginFailedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.imaploginfailedevent_;
}
inline ::grpc::ImapLoginFailedEvent* UserEvent::mutable_imaploginfailedevent() {
  ::grpc::ImapLoginFailedEvent* _msg = _internal_mutable_imaploginfailedevent();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.imapLoginFailedEvent)
  return _msg;
}

// .grpc.SyncStartedEvent syncStartedEvent = 7;
inline bool UserEvent::_internal_has_syncstartedevent() const {
  return event_case() == kSyncStartedEvent;
}
inline bool UserEvent::has_syncstartedevent() const {
  return _internal_has_syncstartedevent();
}
inline void UserEvent::set_has_syncstartedevent() {
  _impl_._oneof_case_[0] = kSyncStartedEvent;
}
inline void UserEvent::clear_syncstartedevent() {
  if (_internal_has_syncstartedevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.syncstartedevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::SyncStartedEvent* UserEvent::release_syncstartedevent() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.syncStartedEvent)
  if (_internal_has_syncstartedevent()) {
    clear_has_event();
    ::grpc::SyncStartedEvent* temp = _impl_.event_.syncstartedevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.syncstartedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::SyncStartedEvent& UserEvent::_internal_syncstartedevent() const {
  return _internal_has_syncstartedevent()
      ? *_impl_.event_.syncstartedevent_
      : reinterpret_cast< ::grpc::SyncStartedEvent&>(::grpc::_SyncStartedEvent_default_instance_);
}
inline const ::grpc::SyncStartedEvent& UserEvent::syncstartedevent() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.syncStartedEvent)
  return _internal_syncstartedevent();
}
inline ::grpc::SyncStartedEvent* UserEvent::unsafe_arena_release_syncstartedevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.syncStartedEvent)
  if (_internal_has_syncstartedevent()) {
    clear_has_event();
    ::grpc::SyncStartedEvent* temp = _impl_.event_.syncstartedevent_;
    _impl_.event_.syncstartedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_syncstartedevent(::grpc::SyncStartedEvent* syncstartedevent) {
  clear_event();
  if (syncstartedevent) {
    set_has_syncstartedevent();
    _impl_.event_.syncstartedevent_ = syncstartedevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.syncStartedEvent)
}
inline ::grpc::SyncStartedEvent* UserEvent::_internal_mutable_syncstartedevent() {
  if (!_internal_has_syncstartedevent()) {
    clear_event();
    set_has_syncstartedevent();
    _impl_.event_.syncstartedevent_ = CreateMaybeMessage< ::grpc::SyncStartedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.syncstartedevent_;
}
inline ::grpc::SyncStartedEvent* UserEvent::mutable_syncstartedevent() {
  ::grpc::SyncStartedEvent* _msg = _internal_mutable_syncstartedevent();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.syncStartedEvent)
  return _msg;
}

// .grpc.SyncFinishedEvent syncFinishedEvent = 8;
inline bool UserEvent::_internal_has_syncfinishedevent() const {
  return event_case() == kSyncFinishedEvent;
}
inline bool UserEvent::has_syncfinishedevent() const {
  return _internal_has_syncfinishedevent();
}
inline void UserEvent::set_has_syncfinishedevent() {
  _impl_._oneof_case_[0] = kSyncFinishedEvent;
}
inline void UserEvent::clear_syncfinishedevent() {
  if (_internal_has_syncfinishedevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.syncfinishedevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::SyncFinishedEvent* UserEvent::release_syncfinishedevent() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.syncFinishedEvent)
  if (_internal_has_syncfinishedevent()) {
    clear_has_event();
    ::grpc::SyncFinishedEvent* temp = _impl_.event_.syncfinishedevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.syncfinishedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::SyncFinishedEvent& UserEvent::_internal_syncfinishedevent() const {
  return _internal_has_syncfinishedevent()
      ? *_impl_.event_.syncfinishedevent_
      : reinterpret_cast< ::grpc::SyncFinishedEvent&>(::grpc::_SyncFinishedEvent_default_instance_);
}
inline const ::grpc::SyncFinishedEvent& UserEvent::syncfinishedevent() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.syncFinishedEvent)
  return _internal_syncfinishedevent();
}
inline ::grpc::SyncFinishedEvent* UserEvent::unsafe_arena_release_syncfinishedevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.syncFinishedEvent)
  if (_internal_has_syncfinishedevent()) {
    clear_has_event();
    ::grpc::SyncFinishedEvent* temp = _impl_.event_.syncfinishedevent_;
    _impl_.event_.syncfinishedevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_syncfinishedevent(::grpc::SyncFinishedEvent* syncfinishedevent) {
  clear_event();
  if (syncfinishedevent) {
    set_has_syncfinishedevent();
    _impl_.event_.syncfinishedevent_ = syncfinishedevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.syncFinishedEvent)
}
inline ::grpc::SyncFinishedEvent* UserEvent::_internal_mutable_syncfinishedevent() {
  if (!_internal_has_syncfinishedevent()) {
    clear_event();
    set_has_syncfinishedevent();
    _impl_.event_.syncfinishedevent_ = CreateMaybeMessage< ::grpc::SyncFinishedEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.syncfinishedevent_;
}
inline ::grpc::SyncFinishedEvent* UserEvent::mutable_syncfinishedevent() {
  ::grpc::SyncFinishedEvent* _msg = _internal_mutable_syncfinishedevent();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.syncFinishedEvent)
  return _msg;
}

// .grpc.SyncProgressEvent syncProgressEvent = 9;
inline bool UserEvent::_internal_has_syncprogressevent() const {
  return event_case() == kSyncProgressEvent;
}
inline bool UserEvent::has_syncprogressevent() const {
  return _internal_has_syncprogressevent();
}
inline void UserEvent::set_has_syncprogressevent() {
  _impl_._oneof_case_[0] = kSyncProgressEvent;
}
inline void UserEvent::clear_syncprogressevent() {
  if (_internal_has_syncprogressevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.syncprogressevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::SyncProgressEvent* UserEvent::release_syncprogressevent() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.syncProgressEvent)
  if (_internal_has_syncprogressevent()) {
    clear_has_event();
    ::grpc::SyncProgressEvent* temp = _impl_.event_.syncprogressevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.syncprogressevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::SyncProgressEvent& UserEvent::_internal_syncprogressevent() const {
  return _internal_has_syncprogressevent()
      ? *_impl_.event_.syncprogressevent_
      : reinterpret_cast< ::grpc::SyncProgressEvent&>(::grpc::_SyncProgressEvent_default_instance_);
}
inline const ::grpc::SyncProgressEvent& UserEvent::syncprogressevent() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.syncProgressEvent)
  return _internal_syncprogressevent();
}
inline ::grpc::SyncProgressEvent* UserEvent::unsafe_arena_release_syncprogressevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.syncProgressEvent)
  if (_internal_has_syncprogressevent()) {
    clear_has_event();
    ::grpc::SyncProgressEvent* temp = _impl_.event_.syncprogressevent_;
    _impl_.event_.syncprogressevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_syncprogressevent(::grpc::SyncProgressEvent* syncprogressevent) {
  clear_event();
  if (syncprogressevent) {
    set_has_syncprogressevent();
    _impl_.event_.syncprogressevent_ = syncprogressevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.syncProgressEvent)
}
inline ::grpc::SyncProgressEvent* UserEvent::_internal_mutable_syncprogressevent() {
  if (!_internal_has_syncprogressevent()) {
    clear_event();
    set_has_syncprogressevent();
    _impl_.event_.syncprogressevent_ = CreateMaybeMessage< ::grpc::SyncProgressEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.syncprogressevent_;
}
inline ::grpc::SyncProgressEvent* UserEvent::mutable_syncprogressevent() {
  ::grpc::SyncProgressEvent* _msg = _internal_mutable_syncprogressevent();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.syncProgressEvent)
  return _msg;
}

inline bool UserEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void UserEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline UserEvent::EventCase UserEvent::event_case() const {
  return UserEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ToggleSplitModeFinishedEvent

// string userID = 1;
inline void ToggleSplitModeFinishedEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& ToggleSplitModeFinishedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.ToggleSplitModeFinishedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToggleSplitModeFinishedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ToggleSplitModeFinishedEvent.userID)
}
inline std::string* ToggleSplitModeFinishedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.ToggleSplitModeFinishedEvent.userID)
  return _s;
}
inline const std::string& ToggleSplitModeFinishedEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void ToggleSplitModeFinishedEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* ToggleSplitModeFinishedEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* ToggleSplitModeFinishedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.ToggleSplitModeFinishedEvent.userID)
  return _impl_.userid_.Release();
}
inline void ToggleSplitModeFinishedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ToggleSplitModeFinishedEvent.userID)
}

// -------------------------------------------------------------------

// UserDisconnectedEvent

// string username = 1;
inline void UserDisconnectedEvent::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserDisconnectedEvent::username() const {
  // @@protoc_insertion_point(field_get:grpc.UserDisconnectedEvent.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDisconnectedEvent::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserDisconnectedEvent.username)
}
inline std::string* UserDisconnectedEvent::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.UserDisconnectedEvent.username)
  return _s;
}
inline const std::string& UserDisconnectedEvent::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserDisconnectedEvent::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserDisconnectedEvent::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserDisconnectedEvent::release_username() {
  // @@protoc_insertion_point(field_release:grpc.UserDisconnectedEvent.username)
  return _impl_.username_.Release();
}
inline void UserDisconnectedEvent::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserDisconnectedEvent.username)
}

// -------------------------------------------------------------------

// UserChangedEvent

// string userID = 1;
inline void UserChangedEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserChangedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.UserChangedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserChangedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserChangedEvent.userID)
}
inline std::string* UserChangedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.UserChangedEvent.userID)
  return _s;
}
inline const std::string& UserChangedEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserChangedEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserChangedEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserChangedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.UserChangedEvent.userID)
  return _impl_.userid_.Release();
}
inline void UserChangedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserChangedEvent.userID)
}

// -------------------------------------------------------------------

// UserBadEvent

// string userID = 1;
inline void UserBadEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UserBadEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.UserBadEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserBadEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserBadEvent.userID)
}
inline std::string* UserBadEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.UserBadEvent.userID)
  return _s;
}
inline const std::string& UserBadEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UserBadEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UserBadEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UserBadEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.UserBadEvent.userID)
  return _impl_.userid_.Release();
}
inline void UserBadEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserBadEvent.userID)
}

// string errorMessage = 2;
inline void UserBadEvent::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& UserBadEvent::errormessage() const {
  // @@protoc_insertion_point(field_get:grpc.UserBadEvent.errorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserBadEvent::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserBadEvent.errorMessage)
}
inline std::string* UserBadEvent::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:grpc.UserBadEvent.errorMessage)
  return _s;
}
inline const std::string& UserBadEvent::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void UserBadEvent::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* UserBadEvent::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* UserBadEvent::release_errormessage() {
  // @@protoc_insertion_point(field_release:grpc.UserBadEvent.errorMessage)
  return _impl_.errormessage_.Release();
}
inline void UserBadEvent::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserBadEvent.errorMessage)
}

// -------------------------------------------------------------------

// UsedBytesChangedEvent

// string userID = 1;
inline void UsedBytesChangedEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& UsedBytesChangedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.UsedBytesChangedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UsedBytesChangedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UsedBytesChangedEvent.userID)
}
inline std::string* UsedBytesChangedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.UsedBytesChangedEvent.userID)
  return _s;
}
inline const std::string& UsedBytesChangedEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void UsedBytesChangedEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* UsedBytesChangedEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* UsedBytesChangedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.UsedBytesChangedEvent.userID)
  return _impl_.userid_.Release();
}
inline void UsedBytesChangedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UsedBytesChangedEvent.userID)
}

// int64 usedBytes = 2;
inline void UsedBytesChangedEvent::clear_usedbytes() {
  _impl_.usedbytes_ = int64_t{0};
}
inline int64_t UsedBytesChangedEvent::_internal_usedbytes() const {
  return _impl_.usedbytes_;
}
inline int64_t UsedBytesChangedEvent::usedbytes() const {
  // @@protoc_insertion_point(field_get:grpc.UsedBytesChangedEvent.usedBytes)
  return _internal_usedbytes();
}
inline void UsedBytesChangedEvent::_internal_set_usedbytes(int64_t value) {
  
  _impl_.usedbytes_ = value;
}
inline void UsedBytesChangedEvent::set_usedbytes(int64_t value) {
  _internal_set_usedbytes(value);
  // @@protoc_insertion_point(field_set:grpc.UsedBytesChangedEvent.usedBytes)
}

// -------------------------------------------------------------------

// ImapLoginFailedEvent

// string username = 1;
inline void ImapLoginFailedEvent::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& ImapLoginFailedEvent::username() const {
  // @@protoc_insertion_point(field_get:grpc.ImapLoginFailedEvent.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImapLoginFailedEvent::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ImapLoginFailedEvent.username)
}
inline std::string* ImapLoginFailedEvent::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.ImapLoginFailedEvent.username)
  return _s;
}
inline const std::string& ImapLoginFailedEvent::_internal_username() const {
  return _impl_.username_.Get();
}
inline void ImapLoginFailedEvent::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* ImapLoginFailedEvent::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* ImapLoginFailedEvent::release_username() {
  // @@protoc_insertion_point(field_release:grpc.ImapLoginFailedEvent.username)
  return _impl_.username_.Release();
}
inline void ImapLoginFailedEvent::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ImapLoginFailedEvent.username)
}

// -------------------------------------------------------------------

// SyncStartedEvent

// string userID = 1;
inline void SyncStartedEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& SyncStartedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.SyncStartedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncStartedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.SyncStartedEvent.userID)
}
inline std::string* SyncStartedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.SyncStartedEvent.userID)
  return _s;
}
inline const std::string& SyncStartedEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void SyncStartedEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncStartedEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncStartedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.SyncStartedEvent.userID)
  return _impl_.userid_.Release();
}
inline void SyncStartedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.SyncStartedEvent.userID)
}

// -------------------------------------------------------------------

// SyncFinishedEvent

// string userID = 1;
inline void SyncFinishedEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& SyncFinishedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.SyncFinishedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncFinishedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.SyncFinishedEvent.userID)
}
inline std::string* SyncFinishedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.SyncFinishedEvent.userID)
  return _s;
}
inline const std::string& SyncFinishedEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void SyncFinishedEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncFinishedEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncFinishedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.SyncFinishedEvent.userID)
  return _impl_.userid_.Release();
}
inline void SyncFinishedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.SyncFinishedEvent.userID)
}

// -------------------------------------------------------------------

// SyncProgressEvent

// string userID = 1;
inline void SyncProgressEvent::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& SyncProgressEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.SyncProgressEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncProgressEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.SyncProgressEvent.userID)
}
inline std::string* SyncProgressEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.SyncProgressEvent.userID)
  return _s;
}
inline const std::string& SyncProgressEvent::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void SyncProgressEvent::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncProgressEvent::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncProgressEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.SyncProgressEvent.userID)
  return _impl_.userid_.Release();
}
inline void SyncProgressEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.SyncProgressEvent.userID)
}

// double progress = 2;
inline void SyncProgressEvent::clear_progress() {
  _impl_.progress_ = 0;
}
inline double SyncProgressEvent::_internal_progress() const {
  return _impl_.progress_;
}
inline double SyncProgressEvent::progress() const {
  // @@protoc_insertion_point(field_get:grpc.SyncProgressEvent.progress)
  return _internal_progress();
}
inline void SyncProgressEvent::_internal_set_progress(double value) {
  
  _impl_.progress_ = value;
}
inline void SyncProgressEvent::set_progress(double value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:grpc.SyncProgressEvent.progress)
}

// int64 elapsedMs = 3;
inline void SyncProgressEvent::clear_elapsedms() {
  _impl_.elapsedms_ = int64_t{0};
}
inline int64_t SyncProgressEvent::_internal_elapsedms() const {
  return _impl_.elapsedms_;
}
inline int64_t SyncProgressEvent::elapsedms() const {
  // @@protoc_insertion_point(field_get:grpc.SyncProgressEvent.elapsedMs)
  return _internal_elapsedms();
}
inline void SyncProgressEvent::_internal_set_elapsedms(int64_t value) {
  
  _impl_.elapsedms_ = value;
}
inline void SyncProgressEvent::set_elapsedms(int64_t value) {
  _internal_set_elapsedms(value);
  // @@protoc_insertion_point(field_set:grpc.SyncProgressEvent.elapsedMs)
}

// int64 remainingMs = 4;
inline void SyncProgressEvent::clear_remainingms() {
  _impl_.remainingms_ = int64_t{0};
}
inline int64_t SyncProgressEvent::_internal_remainingms() const {
  return _impl_.remainingms_;
}
inline int64_t SyncProgressEvent::remainingms() const {
  // @@protoc_insertion_point(field_get:grpc.SyncProgressEvent.remainingMs)
  return _internal_remainingms();
}
inline void SyncProgressEvent::_internal_set_remainingms(int64_t value) {
  
  _impl_.remainingms_ = value;
}
inline void SyncProgressEvent::set_remainingms(int64_t value) {
  _internal_set_remainingms(value);
  // @@protoc_insertion_point(field_set:grpc.SyncProgressEvent.remainingMs)
}

// -------------------------------------------------------------------

// GenericErrorEvent

// .grpc.ErrorCode code = 1;
inline void GenericErrorEvent::clear_code() {
  _impl_.code_ = 0;
}
inline ::grpc::ErrorCode GenericErrorEvent::_internal_code() const {
  return static_cast< ::grpc::ErrorCode >(_impl_.code_);
}
inline ::grpc::ErrorCode GenericErrorEvent::code() const {
  // @@protoc_insertion_point(field_get:grpc.GenericErrorEvent.code)
  return _internal_code();
}
inline void GenericErrorEvent::_internal_set_code(::grpc::ErrorCode value) {
  
  _impl_.code_ = value;
}
inline void GenericErrorEvent::set_code(::grpc::ErrorCode value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:grpc.GenericErrorEvent.code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::grpc::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::LogLevel>() {
  return ::grpc::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::grpc::UserState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::UserState>() {
  return ::grpc::UserState_descriptor();
}
template <> struct is_proto_enum< ::grpc::LoginErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::LoginErrorType>() {
  return ::grpc::LoginErrorType_descriptor();
}
template <> struct is_proto_enum< ::grpc::UpdateErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::UpdateErrorType>() {
  return ::grpc::UpdateErrorType_descriptor();
}
template <> struct is_proto_enum< ::grpc::DiskCacheErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::DiskCacheErrorType>() {
  return ::grpc::DiskCacheErrorType_descriptor();
}
template <> struct is_proto_enum< ::grpc::MailServerSettingsErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::MailServerSettingsErrorType>() {
  return ::grpc::MailServerSettingsErrorType_descriptor();
}
template <> struct is_proto_enum< ::grpc::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::ErrorCode>() {
  return ::grpc::ErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bridge_2eproto
