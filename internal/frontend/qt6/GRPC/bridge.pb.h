// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bridge.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bridge_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bridge_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bridge_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bridge_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[55]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bridge_2eproto;
namespace grpc {
class AddressChangedEvent;
struct AddressChangedEventDefaultTypeInternal;
extern AddressChangedEventDefaultTypeInternal _AddressChangedEvent_default_instance_;
class AddressChangedLogoutEvent;
struct AddressChangedLogoutEventDefaultTypeInternal;
extern AddressChangedLogoutEventDefaultTypeInternal _AddressChangedLogoutEvent_default_instance_;
class ApiCertIssueEvent;
struct ApiCertIssueEventDefaultTypeInternal;
extern ApiCertIssueEventDefaultTypeInternal _ApiCertIssueEvent_default_instance_;
class AppEvent;
struct AppEventDefaultTypeInternal;
extern AppEventDefaultTypeInternal _AppEvent_default_instance_;
class AvailableKeychainsResponse;
struct AvailableKeychainsResponseDefaultTypeInternal;
extern AvailableKeychainsResponseDefaultTypeInternal _AvailableKeychainsResponse_default_instance_;
class CacheErrorEvent;
struct CacheErrorEventDefaultTypeInternal;
extern CacheErrorEventDefaultTypeInternal _CacheErrorEvent_default_instance_;
class CacheEvent;
struct CacheEventDefaultTypeInternal;
extern CacheEventDefaultTypeInternal _CacheEvent_default_instance_;
class CacheLocationChangeSuccessEvent;
struct CacheLocationChangeSuccessEventDefaultTypeInternal;
extern CacheLocationChangeSuccessEventDefaultTypeInternal _CacheLocationChangeSuccessEvent_default_instance_;
class ChangeKeychainFinishedEvent;
struct ChangeKeychainFinishedEventDefaultTypeInternal;
extern ChangeKeychainFinishedEventDefaultTypeInternal _ChangeKeychainFinishedEvent_default_instance_;
class ChangeLocalCacheFinishedEvent;
struct ChangeLocalCacheFinishedEventDefaultTypeInternal;
extern ChangeLocalCacheFinishedEventDefaultTypeInternal _ChangeLocalCacheFinishedEvent_default_instance_;
class ChangeLocalCacheRequest;
struct ChangeLocalCacheRequestDefaultTypeInternal;
extern ChangeLocalCacheRequestDefaultTypeInternal _ChangeLocalCacheRequest_default_instance_;
class ChangePortsFinishedEvent;
struct ChangePortsFinishedEventDefaultTypeInternal;
extern ChangePortsFinishedEventDefaultTypeInternal _ChangePortsFinishedEvent_default_instance_;
class ChangePortsRequest;
struct ChangePortsRequestDefaultTypeInternal;
extern ChangePortsRequestDefaultTypeInternal _ChangePortsRequest_default_instance_;
class ConfigureAppleMailRequest;
struct ConfigureAppleMailRequestDefaultTypeInternal;
extern ConfigureAppleMailRequestDefaultTypeInternal _ConfigureAppleMailRequest_default_instance_;
class DiskCachePathChanged;
struct DiskCachePathChangedDefaultTypeInternal;
extern DiskCachePathChangedDefaultTypeInternal _DiskCachePathChanged_default_instance_;
class HasNoKeychainEvent;
struct HasNoKeychainEventDefaultTypeInternal;
extern HasNoKeychainEventDefaultTypeInternal _HasNoKeychainEvent_default_instance_;
class InternetStatusEvent;
struct InternetStatusEventDefaultTypeInternal;
extern InternetStatusEventDefaultTypeInternal _InternetStatusEvent_default_instance_;
class IsCacheOnDiskEnabledChanged;
struct IsCacheOnDiskEnabledChangedDefaultTypeInternal;
extern IsCacheOnDiskEnabledChangedDefaultTypeInternal _IsCacheOnDiskEnabledChanged_default_instance_;
class KeychainEvent;
struct KeychainEventDefaultTypeInternal;
extern KeychainEventDefaultTypeInternal _KeychainEvent_default_instance_;
class LoginAbortRequest;
struct LoginAbortRequestDefaultTypeInternal;
extern LoginAbortRequestDefaultTypeInternal _LoginAbortRequest_default_instance_;
class LoginErrorEvent;
struct LoginErrorEventDefaultTypeInternal;
extern LoginErrorEventDefaultTypeInternal _LoginErrorEvent_default_instance_;
class LoginEvent;
struct LoginEventDefaultTypeInternal;
extern LoginEventDefaultTypeInternal _LoginEvent_default_instance_;
class LoginFinishedEvent;
struct LoginFinishedEventDefaultTypeInternal;
extern LoginFinishedEventDefaultTypeInternal _LoginFinishedEvent_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginTfaRequestedEvent;
struct LoginTfaRequestedEventDefaultTypeInternal;
extern LoginTfaRequestedEventDefaultTypeInternal _LoginTfaRequestedEvent_default_instance_;
class LoginTwoPasswordsRequestedEvent;
struct LoginTwoPasswordsRequestedEventDefaultTypeInternal;
extern LoginTwoPasswordsRequestedEventDefaultTypeInternal _LoginTwoPasswordsRequestedEvent_default_instance_;
class MailEvent;
struct MailEventDefaultTypeInternal;
extern MailEventDefaultTypeInternal _MailEvent_default_instance_;
class MailSettingsErrorEvent;
struct MailSettingsErrorEventDefaultTypeInternal;
extern MailSettingsErrorEventDefaultTypeInternal _MailSettingsErrorEvent_default_instance_;
class MailSettingsEvent;
struct MailSettingsEventDefaultTypeInternal;
extern MailSettingsEventDefaultTypeInternal _MailSettingsEvent_default_instance_;
class NoActiveKeyForRecipientEvent;
struct NoActiveKeyForRecipientEventDefaultTypeInternal;
extern NoActiveKeyForRecipientEventDefaultTypeInternal _NoActiveKeyForRecipientEvent_default_instance_;
class RebuildKeychainEvent;
struct RebuildKeychainEventDefaultTypeInternal;
extern RebuildKeychainEventDefaultTypeInternal _RebuildKeychainEvent_default_instance_;
class ReportBugErrorEvent;
struct ReportBugErrorEventDefaultTypeInternal;
extern ReportBugErrorEventDefaultTypeInternal _ReportBugErrorEvent_default_instance_;
class ReportBugFinishedEvent;
struct ReportBugFinishedEventDefaultTypeInternal;
extern ReportBugFinishedEventDefaultTypeInternal _ReportBugFinishedEvent_default_instance_;
class ReportBugRequest;
struct ReportBugRequestDefaultTypeInternal;
extern ReportBugRequestDefaultTypeInternal _ReportBugRequest_default_instance_;
class ReportBugSuccessEvent;
struct ReportBugSuccessEventDefaultTypeInternal;
extern ReportBugSuccessEventDefaultTypeInternal _ReportBugSuccessEvent_default_instance_;
class ResetFinishedEvent;
struct ResetFinishedEventDefaultTypeInternal;
extern ResetFinishedEventDefaultTypeInternal _ResetFinishedEvent_default_instance_;
class ShowMainWindowEvent;
struct ShowMainWindowEventDefaultTypeInternal;
extern ShowMainWindowEventDefaultTypeInternal _ShowMainWindowEvent_default_instance_;
class StreamEvent;
struct StreamEventDefaultTypeInternal;
extern StreamEventDefaultTypeInternal _StreamEvent_default_instance_;
class ToggleAutostartFinishedEvent;
struct ToggleAutostartFinishedEventDefaultTypeInternal;
extern ToggleAutostartFinishedEventDefaultTypeInternal _ToggleAutostartFinishedEvent_default_instance_;
class ToggleSplitModeFinishedEvent;
struct ToggleSplitModeFinishedEventDefaultTypeInternal;
extern ToggleSplitModeFinishedEventDefaultTypeInternal _ToggleSplitModeFinishedEvent_default_instance_;
class UpdateCheckFinished;
struct UpdateCheckFinishedDefaultTypeInternal;
extern UpdateCheckFinishedDefaultTypeInternal _UpdateCheckFinished_default_instance_;
class UpdateErrorEvent;
struct UpdateErrorEventDefaultTypeInternal;
extern UpdateErrorEventDefaultTypeInternal _UpdateErrorEvent_default_instance_;
class UpdateEvent;
struct UpdateEventDefaultTypeInternal;
extern UpdateEventDefaultTypeInternal _UpdateEvent_default_instance_;
class UpdateForceEvent;
struct UpdateForceEventDefaultTypeInternal;
extern UpdateForceEventDefaultTypeInternal _UpdateForceEvent_default_instance_;
class UpdateIsLatestVersion;
struct UpdateIsLatestVersionDefaultTypeInternal;
extern UpdateIsLatestVersionDefaultTypeInternal _UpdateIsLatestVersion_default_instance_;
class UpdateManualReadyEvent;
struct UpdateManualReadyEventDefaultTypeInternal;
extern UpdateManualReadyEventDefaultTypeInternal _UpdateManualReadyEvent_default_instance_;
class UpdateManualRestartNeededEvent;
struct UpdateManualRestartNeededEventDefaultTypeInternal;
extern UpdateManualRestartNeededEventDefaultTypeInternal _UpdateManualRestartNeededEvent_default_instance_;
class UpdateSilentRestartNeeded;
struct UpdateSilentRestartNeededDefaultTypeInternal;
extern UpdateSilentRestartNeededDefaultTypeInternal _UpdateSilentRestartNeeded_default_instance_;
class UseSslForSmtpFinishedEvent;
struct UseSslForSmtpFinishedEventDefaultTypeInternal;
extern UseSslForSmtpFinishedEventDefaultTypeInternal _UseSslForSmtpFinishedEvent_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserChangedEvent;
struct UserChangedEventDefaultTypeInternal;
extern UserChangedEventDefaultTypeInternal _UserChangedEvent_default_instance_;
class UserDisconnectedEvent;
struct UserDisconnectedEventDefaultTypeInternal;
extern UserDisconnectedEventDefaultTypeInternal _UserDisconnectedEvent_default_instance_;
class UserEvent;
struct UserEventDefaultTypeInternal;
extern UserEventDefaultTypeInternal _UserEvent_default_instance_;
class UserListResponse;
struct UserListResponseDefaultTypeInternal;
extern UserListResponseDefaultTypeInternal _UserListResponse_default_instance_;
class UserSplitModeRequest;
struct UserSplitModeRequestDefaultTypeInternal;
extern UserSplitModeRequestDefaultTypeInternal _UserSplitModeRequest_default_instance_;
}  // namespace grpc
PROTOBUF_NAMESPACE_OPEN
template<> ::grpc::AddressChangedEvent* Arena::CreateMaybeMessage<::grpc::AddressChangedEvent>(Arena*);
template<> ::grpc::AddressChangedLogoutEvent* Arena::CreateMaybeMessage<::grpc::AddressChangedLogoutEvent>(Arena*);
template<> ::grpc::ApiCertIssueEvent* Arena::CreateMaybeMessage<::grpc::ApiCertIssueEvent>(Arena*);
template<> ::grpc::AppEvent* Arena::CreateMaybeMessage<::grpc::AppEvent>(Arena*);
template<> ::grpc::AvailableKeychainsResponse* Arena::CreateMaybeMessage<::grpc::AvailableKeychainsResponse>(Arena*);
template<> ::grpc::CacheErrorEvent* Arena::CreateMaybeMessage<::grpc::CacheErrorEvent>(Arena*);
template<> ::grpc::CacheEvent* Arena::CreateMaybeMessage<::grpc::CacheEvent>(Arena*);
template<> ::grpc::CacheLocationChangeSuccessEvent* Arena::CreateMaybeMessage<::grpc::CacheLocationChangeSuccessEvent>(Arena*);
template<> ::grpc::ChangeKeychainFinishedEvent* Arena::CreateMaybeMessage<::grpc::ChangeKeychainFinishedEvent>(Arena*);
template<> ::grpc::ChangeLocalCacheFinishedEvent* Arena::CreateMaybeMessage<::grpc::ChangeLocalCacheFinishedEvent>(Arena*);
template<> ::grpc::ChangeLocalCacheRequest* Arena::CreateMaybeMessage<::grpc::ChangeLocalCacheRequest>(Arena*);
template<> ::grpc::ChangePortsFinishedEvent* Arena::CreateMaybeMessage<::grpc::ChangePortsFinishedEvent>(Arena*);
template<> ::grpc::ChangePortsRequest* Arena::CreateMaybeMessage<::grpc::ChangePortsRequest>(Arena*);
template<> ::grpc::ConfigureAppleMailRequest* Arena::CreateMaybeMessage<::grpc::ConfigureAppleMailRequest>(Arena*);
template<> ::grpc::DiskCachePathChanged* Arena::CreateMaybeMessage<::grpc::DiskCachePathChanged>(Arena*);
template<> ::grpc::HasNoKeychainEvent* Arena::CreateMaybeMessage<::grpc::HasNoKeychainEvent>(Arena*);
template<> ::grpc::InternetStatusEvent* Arena::CreateMaybeMessage<::grpc::InternetStatusEvent>(Arena*);
template<> ::grpc::IsCacheOnDiskEnabledChanged* Arena::CreateMaybeMessage<::grpc::IsCacheOnDiskEnabledChanged>(Arena*);
template<> ::grpc::KeychainEvent* Arena::CreateMaybeMessage<::grpc::KeychainEvent>(Arena*);
template<> ::grpc::LoginAbortRequest* Arena::CreateMaybeMessage<::grpc::LoginAbortRequest>(Arena*);
template<> ::grpc::LoginErrorEvent* Arena::CreateMaybeMessage<::grpc::LoginErrorEvent>(Arena*);
template<> ::grpc::LoginEvent* Arena::CreateMaybeMessage<::grpc::LoginEvent>(Arena*);
template<> ::grpc::LoginFinishedEvent* Arena::CreateMaybeMessage<::grpc::LoginFinishedEvent>(Arena*);
template<> ::grpc::LoginRequest* Arena::CreateMaybeMessage<::grpc::LoginRequest>(Arena*);
template<> ::grpc::LoginTfaRequestedEvent* Arena::CreateMaybeMessage<::grpc::LoginTfaRequestedEvent>(Arena*);
template<> ::grpc::LoginTwoPasswordsRequestedEvent* Arena::CreateMaybeMessage<::grpc::LoginTwoPasswordsRequestedEvent>(Arena*);
template<> ::grpc::MailEvent* Arena::CreateMaybeMessage<::grpc::MailEvent>(Arena*);
template<> ::grpc::MailSettingsErrorEvent* Arena::CreateMaybeMessage<::grpc::MailSettingsErrorEvent>(Arena*);
template<> ::grpc::MailSettingsEvent* Arena::CreateMaybeMessage<::grpc::MailSettingsEvent>(Arena*);
template<> ::grpc::NoActiveKeyForRecipientEvent* Arena::CreateMaybeMessage<::grpc::NoActiveKeyForRecipientEvent>(Arena*);
template<> ::grpc::RebuildKeychainEvent* Arena::CreateMaybeMessage<::grpc::RebuildKeychainEvent>(Arena*);
template<> ::grpc::ReportBugErrorEvent* Arena::CreateMaybeMessage<::grpc::ReportBugErrorEvent>(Arena*);
template<> ::grpc::ReportBugFinishedEvent* Arena::CreateMaybeMessage<::grpc::ReportBugFinishedEvent>(Arena*);
template<> ::grpc::ReportBugRequest* Arena::CreateMaybeMessage<::grpc::ReportBugRequest>(Arena*);
template<> ::grpc::ReportBugSuccessEvent* Arena::CreateMaybeMessage<::grpc::ReportBugSuccessEvent>(Arena*);
template<> ::grpc::ResetFinishedEvent* Arena::CreateMaybeMessage<::grpc::ResetFinishedEvent>(Arena*);
template<> ::grpc::ShowMainWindowEvent* Arena::CreateMaybeMessage<::grpc::ShowMainWindowEvent>(Arena*);
template<> ::grpc::StreamEvent* Arena::CreateMaybeMessage<::grpc::StreamEvent>(Arena*);
template<> ::grpc::ToggleAutostartFinishedEvent* Arena::CreateMaybeMessage<::grpc::ToggleAutostartFinishedEvent>(Arena*);
template<> ::grpc::ToggleSplitModeFinishedEvent* Arena::CreateMaybeMessage<::grpc::ToggleSplitModeFinishedEvent>(Arena*);
template<> ::grpc::UpdateCheckFinished* Arena::CreateMaybeMessage<::grpc::UpdateCheckFinished>(Arena*);
template<> ::grpc::UpdateErrorEvent* Arena::CreateMaybeMessage<::grpc::UpdateErrorEvent>(Arena*);
template<> ::grpc::UpdateEvent* Arena::CreateMaybeMessage<::grpc::UpdateEvent>(Arena*);
template<> ::grpc::UpdateForceEvent* Arena::CreateMaybeMessage<::grpc::UpdateForceEvent>(Arena*);
template<> ::grpc::UpdateIsLatestVersion* Arena::CreateMaybeMessage<::grpc::UpdateIsLatestVersion>(Arena*);
template<> ::grpc::UpdateManualReadyEvent* Arena::CreateMaybeMessage<::grpc::UpdateManualReadyEvent>(Arena*);
template<> ::grpc::UpdateManualRestartNeededEvent* Arena::CreateMaybeMessage<::grpc::UpdateManualRestartNeededEvent>(Arena*);
template<> ::grpc::UpdateSilentRestartNeeded* Arena::CreateMaybeMessage<::grpc::UpdateSilentRestartNeeded>(Arena*);
template<> ::grpc::UseSslForSmtpFinishedEvent* Arena::CreateMaybeMessage<::grpc::UseSslForSmtpFinishedEvent>(Arena*);
template<> ::grpc::User* Arena::CreateMaybeMessage<::grpc::User>(Arena*);
template<> ::grpc::UserChangedEvent* Arena::CreateMaybeMessage<::grpc::UserChangedEvent>(Arena*);
template<> ::grpc::UserDisconnectedEvent* Arena::CreateMaybeMessage<::grpc::UserDisconnectedEvent>(Arena*);
template<> ::grpc::UserEvent* Arena::CreateMaybeMessage<::grpc::UserEvent>(Arena*);
template<> ::grpc::UserListResponse* Arena::CreateMaybeMessage<::grpc::UserListResponse>(Arena*);
template<> ::grpc::UserSplitModeRequest* Arena::CreateMaybeMessage<::grpc::UserSplitModeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace grpc {

enum LoginErrorType : int {
  USERNAME_PASSWORD_ERROR = 0,
  FREE_USER = 1,
  CONNECTION_ERROR = 2,
  TFA_ERROR = 3,
  TFA_ABORT = 4,
  TWO_PASSWORDS_ERROR = 5,
  TWO_PASSWORDS_ABORT = 6,
  LoginErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoginErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoginErrorType_IsValid(int value);
constexpr LoginErrorType LoginErrorType_MIN = USERNAME_PASSWORD_ERROR;
constexpr LoginErrorType LoginErrorType_MAX = TWO_PASSWORDS_ABORT;
constexpr int LoginErrorType_ARRAYSIZE = LoginErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoginErrorType_descriptor();
template<typename T>
inline const std::string& LoginErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoginErrorType_descriptor(), enum_t_value);
}
inline bool LoginErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoginErrorType>(
    LoginErrorType_descriptor(), name, value);
}
enum UpdateErrorType : int {
  UPDATE_MANUAL_ERROR = 0,
  UPDATE_FORCE_ERROR = 1,
  UPDATE_SILENT_ERROR = 2,
  UpdateErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateErrorType_IsValid(int value);
constexpr UpdateErrorType UpdateErrorType_MIN = UPDATE_MANUAL_ERROR;
constexpr UpdateErrorType UpdateErrorType_MAX = UPDATE_SILENT_ERROR;
constexpr int UpdateErrorType_ARRAYSIZE = UpdateErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateErrorType_descriptor();
template<typename T>
inline const std::string& UpdateErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateErrorType_descriptor(), enum_t_value);
}
inline bool UpdateErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateErrorType>(
    UpdateErrorType_descriptor(), name, value);
}
enum CacheErrorType : int {
  CACHE_UNAVAILABLE_ERROR = 0,
  CACHE_CANT_MOVE_ERROR = 1,
  DISK_FULL = 2,
  CacheErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CacheErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CacheErrorType_IsValid(int value);
constexpr CacheErrorType CacheErrorType_MIN = CACHE_UNAVAILABLE_ERROR;
constexpr CacheErrorType CacheErrorType_MAX = DISK_FULL;
constexpr int CacheErrorType_ARRAYSIZE = CacheErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CacheErrorType_descriptor();
template<typename T>
inline const std::string& CacheErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CacheErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CacheErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CacheErrorType_descriptor(), enum_t_value);
}
inline bool CacheErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CacheErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CacheErrorType>(
    CacheErrorType_descriptor(), name, value);
}
enum MailSettingsErrorType : int {
  IMAP_PORT_ISSUE = 0,
  SMTP_PORT_ISSUE = 1,
  MailSettingsErrorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MailSettingsErrorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MailSettingsErrorType_IsValid(int value);
constexpr MailSettingsErrorType MailSettingsErrorType_MIN = IMAP_PORT_ISSUE;
constexpr MailSettingsErrorType MailSettingsErrorType_MAX = SMTP_PORT_ISSUE;
constexpr int MailSettingsErrorType_ARRAYSIZE = MailSettingsErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MailSettingsErrorType_descriptor();
template<typename T>
inline const std::string& MailSettingsErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MailSettingsErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MailSettingsErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MailSettingsErrorType_descriptor(), enum_t_value);
}
inline bool MailSettingsErrorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MailSettingsErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MailSettingsErrorType>(
    MailSettingsErrorType_descriptor(), name, value);
}
// ===================================================================

class ReportBugRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ReportBugRequest) */ {
 public:
  inline ReportBugRequest() : ReportBugRequest(nullptr) {}
  ~ReportBugRequest() override;
  explicit constexpr ReportBugRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugRequest(const ReportBugRequest& from);
  ReportBugRequest(ReportBugRequest&& from) noexcept
    : ReportBugRequest() {
    *this = ::std::move(from);
  }

  inline ReportBugRequest& operator=(const ReportBugRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugRequest& operator=(ReportBugRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugRequest* internal_default_instance() {
    return reinterpret_cast<const ReportBugRequest*>(
               &_ReportBugRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReportBugRequest& a, ReportBugRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReportBugRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReportBugRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportBugRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugRequest";
  }
  protected:
  explicit ReportBugRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
    kAddressFieldNumber = 2,
    kEmailClientFieldNumber = 3,
    kIncludeLogsFieldNumber = 4,
  };
  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string emailClient = 3;
  void clear_emailclient();
  const std::string& emailclient() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_emailclient(ArgT0&& arg0, ArgT... args);
  std::string* mutable_emailclient();
  PROTOBUF_NODISCARD std::string* release_emailclient();
  void set_allocated_emailclient(std::string* emailclient);
  private:
  const std::string& _internal_emailclient() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emailclient(const std::string& value);
  std::string* _internal_mutable_emailclient();
  public:

  // bool includeLogs = 4;
  void clear_includelogs();
  bool includelogs() const;
  void set_includelogs(bool value);
  private:
  bool _internal_includelogs() const;
  void _internal_set_includelogs(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.ReportBugRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr emailclient_;
  bool includelogs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit constexpr LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginAbortRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginAbortRequest) */ {
 public:
  inline LoginAbortRequest() : LoginAbortRequest(nullptr) {}
  ~LoginAbortRequest() override;
  explicit constexpr LoginAbortRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginAbortRequest(const LoginAbortRequest& from);
  LoginAbortRequest(LoginAbortRequest&& from) noexcept
    : LoginAbortRequest() {
    *this = ::std::move(from);
  }

  inline LoginAbortRequest& operator=(const LoginAbortRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAbortRequest& operator=(LoginAbortRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginAbortRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginAbortRequest* internal_default_instance() {
    return reinterpret_cast<const LoginAbortRequest*>(
               &_LoginAbortRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LoginAbortRequest& a, LoginAbortRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAbortRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAbortRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginAbortRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginAbortRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginAbortRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginAbortRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginAbortRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginAbortRequest";
  }
  protected:
  explicit LoginAbortRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginAbortRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ChangeLocalCacheRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ChangeLocalCacheRequest) */ {
 public:
  inline ChangeLocalCacheRequest() : ChangeLocalCacheRequest(nullptr) {}
  ~ChangeLocalCacheRequest() override;
  explicit constexpr ChangeLocalCacheRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeLocalCacheRequest(const ChangeLocalCacheRequest& from);
  ChangeLocalCacheRequest(ChangeLocalCacheRequest&& from) noexcept
    : ChangeLocalCacheRequest() {
    *this = ::std::move(from);
  }

  inline ChangeLocalCacheRequest& operator=(const ChangeLocalCacheRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLocalCacheRequest& operator=(ChangeLocalCacheRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeLocalCacheRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeLocalCacheRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeLocalCacheRequest*>(
               &_ChangeLocalCacheRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ChangeLocalCacheRequest& a, ChangeLocalCacheRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLocalCacheRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeLocalCacheRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeLocalCacheRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeLocalCacheRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeLocalCacheRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeLocalCacheRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLocalCacheRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ChangeLocalCacheRequest";
  }
  protected:
  explicit ChangeLocalCacheRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiskCachePathFieldNumber = 2,
    kEnableDiskCacheFieldNumber = 1,
  };
  // string diskCachePath = 2;
  void clear_diskcachepath();
  const std::string& diskcachepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_diskcachepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_diskcachepath();
  PROTOBUF_NODISCARD std::string* release_diskcachepath();
  void set_allocated_diskcachepath(std::string* diskcachepath);
  private:
  const std::string& _internal_diskcachepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_diskcachepath(const std::string& value);
  std::string* _internal_mutable_diskcachepath();
  public:

  // bool enableDiskCache = 1;
  void clear_enablediskcache();
  bool enablediskcache() const;
  void set_enablediskcache(bool value);
  private:
  bool _internal_enablediskcache() const;
  void _internal_set_enablediskcache(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.ChangeLocalCacheRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr diskcachepath_;
  bool enablediskcache_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ChangePortsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ChangePortsRequest) */ {
 public:
  inline ChangePortsRequest() : ChangePortsRequest(nullptr) {}
  ~ChangePortsRequest() override;
  explicit constexpr ChangePortsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangePortsRequest(const ChangePortsRequest& from);
  ChangePortsRequest(ChangePortsRequest&& from) noexcept
    : ChangePortsRequest() {
    *this = ::std::move(from);
  }

  inline ChangePortsRequest& operator=(const ChangePortsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePortsRequest& operator=(ChangePortsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePortsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePortsRequest* internal_default_instance() {
    return reinterpret_cast<const ChangePortsRequest*>(
               &_ChangePortsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChangePortsRequest& a, ChangePortsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePortsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePortsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePortsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePortsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangePortsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangePortsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangePortsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ChangePortsRequest";
  }
  protected:
  explicit ChangePortsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImapPortFieldNumber = 1,
    kSmtpPortFieldNumber = 2,
  };
  // int32 imapPort = 1;
  void clear_imapport();
  int32_t imapport() const;
  void set_imapport(int32_t value);
  private:
  int32_t _internal_imapport() const;
  void _internal_set_imapport(int32_t value);
  public:

  // int32 smtpPort = 2;
  void clear_smtpport();
  int32_t smtpport() const;
  void set_smtpport(int32_t value);
  private:
  int32_t _internal_smtpport() const;
  void _internal_set_smtpport(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.ChangePortsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t imapport_;
  int32_t smtpport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AvailableKeychainsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AvailableKeychainsResponse) */ {
 public:
  inline AvailableKeychainsResponse() : AvailableKeychainsResponse(nullptr) {}
  ~AvailableKeychainsResponse() override;
  explicit constexpr AvailableKeychainsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvailableKeychainsResponse(const AvailableKeychainsResponse& from);
  AvailableKeychainsResponse(AvailableKeychainsResponse&& from) noexcept
    : AvailableKeychainsResponse() {
    *this = ::std::move(from);
  }

  inline AvailableKeychainsResponse& operator=(const AvailableKeychainsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvailableKeychainsResponse& operator=(AvailableKeychainsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvailableKeychainsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvailableKeychainsResponse* internal_default_instance() {
    return reinterpret_cast<const AvailableKeychainsResponse*>(
               &_AvailableKeychainsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AvailableKeychainsResponse& a, AvailableKeychainsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AvailableKeychainsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvailableKeychainsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvailableKeychainsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvailableKeychainsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvailableKeychainsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AvailableKeychainsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvailableKeychainsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AvailableKeychainsResponse";
  }
  protected:
  explicit AvailableKeychainsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeychainsFieldNumber = 1,
  };
  // repeated string keychains = 1;
  int keychains_size() const;
  private:
  int _internal_keychains_size() const;
  public:
  void clear_keychains();
  const std::string& keychains(int index) const;
  std::string* mutable_keychains(int index);
  void set_keychains(int index, const std::string& value);
  void set_keychains(int index, std::string&& value);
  void set_keychains(int index, const char* value);
  void set_keychains(int index, const char* value, size_t size);
  std::string* add_keychains();
  void add_keychains(const std::string& value);
  void add_keychains(std::string&& value);
  void add_keychains(const char* value);
  void add_keychains(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keychains() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keychains();
  private:
  const std::string& _internal_keychains(int index) const;
  std::string* _internal_add_keychains();
  public:

  // @@protoc_insertion_point(class_scope:grpc.AvailableKeychainsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keychains_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit constexpr User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressesFieldNumber = 10,
    kIdFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kAvatarTextFieldNumber = 3,
    kPasswordFieldNumber = 9,
    kUsedBytesFieldNumber = 7,
    kTotalBytesFieldNumber = 8,
    kLoggedInFieldNumber = 4,
    kSplitModeFieldNumber = 5,
    kSetupGuideSeenFieldNumber = 6,
  };
  // repeated string addresses = 10;
  int addresses_size() const;
  private:
  int _internal_addresses_size() const;
  public:
  void clear_addresses();
  const std::string& addresses(int index) const;
  std::string* mutable_addresses(int index);
  void set_addresses(int index, const std::string& value);
  void set_addresses(int index, std::string&& value);
  void set_addresses(int index, const char* value);
  void set_addresses(int index, const char* value, size_t size);
  std::string* add_addresses();
  void add_addresses(const std::string& value);
  void add_addresses(std::string&& value);
  void add_addresses(const char* value);
  void add_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresses();
  private:
  const std::string& _internal_addresses(int index) const;
  std::string* _internal_add_addresses();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string avatarText = 3;
  void clear_avatartext();
  const std::string& avatartext() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatartext(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatartext();
  PROTOBUF_NODISCARD std::string* release_avatartext();
  void set_allocated_avatartext(std::string* avatartext);
  private:
  const std::string& _internal_avatartext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatartext(const std::string& value);
  std::string* _internal_mutable_avatartext();
  public:

  // string password = 9;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // int64 usedBytes = 7;
  void clear_usedbytes();
  int64_t usedbytes() const;
  void set_usedbytes(int64_t value);
  private:
  int64_t _internal_usedbytes() const;
  void _internal_set_usedbytes(int64_t value);
  public:

  // int64 totalBytes = 8;
  void clear_totalbytes();
  int64_t totalbytes() const;
  void set_totalbytes(int64_t value);
  private:
  int64_t _internal_totalbytes() const;
  void _internal_set_totalbytes(int64_t value);
  public:

  // bool loggedIn = 4;
  void clear_loggedin();
  bool loggedin() const;
  void set_loggedin(bool value);
  private:
  bool _internal_loggedin() const;
  void _internal_set_loggedin(bool value);
  public:

  // bool splitMode = 5;
  void clear_splitmode();
  bool splitmode() const;
  void set_splitmode(bool value);
  private:
  bool _internal_splitmode() const;
  void _internal_set_splitmode(bool value);
  public:

  // bool setupGuideSeen = 6;
  void clear_setupguideseen();
  bool setupguideseen() const;
  void set_setupguideseen(bool value);
  private:
  bool _internal_setupguideseen() const;
  void _internal_set_setupguideseen(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatartext_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  int64_t usedbytes_;
  int64_t totalbytes_;
  bool loggedin_;
  bool splitmode_;
  bool setupguideseen_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserSplitModeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserSplitModeRequest) */ {
 public:
  inline UserSplitModeRequest() : UserSplitModeRequest(nullptr) {}
  ~UserSplitModeRequest() override;
  explicit constexpr UserSplitModeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserSplitModeRequest(const UserSplitModeRequest& from);
  UserSplitModeRequest(UserSplitModeRequest&& from) noexcept
    : UserSplitModeRequest() {
    *this = ::std::move(from);
  }

  inline UserSplitModeRequest& operator=(const UserSplitModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserSplitModeRequest& operator=(UserSplitModeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserSplitModeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserSplitModeRequest* internal_default_instance() {
    return reinterpret_cast<const UserSplitModeRequest*>(
               &_UserSplitModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UserSplitModeRequest& a, UserSplitModeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserSplitModeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserSplitModeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserSplitModeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserSplitModeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserSplitModeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserSplitModeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSplitModeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserSplitModeRequest";
  }
  protected:
  explicit UserSplitModeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kActiveFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // bool active = 2;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserSplitModeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  bool active_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserListResponse) */ {
 public:
  inline UserListResponse() : UserListResponse(nullptr) {}
  ~UserListResponse() override;
  explicit constexpr UserListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserListResponse(const UserListResponse& from);
  UserListResponse(UserListResponse&& from) noexcept
    : UserListResponse() {
    *this = ::std::move(from);
  }

  inline UserListResponse& operator=(const UserListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserListResponse& operator=(UserListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserListResponse* internal_default_instance() {
    return reinterpret_cast<const UserListResponse*>(
               &_UserListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UserListResponse& a, UserListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UserListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserListResponse";
  }
  protected:
  explicit UserListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .grpc.User users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::grpc::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >*
      mutable_users();
  private:
  const ::grpc::User& _internal_users(int index) const;
  ::grpc::User* _internal_add_users();
  public:
  const ::grpc::User& users(int index) const;
  ::grpc::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >&
      users() const;

  // @@protoc_insertion_point(class_scope:grpc.UserListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User > users_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ConfigureAppleMailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ConfigureAppleMailRequest) */ {
 public:
  inline ConfigureAppleMailRequest() : ConfigureAppleMailRequest(nullptr) {}
  ~ConfigureAppleMailRequest() override;
  explicit constexpr ConfigureAppleMailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigureAppleMailRequest(const ConfigureAppleMailRequest& from);
  ConfigureAppleMailRequest(ConfigureAppleMailRequest&& from) noexcept
    : ConfigureAppleMailRequest() {
    *this = ::std::move(from);
  }

  inline ConfigureAppleMailRequest& operator=(const ConfigureAppleMailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureAppleMailRequest& operator=(ConfigureAppleMailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigureAppleMailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureAppleMailRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigureAppleMailRequest*>(
               &_ConfigureAppleMailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConfigureAppleMailRequest& a, ConfigureAppleMailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureAppleMailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureAppleMailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigureAppleMailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigureAppleMailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigureAppleMailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigureAppleMailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigureAppleMailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ConfigureAppleMailRequest";
  }
  protected:
  explicit ConfigureAppleMailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kAddressFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:grpc.ConfigureAppleMailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class StreamEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.StreamEvent) */ {
 public:
  inline StreamEvent() : StreamEvent(nullptr) {}
  ~StreamEvent() override;
  explicit constexpr StreamEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamEvent(const StreamEvent& from);
  StreamEvent(StreamEvent&& from) noexcept
    : StreamEvent() {
    *this = ::std::move(from);
  }

  inline StreamEvent& operator=(const StreamEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamEvent& operator=(StreamEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kApp = 1,
    kLogin = 2,
    kUpdate = 3,
    kCache = 4,
    kMailSettings = 5,
    kKeychain = 6,
    kMail = 7,
    kUser = 8,
    EVENT_NOT_SET = 0,
  };

  static inline const StreamEvent* internal_default_instance() {
    return reinterpret_cast<const StreamEvent*>(
               &_StreamEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StreamEvent& a, StreamEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StreamEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.StreamEvent";
  }
  protected:
  explicit StreamEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
    kLoginFieldNumber = 2,
    kUpdateFieldNumber = 3,
    kCacheFieldNumber = 4,
    kMailSettingsFieldNumber = 5,
    kKeychainFieldNumber = 6,
    kMailFieldNumber = 7,
    kUserFieldNumber = 8,
  };
  // .grpc.AppEvent app = 1;
  bool has_app() const;
  private:
  bool _internal_has_app() const;
  public:
  void clear_app();
  const ::grpc::AppEvent& app() const;
  PROTOBUF_NODISCARD ::grpc::AppEvent* release_app();
  ::grpc::AppEvent* mutable_app();
  void set_allocated_app(::grpc::AppEvent* app);
  private:
  const ::grpc::AppEvent& _internal_app() const;
  ::grpc::AppEvent* _internal_mutable_app();
  public:
  void unsafe_arena_set_allocated_app(
      ::grpc::AppEvent* app);
  ::grpc::AppEvent* unsafe_arena_release_app();

  // .grpc.LoginEvent login = 2;
  bool has_login() const;
  private:
  bool _internal_has_login() const;
  public:
  void clear_login();
  const ::grpc::LoginEvent& login() const;
  PROTOBUF_NODISCARD ::grpc::LoginEvent* release_login();
  ::grpc::LoginEvent* mutable_login();
  void set_allocated_login(::grpc::LoginEvent* login);
  private:
  const ::grpc::LoginEvent& _internal_login() const;
  ::grpc::LoginEvent* _internal_mutable_login();
  public:
  void unsafe_arena_set_allocated_login(
      ::grpc::LoginEvent* login);
  ::grpc::LoginEvent* unsafe_arena_release_login();

  // .grpc.UpdateEvent update = 3;
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::grpc::UpdateEvent& update() const;
  PROTOBUF_NODISCARD ::grpc::UpdateEvent* release_update();
  ::grpc::UpdateEvent* mutable_update();
  void set_allocated_update(::grpc::UpdateEvent* update);
  private:
  const ::grpc::UpdateEvent& _internal_update() const;
  ::grpc::UpdateEvent* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::grpc::UpdateEvent* update);
  ::grpc::UpdateEvent* unsafe_arena_release_update();

  // .grpc.CacheEvent cache = 4;
  bool has_cache() const;
  private:
  bool _internal_has_cache() const;
  public:
  void clear_cache();
  const ::grpc::CacheEvent& cache() const;
  PROTOBUF_NODISCARD ::grpc::CacheEvent* release_cache();
  ::grpc::CacheEvent* mutable_cache();
  void set_allocated_cache(::grpc::CacheEvent* cache);
  private:
  const ::grpc::CacheEvent& _internal_cache() const;
  ::grpc::CacheEvent* _internal_mutable_cache();
  public:
  void unsafe_arena_set_allocated_cache(
      ::grpc::CacheEvent* cache);
  ::grpc::CacheEvent* unsafe_arena_release_cache();

  // .grpc.MailSettingsEvent mailSettings = 5;
  bool has_mailsettings() const;
  private:
  bool _internal_has_mailsettings() const;
  public:
  void clear_mailsettings();
  const ::grpc::MailSettingsEvent& mailsettings() const;
  PROTOBUF_NODISCARD ::grpc::MailSettingsEvent* release_mailsettings();
  ::grpc::MailSettingsEvent* mutable_mailsettings();
  void set_allocated_mailsettings(::grpc::MailSettingsEvent* mailsettings);
  private:
  const ::grpc::MailSettingsEvent& _internal_mailsettings() const;
  ::grpc::MailSettingsEvent* _internal_mutable_mailsettings();
  public:
  void unsafe_arena_set_allocated_mailsettings(
      ::grpc::MailSettingsEvent* mailsettings);
  ::grpc::MailSettingsEvent* unsafe_arena_release_mailsettings();

  // .grpc.KeychainEvent keychain = 6;
  bool has_keychain() const;
  private:
  bool _internal_has_keychain() const;
  public:
  void clear_keychain();
  const ::grpc::KeychainEvent& keychain() const;
  PROTOBUF_NODISCARD ::grpc::KeychainEvent* release_keychain();
  ::grpc::KeychainEvent* mutable_keychain();
  void set_allocated_keychain(::grpc::KeychainEvent* keychain);
  private:
  const ::grpc::KeychainEvent& _internal_keychain() const;
  ::grpc::KeychainEvent* _internal_mutable_keychain();
  public:
  void unsafe_arena_set_allocated_keychain(
      ::grpc::KeychainEvent* keychain);
  ::grpc::KeychainEvent* unsafe_arena_release_keychain();

  // .grpc.MailEvent mail = 7;
  bool has_mail() const;
  private:
  bool _internal_has_mail() const;
  public:
  void clear_mail();
  const ::grpc::MailEvent& mail() const;
  PROTOBUF_NODISCARD ::grpc::MailEvent* release_mail();
  ::grpc::MailEvent* mutable_mail();
  void set_allocated_mail(::grpc::MailEvent* mail);
  private:
  const ::grpc::MailEvent& _internal_mail() const;
  ::grpc::MailEvent* _internal_mutable_mail();
  public:
  void unsafe_arena_set_allocated_mail(
      ::grpc::MailEvent* mail);
  ::grpc::MailEvent* unsafe_arena_release_mail();

  // .grpc.UserEvent user = 8;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::grpc::UserEvent& user() const;
  PROTOBUF_NODISCARD ::grpc::UserEvent* release_user();
  ::grpc::UserEvent* mutable_user();
  void set_allocated_user(::grpc::UserEvent* user);
  private:
  const ::grpc::UserEvent& _internal_user() const;
  ::grpc::UserEvent* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::grpc::UserEvent* user);
  ::grpc::UserEvent* unsafe_arena_release_user();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.StreamEvent)
 private:
  class _Internal;
  void set_has_app();
  void set_has_login();
  void set_has_update();
  void set_has_cache();
  void set_has_mailsettings();
  void set_has_keychain();
  void set_has_mail();
  void set_has_user();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::AppEvent* app_;
    ::grpc::LoginEvent* login_;
    ::grpc::UpdateEvent* update_;
    ::grpc::CacheEvent* cache_;
    ::grpc::MailSettingsEvent* mailsettings_;
    ::grpc::KeychainEvent* keychain_;
    ::grpc::MailEvent* mail_;
    ::grpc::UserEvent* user_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AppEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AppEvent) */ {
 public:
  inline AppEvent() : AppEvent(nullptr) {}
  ~AppEvent() override;
  explicit constexpr AppEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppEvent(const AppEvent& from);
  AppEvent(AppEvent&& from) noexcept
    : AppEvent() {
    *this = ::std::move(from);
  }

  inline AppEvent& operator=(const AppEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppEvent& operator=(AppEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kInternetStatus = 1,
    kToggleAutostartFinished = 2,
    kResetFinished = 3,
    kReportBugFinished = 4,
    kReportBugSuccess = 5,
    kReportBugError = 6,
    kShowMainWindow = 7,
    EVENT_NOT_SET = 0,
  };

  static inline const AppEvent* internal_default_instance() {
    return reinterpret_cast<const AppEvent*>(
               &_AppEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AppEvent& a, AppEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AppEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AppEvent";
  }
  protected:
  explicit AppEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInternetStatusFieldNumber = 1,
    kToggleAutostartFinishedFieldNumber = 2,
    kResetFinishedFieldNumber = 3,
    kReportBugFinishedFieldNumber = 4,
    kReportBugSuccessFieldNumber = 5,
    kReportBugErrorFieldNumber = 6,
    kShowMainWindowFieldNumber = 7,
  };
  // .grpc.InternetStatusEvent internetStatus = 1;
  bool has_internetstatus() const;
  private:
  bool _internal_has_internetstatus() const;
  public:
  void clear_internetstatus();
  const ::grpc::InternetStatusEvent& internetstatus() const;
  PROTOBUF_NODISCARD ::grpc::InternetStatusEvent* release_internetstatus();
  ::grpc::InternetStatusEvent* mutable_internetstatus();
  void set_allocated_internetstatus(::grpc::InternetStatusEvent* internetstatus);
  private:
  const ::grpc::InternetStatusEvent& _internal_internetstatus() const;
  ::grpc::InternetStatusEvent* _internal_mutable_internetstatus();
  public:
  void unsafe_arena_set_allocated_internetstatus(
      ::grpc::InternetStatusEvent* internetstatus);
  ::grpc::InternetStatusEvent* unsafe_arena_release_internetstatus();

  // .grpc.ToggleAutostartFinishedEvent toggleAutostartFinished = 2;
  bool has_toggleautostartfinished() const;
  private:
  bool _internal_has_toggleautostartfinished() const;
  public:
  void clear_toggleautostartfinished();
  const ::grpc::ToggleAutostartFinishedEvent& toggleautostartfinished() const;
  PROTOBUF_NODISCARD ::grpc::ToggleAutostartFinishedEvent* release_toggleautostartfinished();
  ::grpc::ToggleAutostartFinishedEvent* mutable_toggleautostartfinished();
  void set_allocated_toggleautostartfinished(::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished);
  private:
  const ::grpc::ToggleAutostartFinishedEvent& _internal_toggleautostartfinished() const;
  ::grpc::ToggleAutostartFinishedEvent* _internal_mutable_toggleautostartfinished();
  public:
  void unsafe_arena_set_allocated_toggleautostartfinished(
      ::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished);
  ::grpc::ToggleAutostartFinishedEvent* unsafe_arena_release_toggleautostartfinished();

  // .grpc.ResetFinishedEvent resetFinished = 3;
  bool has_resetfinished() const;
  private:
  bool _internal_has_resetfinished() const;
  public:
  void clear_resetfinished();
  const ::grpc::ResetFinishedEvent& resetfinished() const;
  PROTOBUF_NODISCARD ::grpc::ResetFinishedEvent* release_resetfinished();
  ::grpc::ResetFinishedEvent* mutable_resetfinished();
  void set_allocated_resetfinished(::grpc::ResetFinishedEvent* resetfinished);
  private:
  const ::grpc::ResetFinishedEvent& _internal_resetfinished() const;
  ::grpc::ResetFinishedEvent* _internal_mutable_resetfinished();
  public:
  void unsafe_arena_set_allocated_resetfinished(
      ::grpc::ResetFinishedEvent* resetfinished);
  ::grpc::ResetFinishedEvent* unsafe_arena_release_resetfinished();

  // .grpc.ReportBugFinishedEvent reportBugFinished = 4;
  bool has_reportbugfinished() const;
  private:
  bool _internal_has_reportbugfinished() const;
  public:
  void clear_reportbugfinished();
  const ::grpc::ReportBugFinishedEvent& reportbugfinished() const;
  PROTOBUF_NODISCARD ::grpc::ReportBugFinishedEvent* release_reportbugfinished();
  ::grpc::ReportBugFinishedEvent* mutable_reportbugfinished();
  void set_allocated_reportbugfinished(::grpc::ReportBugFinishedEvent* reportbugfinished);
  private:
  const ::grpc::ReportBugFinishedEvent& _internal_reportbugfinished() const;
  ::grpc::ReportBugFinishedEvent* _internal_mutable_reportbugfinished();
  public:
  void unsafe_arena_set_allocated_reportbugfinished(
      ::grpc::ReportBugFinishedEvent* reportbugfinished);
  ::grpc::ReportBugFinishedEvent* unsafe_arena_release_reportbugfinished();

  // .grpc.ReportBugSuccessEvent reportBugSuccess = 5;
  bool has_reportbugsuccess() const;
  private:
  bool _internal_has_reportbugsuccess() const;
  public:
  void clear_reportbugsuccess();
  const ::grpc::ReportBugSuccessEvent& reportbugsuccess() const;
  PROTOBUF_NODISCARD ::grpc::ReportBugSuccessEvent* release_reportbugsuccess();
  ::grpc::ReportBugSuccessEvent* mutable_reportbugsuccess();
  void set_allocated_reportbugsuccess(::grpc::ReportBugSuccessEvent* reportbugsuccess);
  private:
  const ::grpc::ReportBugSuccessEvent& _internal_reportbugsuccess() const;
  ::grpc::ReportBugSuccessEvent* _internal_mutable_reportbugsuccess();
  public:
  void unsafe_arena_set_allocated_reportbugsuccess(
      ::grpc::ReportBugSuccessEvent* reportbugsuccess);
  ::grpc::ReportBugSuccessEvent* unsafe_arena_release_reportbugsuccess();

  // .grpc.ReportBugErrorEvent reportBugError = 6;
  bool has_reportbugerror() const;
  private:
  bool _internal_has_reportbugerror() const;
  public:
  void clear_reportbugerror();
  const ::grpc::ReportBugErrorEvent& reportbugerror() const;
  PROTOBUF_NODISCARD ::grpc::ReportBugErrorEvent* release_reportbugerror();
  ::grpc::ReportBugErrorEvent* mutable_reportbugerror();
  void set_allocated_reportbugerror(::grpc::ReportBugErrorEvent* reportbugerror);
  private:
  const ::grpc::ReportBugErrorEvent& _internal_reportbugerror() const;
  ::grpc::ReportBugErrorEvent* _internal_mutable_reportbugerror();
  public:
  void unsafe_arena_set_allocated_reportbugerror(
      ::grpc::ReportBugErrorEvent* reportbugerror);
  ::grpc::ReportBugErrorEvent* unsafe_arena_release_reportbugerror();

  // .grpc.ShowMainWindowEvent showMainWindow = 7;
  bool has_showmainwindow() const;
  private:
  bool _internal_has_showmainwindow() const;
  public:
  void clear_showmainwindow();
  const ::grpc::ShowMainWindowEvent& showmainwindow() const;
  PROTOBUF_NODISCARD ::grpc::ShowMainWindowEvent* release_showmainwindow();
  ::grpc::ShowMainWindowEvent* mutable_showmainwindow();
  void set_allocated_showmainwindow(::grpc::ShowMainWindowEvent* showmainwindow);
  private:
  const ::grpc::ShowMainWindowEvent& _internal_showmainwindow() const;
  ::grpc::ShowMainWindowEvent* _internal_mutable_showmainwindow();
  public:
  void unsafe_arena_set_allocated_showmainwindow(
      ::grpc::ShowMainWindowEvent* showmainwindow);
  ::grpc::ShowMainWindowEvent* unsafe_arena_release_showmainwindow();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.AppEvent)
 private:
  class _Internal;
  void set_has_internetstatus();
  void set_has_toggleautostartfinished();
  void set_has_resetfinished();
  void set_has_reportbugfinished();
  void set_has_reportbugsuccess();
  void set_has_reportbugerror();
  void set_has_showmainwindow();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::InternetStatusEvent* internetstatus_;
    ::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished_;
    ::grpc::ResetFinishedEvent* resetfinished_;
    ::grpc::ReportBugFinishedEvent* reportbugfinished_;
    ::grpc::ReportBugSuccessEvent* reportbugsuccess_;
    ::grpc::ReportBugErrorEvent* reportbugerror_;
    ::grpc::ShowMainWindowEvent* showmainwindow_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class InternetStatusEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.InternetStatusEvent) */ {
 public:
  inline InternetStatusEvent() : InternetStatusEvent(nullptr) {}
  ~InternetStatusEvent() override;
  explicit constexpr InternetStatusEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InternetStatusEvent(const InternetStatusEvent& from);
  InternetStatusEvent(InternetStatusEvent&& from) noexcept
    : InternetStatusEvent() {
    *this = ::std::move(from);
  }

  inline InternetStatusEvent& operator=(const InternetStatusEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InternetStatusEvent& operator=(InternetStatusEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InternetStatusEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const InternetStatusEvent* internal_default_instance() {
    return reinterpret_cast<const InternetStatusEvent*>(
               &_InternetStatusEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InternetStatusEvent& a, InternetStatusEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(InternetStatusEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InternetStatusEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InternetStatusEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InternetStatusEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InternetStatusEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InternetStatusEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InternetStatusEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.InternetStatusEvent";
  }
  protected:
  explicit InternetStatusEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectedFieldNumber = 1,
  };
  // bool connected = 1;
  void clear_connected();
  bool connected() const;
  void set_connected(bool value);
  private:
  bool _internal_connected() const;
  void _internal_set_connected(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.InternetStatusEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool connected_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ToggleAutostartFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ToggleAutostartFinishedEvent) */ {
 public:
  inline ToggleAutostartFinishedEvent() : ToggleAutostartFinishedEvent(nullptr) {}
  explicit constexpr ToggleAutostartFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleAutostartFinishedEvent(const ToggleAutostartFinishedEvent& from);
  ToggleAutostartFinishedEvent(ToggleAutostartFinishedEvent&& from) noexcept
    : ToggleAutostartFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ToggleAutostartFinishedEvent& operator=(const ToggleAutostartFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleAutostartFinishedEvent& operator=(ToggleAutostartFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToggleAutostartFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleAutostartFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ToggleAutostartFinishedEvent*>(
               &_ToggleAutostartFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ToggleAutostartFinishedEvent& a, ToggleAutostartFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ToggleAutostartFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleAutostartFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleAutostartFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleAutostartFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ToggleAutostartFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ToggleAutostartFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ToggleAutostartFinishedEvent";
  }
  protected:
  explicit ToggleAutostartFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ToggleAutostartFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ResetFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ResetFinishedEvent) */ {
 public:
  inline ResetFinishedEvent() : ResetFinishedEvent(nullptr) {}
  explicit constexpr ResetFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetFinishedEvent(const ResetFinishedEvent& from);
  ResetFinishedEvent(ResetFinishedEvent&& from) noexcept
    : ResetFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ResetFinishedEvent& operator=(const ResetFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetFinishedEvent& operator=(ResetFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ResetFinishedEvent*>(
               &_ResetFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ResetFinishedEvent& a, ResetFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ResetFinishedEvent";
  }
  protected:
  explicit ResetFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ResetFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ReportBugFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ReportBugFinishedEvent) */ {
 public:
  inline ReportBugFinishedEvent() : ReportBugFinishedEvent(nullptr) {}
  explicit constexpr ReportBugFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugFinishedEvent(const ReportBugFinishedEvent& from);
  ReportBugFinishedEvent(ReportBugFinishedEvent&& from) noexcept
    : ReportBugFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ReportBugFinishedEvent& operator=(const ReportBugFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugFinishedEvent& operator=(ReportBugFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ReportBugFinishedEvent*>(
               &_ReportBugFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReportBugFinishedEvent& a, ReportBugFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportBugFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportBugFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugFinishedEvent";
  }
  protected:
  explicit ReportBugFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ReportBugFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ReportBugSuccessEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ReportBugSuccessEvent) */ {
 public:
  inline ReportBugSuccessEvent() : ReportBugSuccessEvent(nullptr) {}
  explicit constexpr ReportBugSuccessEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugSuccessEvent(const ReportBugSuccessEvent& from);
  ReportBugSuccessEvent(ReportBugSuccessEvent&& from) noexcept
    : ReportBugSuccessEvent() {
    *this = ::std::move(from);
  }

  inline ReportBugSuccessEvent& operator=(const ReportBugSuccessEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugSuccessEvent& operator=(ReportBugSuccessEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugSuccessEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugSuccessEvent* internal_default_instance() {
    return reinterpret_cast<const ReportBugSuccessEvent*>(
               &_ReportBugSuccessEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ReportBugSuccessEvent& a, ReportBugSuccessEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugSuccessEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugSuccessEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugSuccessEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugSuccessEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportBugSuccessEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportBugSuccessEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugSuccessEvent";
  }
  protected:
  explicit ReportBugSuccessEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ReportBugSuccessEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ReportBugErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ReportBugErrorEvent) */ {
 public:
  inline ReportBugErrorEvent() : ReportBugErrorEvent(nullptr) {}
  explicit constexpr ReportBugErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportBugErrorEvent(const ReportBugErrorEvent& from);
  ReportBugErrorEvent(ReportBugErrorEvent&& from) noexcept
    : ReportBugErrorEvent() {
    *this = ::std::move(from);
  }

  inline ReportBugErrorEvent& operator=(const ReportBugErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBugErrorEvent& operator=(ReportBugErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBugErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBugErrorEvent* internal_default_instance() {
    return reinterpret_cast<const ReportBugErrorEvent*>(
               &_ReportBugErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ReportBugErrorEvent& a, ReportBugErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportBugErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBugErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBugErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportBugErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportBugErrorEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportBugErrorEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ReportBugErrorEvent";
  }
  protected:
  explicit ReportBugErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ReportBugErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ShowMainWindowEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ShowMainWindowEvent) */ {
 public:
  inline ShowMainWindowEvent() : ShowMainWindowEvent(nullptr) {}
  explicit constexpr ShowMainWindowEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowMainWindowEvent(const ShowMainWindowEvent& from);
  ShowMainWindowEvent(ShowMainWindowEvent&& from) noexcept
    : ShowMainWindowEvent() {
    *this = ::std::move(from);
  }

  inline ShowMainWindowEvent& operator=(const ShowMainWindowEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowMainWindowEvent& operator=(ShowMainWindowEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowMainWindowEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowMainWindowEvent* internal_default_instance() {
    return reinterpret_cast<const ShowMainWindowEvent*>(
               &_ShowMainWindowEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ShowMainWindowEvent& a, ShowMainWindowEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowMainWindowEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowMainWindowEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShowMainWindowEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShowMainWindowEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ShowMainWindowEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ShowMainWindowEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ShowMainWindowEvent";
  }
  protected:
  explicit ShowMainWindowEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ShowMainWindowEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginEvent) */ {
 public:
  inline LoginEvent() : LoginEvent(nullptr) {}
  ~LoginEvent() override;
  explicit constexpr LoginEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginEvent(const LoginEvent& from);
  LoginEvent(LoginEvent&& from) noexcept
    : LoginEvent() {
    *this = ::std::move(from);
  }

  inline LoginEvent& operator=(const LoginEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginEvent& operator=(LoginEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kTfaRequested = 2,
    kTwoPasswordRequested = 3,
    kFinished = 4,
    kAlreadyLoggedIn = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const LoginEvent* internal_default_instance() {
    return reinterpret_cast<const LoginEvent*>(
               &_LoginEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LoginEvent& a, LoginEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginEvent";
  }
  protected:
  explicit LoginEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kTfaRequestedFieldNumber = 2,
    kTwoPasswordRequestedFieldNumber = 3,
    kFinishedFieldNumber = 4,
    kAlreadyLoggedInFieldNumber = 5,
  };
  // .grpc.LoginErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::LoginErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::LoginErrorEvent* release_error();
  ::grpc::LoginErrorEvent* mutable_error();
  void set_allocated_error(::grpc::LoginErrorEvent* error);
  private:
  const ::grpc::LoginErrorEvent& _internal_error() const;
  ::grpc::LoginErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::LoginErrorEvent* error);
  ::grpc::LoginErrorEvent* unsafe_arena_release_error();

  // .grpc.LoginTfaRequestedEvent tfaRequested = 2;
  bool has_tfarequested() const;
  private:
  bool _internal_has_tfarequested() const;
  public:
  void clear_tfarequested();
  const ::grpc::LoginTfaRequestedEvent& tfarequested() const;
  PROTOBUF_NODISCARD ::grpc::LoginTfaRequestedEvent* release_tfarequested();
  ::grpc::LoginTfaRequestedEvent* mutable_tfarequested();
  void set_allocated_tfarequested(::grpc::LoginTfaRequestedEvent* tfarequested);
  private:
  const ::grpc::LoginTfaRequestedEvent& _internal_tfarequested() const;
  ::grpc::LoginTfaRequestedEvent* _internal_mutable_tfarequested();
  public:
  void unsafe_arena_set_allocated_tfarequested(
      ::grpc::LoginTfaRequestedEvent* tfarequested);
  ::grpc::LoginTfaRequestedEvent* unsafe_arena_release_tfarequested();

  // .grpc.LoginTwoPasswordsRequestedEvent twoPasswordRequested = 3;
  bool has_twopasswordrequested() const;
  private:
  bool _internal_has_twopasswordrequested() const;
  public:
  void clear_twopasswordrequested();
  const ::grpc::LoginTwoPasswordsRequestedEvent& twopasswordrequested() const;
  PROTOBUF_NODISCARD ::grpc::LoginTwoPasswordsRequestedEvent* release_twopasswordrequested();
  ::grpc::LoginTwoPasswordsRequestedEvent* mutable_twopasswordrequested();
  void set_allocated_twopasswordrequested(::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested);
  private:
  const ::grpc::LoginTwoPasswordsRequestedEvent& _internal_twopasswordrequested() const;
  ::grpc::LoginTwoPasswordsRequestedEvent* _internal_mutable_twopasswordrequested();
  public:
  void unsafe_arena_set_allocated_twopasswordrequested(
      ::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested);
  ::grpc::LoginTwoPasswordsRequestedEvent* unsafe_arena_release_twopasswordrequested();

  // .grpc.LoginFinishedEvent finished = 4;
  bool has_finished() const;
  private:
  bool _internal_has_finished() const;
  public:
  void clear_finished();
  const ::grpc::LoginFinishedEvent& finished() const;
  PROTOBUF_NODISCARD ::grpc::LoginFinishedEvent* release_finished();
  ::grpc::LoginFinishedEvent* mutable_finished();
  void set_allocated_finished(::grpc::LoginFinishedEvent* finished);
  private:
  const ::grpc::LoginFinishedEvent& _internal_finished() const;
  ::grpc::LoginFinishedEvent* _internal_mutable_finished();
  public:
  void unsafe_arena_set_allocated_finished(
      ::grpc::LoginFinishedEvent* finished);
  ::grpc::LoginFinishedEvent* unsafe_arena_release_finished();

  // .grpc.LoginFinishedEvent alreadyLoggedIn = 5;
  bool has_alreadyloggedin() const;
  private:
  bool _internal_has_alreadyloggedin() const;
  public:
  void clear_alreadyloggedin();
  const ::grpc::LoginFinishedEvent& alreadyloggedin() const;
  PROTOBUF_NODISCARD ::grpc::LoginFinishedEvent* release_alreadyloggedin();
  ::grpc::LoginFinishedEvent* mutable_alreadyloggedin();
  void set_allocated_alreadyloggedin(::grpc::LoginFinishedEvent* alreadyloggedin);
  private:
  const ::grpc::LoginFinishedEvent& _internal_alreadyloggedin() const;
  ::grpc::LoginFinishedEvent* _internal_mutable_alreadyloggedin();
  public:
  void unsafe_arena_set_allocated_alreadyloggedin(
      ::grpc::LoginFinishedEvent* alreadyloggedin);
  ::grpc::LoginFinishedEvent* unsafe_arena_release_alreadyloggedin();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.LoginEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_tfarequested();
  void set_has_twopasswordrequested();
  void set_has_finished();
  void set_has_alreadyloggedin();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::LoginErrorEvent* error_;
    ::grpc::LoginTfaRequestedEvent* tfarequested_;
    ::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested_;
    ::grpc::LoginFinishedEvent* finished_;
    ::grpc::LoginFinishedEvent* alreadyloggedin_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginErrorEvent) */ {
 public:
  inline LoginErrorEvent() : LoginErrorEvent(nullptr) {}
  ~LoginErrorEvent() override;
  explicit constexpr LoginErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginErrorEvent(const LoginErrorEvent& from);
  LoginErrorEvent(LoginErrorEvent&& from) noexcept
    : LoginErrorEvent() {
    *this = ::std::move(from);
  }

  inline LoginErrorEvent& operator=(const LoginErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginErrorEvent& operator=(LoginErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginErrorEvent* internal_default_instance() {
    return reinterpret_cast<const LoginErrorEvent*>(
               &_LoginErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(LoginErrorEvent& a, LoginErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginErrorEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginErrorEvent";
  }
  protected:
  explicit LoginErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .grpc.LoginErrorType type = 1;
  void clear_type();
  ::grpc::LoginErrorType type() const;
  void set_type(::grpc::LoginErrorType value);
  private:
  ::grpc::LoginErrorType _internal_type() const;
  void _internal_set_type(::grpc::LoginErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginTfaRequestedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginTfaRequestedEvent) */ {
 public:
  inline LoginTfaRequestedEvent() : LoginTfaRequestedEvent(nullptr) {}
  ~LoginTfaRequestedEvent() override;
  explicit constexpr LoginTfaRequestedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginTfaRequestedEvent(const LoginTfaRequestedEvent& from);
  LoginTfaRequestedEvent(LoginTfaRequestedEvent&& from) noexcept
    : LoginTfaRequestedEvent() {
    *this = ::std::move(from);
  }

  inline LoginTfaRequestedEvent& operator=(const LoginTfaRequestedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginTfaRequestedEvent& operator=(LoginTfaRequestedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginTfaRequestedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginTfaRequestedEvent* internal_default_instance() {
    return reinterpret_cast<const LoginTfaRequestedEvent*>(
               &_LoginTfaRequestedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LoginTfaRequestedEvent& a, LoginTfaRequestedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginTfaRequestedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginTfaRequestedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginTfaRequestedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginTfaRequestedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginTfaRequestedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginTfaRequestedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginTfaRequestedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginTfaRequestedEvent";
  }
  protected:
  explicit LoginTfaRequestedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginTfaRequestedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginTwoPasswordsRequestedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.LoginTwoPasswordsRequestedEvent) */ {
 public:
  inline LoginTwoPasswordsRequestedEvent() : LoginTwoPasswordsRequestedEvent(nullptr) {}
  explicit constexpr LoginTwoPasswordsRequestedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginTwoPasswordsRequestedEvent(const LoginTwoPasswordsRequestedEvent& from);
  LoginTwoPasswordsRequestedEvent(LoginTwoPasswordsRequestedEvent&& from) noexcept
    : LoginTwoPasswordsRequestedEvent() {
    *this = ::std::move(from);
  }

  inline LoginTwoPasswordsRequestedEvent& operator=(const LoginTwoPasswordsRequestedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginTwoPasswordsRequestedEvent& operator=(LoginTwoPasswordsRequestedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginTwoPasswordsRequestedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginTwoPasswordsRequestedEvent* internal_default_instance() {
    return reinterpret_cast<const LoginTwoPasswordsRequestedEvent*>(
               &_LoginTwoPasswordsRequestedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LoginTwoPasswordsRequestedEvent& a, LoginTwoPasswordsRequestedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginTwoPasswordsRequestedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginTwoPasswordsRequestedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginTwoPasswordsRequestedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginTwoPasswordsRequestedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LoginTwoPasswordsRequestedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LoginTwoPasswordsRequestedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginTwoPasswordsRequestedEvent";
  }
  protected:
  explicit LoginTwoPasswordsRequestedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.LoginTwoPasswordsRequestedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class LoginFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.LoginFinishedEvent) */ {
 public:
  inline LoginFinishedEvent() : LoginFinishedEvent(nullptr) {}
  ~LoginFinishedEvent() override;
  explicit constexpr LoginFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginFinishedEvent(const LoginFinishedEvent& from);
  LoginFinishedEvent(LoginFinishedEvent&& from) noexcept
    : LoginFinishedEvent() {
    *this = ::std::move(from);
  }

  inline LoginFinishedEvent& operator=(const LoginFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginFinishedEvent& operator=(LoginFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const LoginFinishedEvent*>(
               &_LoginFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LoginFinishedEvent& a, LoginFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginFinishedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginFinishedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginFinishedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.LoginFinishedEvent";
  }
  protected:
  explicit LoginFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:grpc.LoginFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateEvent) */ {
 public:
  inline UpdateEvent() : UpdateEvent(nullptr) {}
  ~UpdateEvent() override;
  explicit constexpr UpdateEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateEvent(const UpdateEvent& from);
  UpdateEvent(UpdateEvent&& from) noexcept
    : UpdateEvent() {
    *this = ::std::move(from);
  }

  inline UpdateEvent& operator=(const UpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateEvent& operator=(UpdateEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kManualReady = 2,
    kManualRestartNeeded = 3,
    kForce = 4,
    kSilentRestartNeeded = 5,
    kIsLatestVersion = 6,
    kCheckFinished = 7,
    EVENT_NOT_SET = 0,
  };

  static inline const UpdateEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateEvent*>(
               &_UpdateEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UpdateEvent& a, UpdateEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateEvent";
  }
  protected:
  explicit UpdateEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kManualReadyFieldNumber = 2,
    kManualRestartNeededFieldNumber = 3,
    kForceFieldNumber = 4,
    kSilentRestartNeededFieldNumber = 5,
    kIsLatestVersionFieldNumber = 6,
    kCheckFinishedFieldNumber = 7,
  };
  // .grpc.UpdateErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::UpdateErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::UpdateErrorEvent* release_error();
  ::grpc::UpdateErrorEvent* mutable_error();
  void set_allocated_error(::grpc::UpdateErrorEvent* error);
  private:
  const ::grpc::UpdateErrorEvent& _internal_error() const;
  ::grpc::UpdateErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::UpdateErrorEvent* error);
  ::grpc::UpdateErrorEvent* unsafe_arena_release_error();

  // .grpc.UpdateManualReadyEvent manualReady = 2;
  bool has_manualready() const;
  private:
  bool _internal_has_manualready() const;
  public:
  void clear_manualready();
  const ::grpc::UpdateManualReadyEvent& manualready() const;
  PROTOBUF_NODISCARD ::grpc::UpdateManualReadyEvent* release_manualready();
  ::grpc::UpdateManualReadyEvent* mutable_manualready();
  void set_allocated_manualready(::grpc::UpdateManualReadyEvent* manualready);
  private:
  const ::grpc::UpdateManualReadyEvent& _internal_manualready() const;
  ::grpc::UpdateManualReadyEvent* _internal_mutable_manualready();
  public:
  void unsafe_arena_set_allocated_manualready(
      ::grpc::UpdateManualReadyEvent* manualready);
  ::grpc::UpdateManualReadyEvent* unsafe_arena_release_manualready();

  // .grpc.UpdateManualRestartNeededEvent manualRestartNeeded = 3;
  bool has_manualrestartneeded() const;
  private:
  bool _internal_has_manualrestartneeded() const;
  public:
  void clear_manualrestartneeded();
  const ::grpc::UpdateManualRestartNeededEvent& manualrestartneeded() const;
  PROTOBUF_NODISCARD ::grpc::UpdateManualRestartNeededEvent* release_manualrestartneeded();
  ::grpc::UpdateManualRestartNeededEvent* mutable_manualrestartneeded();
  void set_allocated_manualrestartneeded(::grpc::UpdateManualRestartNeededEvent* manualrestartneeded);
  private:
  const ::grpc::UpdateManualRestartNeededEvent& _internal_manualrestartneeded() const;
  ::grpc::UpdateManualRestartNeededEvent* _internal_mutable_manualrestartneeded();
  public:
  void unsafe_arena_set_allocated_manualrestartneeded(
      ::grpc::UpdateManualRestartNeededEvent* manualrestartneeded);
  ::grpc::UpdateManualRestartNeededEvent* unsafe_arena_release_manualrestartneeded();

  // .grpc.UpdateForceEvent force = 4;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  const ::grpc::UpdateForceEvent& force() const;
  PROTOBUF_NODISCARD ::grpc::UpdateForceEvent* release_force();
  ::grpc::UpdateForceEvent* mutable_force();
  void set_allocated_force(::grpc::UpdateForceEvent* force);
  private:
  const ::grpc::UpdateForceEvent& _internal_force() const;
  ::grpc::UpdateForceEvent* _internal_mutable_force();
  public:
  void unsafe_arena_set_allocated_force(
      ::grpc::UpdateForceEvent* force);
  ::grpc::UpdateForceEvent* unsafe_arena_release_force();

  // .grpc.UpdateSilentRestartNeeded silentRestartNeeded = 5;
  bool has_silentrestartneeded() const;
  private:
  bool _internal_has_silentrestartneeded() const;
  public:
  void clear_silentrestartneeded();
  const ::grpc::UpdateSilentRestartNeeded& silentrestartneeded() const;
  PROTOBUF_NODISCARD ::grpc::UpdateSilentRestartNeeded* release_silentrestartneeded();
  ::grpc::UpdateSilentRestartNeeded* mutable_silentrestartneeded();
  void set_allocated_silentrestartneeded(::grpc::UpdateSilentRestartNeeded* silentrestartneeded);
  private:
  const ::grpc::UpdateSilentRestartNeeded& _internal_silentrestartneeded() const;
  ::grpc::UpdateSilentRestartNeeded* _internal_mutable_silentrestartneeded();
  public:
  void unsafe_arena_set_allocated_silentrestartneeded(
      ::grpc::UpdateSilentRestartNeeded* silentrestartneeded);
  ::grpc::UpdateSilentRestartNeeded* unsafe_arena_release_silentrestartneeded();

  // .grpc.UpdateIsLatestVersion isLatestVersion = 6;
  bool has_islatestversion() const;
  private:
  bool _internal_has_islatestversion() const;
  public:
  void clear_islatestversion();
  const ::grpc::UpdateIsLatestVersion& islatestversion() const;
  PROTOBUF_NODISCARD ::grpc::UpdateIsLatestVersion* release_islatestversion();
  ::grpc::UpdateIsLatestVersion* mutable_islatestversion();
  void set_allocated_islatestversion(::grpc::UpdateIsLatestVersion* islatestversion);
  private:
  const ::grpc::UpdateIsLatestVersion& _internal_islatestversion() const;
  ::grpc::UpdateIsLatestVersion* _internal_mutable_islatestversion();
  public:
  void unsafe_arena_set_allocated_islatestversion(
      ::grpc::UpdateIsLatestVersion* islatestversion);
  ::grpc::UpdateIsLatestVersion* unsafe_arena_release_islatestversion();

  // .grpc.UpdateCheckFinished checkFinished = 7;
  bool has_checkfinished() const;
  private:
  bool _internal_has_checkfinished() const;
  public:
  void clear_checkfinished();
  const ::grpc::UpdateCheckFinished& checkfinished() const;
  PROTOBUF_NODISCARD ::grpc::UpdateCheckFinished* release_checkfinished();
  ::grpc::UpdateCheckFinished* mutable_checkfinished();
  void set_allocated_checkfinished(::grpc::UpdateCheckFinished* checkfinished);
  private:
  const ::grpc::UpdateCheckFinished& _internal_checkfinished() const;
  ::grpc::UpdateCheckFinished* _internal_mutable_checkfinished();
  public:
  void unsafe_arena_set_allocated_checkfinished(
      ::grpc::UpdateCheckFinished* checkfinished);
  ::grpc::UpdateCheckFinished* unsafe_arena_release_checkfinished();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.UpdateEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_manualready();
  void set_has_manualrestartneeded();
  void set_has_force();
  void set_has_silentrestartneeded();
  void set_has_islatestversion();
  void set_has_checkfinished();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::UpdateErrorEvent* error_;
    ::grpc::UpdateManualReadyEvent* manualready_;
    ::grpc::UpdateManualRestartNeededEvent* manualrestartneeded_;
    ::grpc::UpdateForceEvent* force_;
    ::grpc::UpdateSilentRestartNeeded* silentrestartneeded_;
    ::grpc::UpdateIsLatestVersion* islatestversion_;
    ::grpc::UpdateCheckFinished* checkfinished_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateErrorEvent) */ {
 public:
  inline UpdateErrorEvent() : UpdateErrorEvent(nullptr) {}
  ~UpdateErrorEvent() override;
  explicit constexpr UpdateErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateErrorEvent(const UpdateErrorEvent& from);
  UpdateErrorEvent(UpdateErrorEvent&& from) noexcept
    : UpdateErrorEvent() {
    *this = ::std::move(from);
  }

  inline UpdateErrorEvent& operator=(const UpdateErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateErrorEvent& operator=(UpdateErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateErrorEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateErrorEvent*>(
               &_UpdateErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UpdateErrorEvent& a, UpdateErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateErrorEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateErrorEvent";
  }
  protected:
  explicit UpdateErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .grpc.UpdateErrorType type = 1;
  void clear_type();
  ::grpc::UpdateErrorType type() const;
  void set_type(::grpc::UpdateErrorType value);
  private:
  ::grpc::UpdateErrorType _internal_type() const;
  void _internal_set_type(::grpc::UpdateErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.UpdateErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateManualReadyEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateManualReadyEvent) */ {
 public:
  inline UpdateManualReadyEvent() : UpdateManualReadyEvent(nullptr) {}
  ~UpdateManualReadyEvent() override;
  explicit constexpr UpdateManualReadyEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateManualReadyEvent(const UpdateManualReadyEvent& from);
  UpdateManualReadyEvent(UpdateManualReadyEvent&& from) noexcept
    : UpdateManualReadyEvent() {
    *this = ::std::move(from);
  }

  inline UpdateManualReadyEvent& operator=(const UpdateManualReadyEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateManualReadyEvent& operator=(UpdateManualReadyEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateManualReadyEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateManualReadyEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateManualReadyEvent*>(
               &_UpdateManualReadyEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UpdateManualReadyEvent& a, UpdateManualReadyEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateManualReadyEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateManualReadyEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateManualReadyEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateManualReadyEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateManualReadyEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateManualReadyEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateManualReadyEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateManualReadyEvent";
  }
  protected:
  explicit UpdateManualReadyEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UpdateManualReadyEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateManualRestartNeededEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateManualRestartNeededEvent) */ {
 public:
  inline UpdateManualRestartNeededEvent() : UpdateManualRestartNeededEvent(nullptr) {}
  explicit constexpr UpdateManualRestartNeededEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateManualRestartNeededEvent(const UpdateManualRestartNeededEvent& from);
  UpdateManualRestartNeededEvent(UpdateManualRestartNeededEvent&& from) noexcept
    : UpdateManualRestartNeededEvent() {
    *this = ::std::move(from);
  }

  inline UpdateManualRestartNeededEvent& operator=(const UpdateManualRestartNeededEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateManualRestartNeededEvent& operator=(UpdateManualRestartNeededEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateManualRestartNeededEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateManualRestartNeededEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateManualRestartNeededEvent*>(
               &_UpdateManualRestartNeededEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UpdateManualRestartNeededEvent& a, UpdateManualRestartNeededEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateManualRestartNeededEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateManualRestartNeededEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateManualRestartNeededEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateManualRestartNeededEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateManualRestartNeededEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateManualRestartNeededEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateManualRestartNeededEvent";
  }
  protected:
  explicit UpdateManualRestartNeededEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateManualRestartNeededEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateForceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UpdateForceEvent) */ {
 public:
  inline UpdateForceEvent() : UpdateForceEvent(nullptr) {}
  ~UpdateForceEvent() override;
  explicit constexpr UpdateForceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateForceEvent(const UpdateForceEvent& from);
  UpdateForceEvent(UpdateForceEvent&& from) noexcept
    : UpdateForceEvent() {
    *this = ::std::move(from);
  }

  inline UpdateForceEvent& operator=(const UpdateForceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateForceEvent& operator=(UpdateForceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateForceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateForceEvent* internal_default_instance() {
    return reinterpret_cast<const UpdateForceEvent*>(
               &_UpdateForceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UpdateForceEvent& a, UpdateForceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateForceEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateForceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateForceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateForceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateForceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateForceEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateForceEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateForceEvent";
  }
  protected:
  explicit UpdateForceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UpdateForceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateSilentRestartNeeded final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateSilentRestartNeeded) */ {
 public:
  inline UpdateSilentRestartNeeded() : UpdateSilentRestartNeeded(nullptr) {}
  explicit constexpr UpdateSilentRestartNeeded(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSilentRestartNeeded(const UpdateSilentRestartNeeded& from);
  UpdateSilentRestartNeeded(UpdateSilentRestartNeeded&& from) noexcept
    : UpdateSilentRestartNeeded() {
    *this = ::std::move(from);
  }

  inline UpdateSilentRestartNeeded& operator=(const UpdateSilentRestartNeeded& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSilentRestartNeeded& operator=(UpdateSilentRestartNeeded&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSilentRestartNeeded& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSilentRestartNeeded* internal_default_instance() {
    return reinterpret_cast<const UpdateSilentRestartNeeded*>(
               &_UpdateSilentRestartNeeded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateSilentRestartNeeded& a, UpdateSilentRestartNeeded& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSilentRestartNeeded* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSilentRestartNeeded* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSilentRestartNeeded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSilentRestartNeeded>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateSilentRestartNeeded& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateSilentRestartNeeded& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateSilentRestartNeeded";
  }
  protected:
  explicit UpdateSilentRestartNeeded(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateSilentRestartNeeded)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateIsLatestVersion final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateIsLatestVersion) */ {
 public:
  inline UpdateIsLatestVersion() : UpdateIsLatestVersion(nullptr) {}
  explicit constexpr UpdateIsLatestVersion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateIsLatestVersion(const UpdateIsLatestVersion& from);
  UpdateIsLatestVersion(UpdateIsLatestVersion&& from) noexcept
    : UpdateIsLatestVersion() {
    *this = ::std::move(from);
  }

  inline UpdateIsLatestVersion& operator=(const UpdateIsLatestVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateIsLatestVersion& operator=(UpdateIsLatestVersion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateIsLatestVersion& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateIsLatestVersion* internal_default_instance() {
    return reinterpret_cast<const UpdateIsLatestVersion*>(
               &_UpdateIsLatestVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UpdateIsLatestVersion& a, UpdateIsLatestVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateIsLatestVersion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateIsLatestVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateIsLatestVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateIsLatestVersion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateIsLatestVersion& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateIsLatestVersion& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateIsLatestVersion";
  }
  protected:
  explicit UpdateIsLatestVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateIsLatestVersion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UpdateCheckFinished final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UpdateCheckFinished) */ {
 public:
  inline UpdateCheckFinished() : UpdateCheckFinished(nullptr) {}
  explicit constexpr UpdateCheckFinished(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateCheckFinished(const UpdateCheckFinished& from);
  UpdateCheckFinished(UpdateCheckFinished&& from) noexcept
    : UpdateCheckFinished() {
    *this = ::std::move(from);
  }

  inline UpdateCheckFinished& operator=(const UpdateCheckFinished& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCheckFinished& operator=(UpdateCheckFinished&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCheckFinished& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCheckFinished* internal_default_instance() {
    return reinterpret_cast<const UpdateCheckFinished*>(
               &_UpdateCheckFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdateCheckFinished& a, UpdateCheckFinished& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateCheckFinished* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCheckFinished* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCheckFinished* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateCheckFinished>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateCheckFinished& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateCheckFinished& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UpdateCheckFinished";
  }
  protected:
  explicit UpdateCheckFinished(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UpdateCheckFinished)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class CacheEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.CacheEvent) */ {
 public:
  inline CacheEvent() : CacheEvent(nullptr) {}
  ~CacheEvent() override;
  explicit constexpr CacheEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheEvent(const CacheEvent& from);
  CacheEvent(CacheEvent&& from) noexcept
    : CacheEvent() {
    *this = ::std::move(from);
  }

  inline CacheEvent& operator=(const CacheEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheEvent& operator=(CacheEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kLocationChangedSuccess = 2,
    kChangeLocalCacheFinished = 3,
    kIsCacheOnDiskEnabledChanged = 4,
    kDiskCachePathChanged = 5,
    EVENT_NOT_SET = 0,
  };

  static inline const CacheEvent* internal_default_instance() {
    return reinterpret_cast<const CacheEvent*>(
               &_CacheEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CacheEvent& a, CacheEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CacheEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.CacheEvent";
  }
  protected:
  explicit CacheEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kLocationChangedSuccessFieldNumber = 2,
    kChangeLocalCacheFinishedFieldNumber = 3,
    kIsCacheOnDiskEnabledChangedFieldNumber = 4,
    kDiskCachePathChangedFieldNumber = 5,
  };
  // .grpc.CacheErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::CacheErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::CacheErrorEvent* release_error();
  ::grpc::CacheErrorEvent* mutable_error();
  void set_allocated_error(::grpc::CacheErrorEvent* error);
  private:
  const ::grpc::CacheErrorEvent& _internal_error() const;
  ::grpc::CacheErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::CacheErrorEvent* error);
  ::grpc::CacheErrorEvent* unsafe_arena_release_error();

  // .grpc.CacheLocationChangeSuccessEvent locationChangedSuccess = 2;
  bool has_locationchangedsuccess() const;
  private:
  bool _internal_has_locationchangedsuccess() const;
  public:
  void clear_locationchangedsuccess();
  const ::grpc::CacheLocationChangeSuccessEvent& locationchangedsuccess() const;
  PROTOBUF_NODISCARD ::grpc::CacheLocationChangeSuccessEvent* release_locationchangedsuccess();
  ::grpc::CacheLocationChangeSuccessEvent* mutable_locationchangedsuccess();
  void set_allocated_locationchangedsuccess(::grpc::CacheLocationChangeSuccessEvent* locationchangedsuccess);
  private:
  const ::grpc::CacheLocationChangeSuccessEvent& _internal_locationchangedsuccess() const;
  ::grpc::CacheLocationChangeSuccessEvent* _internal_mutable_locationchangedsuccess();
  public:
  void unsafe_arena_set_allocated_locationchangedsuccess(
      ::grpc::CacheLocationChangeSuccessEvent* locationchangedsuccess);
  ::grpc::CacheLocationChangeSuccessEvent* unsafe_arena_release_locationchangedsuccess();

  // .grpc.ChangeLocalCacheFinishedEvent changeLocalCacheFinished = 3;
  bool has_changelocalcachefinished() const;
  private:
  bool _internal_has_changelocalcachefinished() const;
  public:
  void clear_changelocalcachefinished();
  const ::grpc::ChangeLocalCacheFinishedEvent& changelocalcachefinished() const;
  PROTOBUF_NODISCARD ::grpc::ChangeLocalCacheFinishedEvent* release_changelocalcachefinished();
  ::grpc::ChangeLocalCacheFinishedEvent* mutable_changelocalcachefinished();
  void set_allocated_changelocalcachefinished(::grpc::ChangeLocalCacheFinishedEvent* changelocalcachefinished);
  private:
  const ::grpc::ChangeLocalCacheFinishedEvent& _internal_changelocalcachefinished() const;
  ::grpc::ChangeLocalCacheFinishedEvent* _internal_mutable_changelocalcachefinished();
  public:
  void unsafe_arena_set_allocated_changelocalcachefinished(
      ::grpc::ChangeLocalCacheFinishedEvent* changelocalcachefinished);
  ::grpc::ChangeLocalCacheFinishedEvent* unsafe_arena_release_changelocalcachefinished();

  // .grpc.IsCacheOnDiskEnabledChanged isCacheOnDiskEnabledChanged = 4;
  bool has_iscacheondiskenabledchanged() const;
  private:
  bool _internal_has_iscacheondiskenabledchanged() const;
  public:
  void clear_iscacheondiskenabledchanged();
  const ::grpc::IsCacheOnDiskEnabledChanged& iscacheondiskenabledchanged() const;
  PROTOBUF_NODISCARD ::grpc::IsCacheOnDiskEnabledChanged* release_iscacheondiskenabledchanged();
  ::grpc::IsCacheOnDiskEnabledChanged* mutable_iscacheondiskenabledchanged();
  void set_allocated_iscacheondiskenabledchanged(::grpc::IsCacheOnDiskEnabledChanged* iscacheondiskenabledchanged);
  private:
  const ::grpc::IsCacheOnDiskEnabledChanged& _internal_iscacheondiskenabledchanged() const;
  ::grpc::IsCacheOnDiskEnabledChanged* _internal_mutable_iscacheondiskenabledchanged();
  public:
  void unsafe_arena_set_allocated_iscacheondiskenabledchanged(
      ::grpc::IsCacheOnDiskEnabledChanged* iscacheondiskenabledchanged);
  ::grpc::IsCacheOnDiskEnabledChanged* unsafe_arena_release_iscacheondiskenabledchanged();

  // .grpc.DiskCachePathChanged diskCachePathChanged = 5;
  bool has_diskcachepathchanged() const;
  private:
  bool _internal_has_diskcachepathchanged() const;
  public:
  void clear_diskcachepathchanged();
  const ::grpc::DiskCachePathChanged& diskcachepathchanged() const;
  PROTOBUF_NODISCARD ::grpc::DiskCachePathChanged* release_diskcachepathchanged();
  ::grpc::DiskCachePathChanged* mutable_diskcachepathchanged();
  void set_allocated_diskcachepathchanged(::grpc::DiskCachePathChanged* diskcachepathchanged);
  private:
  const ::grpc::DiskCachePathChanged& _internal_diskcachepathchanged() const;
  ::grpc::DiskCachePathChanged* _internal_mutable_diskcachepathchanged();
  public:
  void unsafe_arena_set_allocated_diskcachepathchanged(
      ::grpc::DiskCachePathChanged* diskcachepathchanged);
  ::grpc::DiskCachePathChanged* unsafe_arena_release_diskcachepathchanged();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.CacheEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_locationchangedsuccess();
  void set_has_changelocalcachefinished();
  void set_has_iscacheondiskenabledchanged();
  void set_has_diskcachepathchanged();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::CacheErrorEvent* error_;
    ::grpc::CacheLocationChangeSuccessEvent* locationchangedsuccess_;
    ::grpc::ChangeLocalCacheFinishedEvent* changelocalcachefinished_;
    ::grpc::IsCacheOnDiskEnabledChanged* iscacheondiskenabledchanged_;
    ::grpc::DiskCachePathChanged* diskcachepathchanged_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class CacheErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.CacheErrorEvent) */ {
 public:
  inline CacheErrorEvent() : CacheErrorEvent(nullptr) {}
  ~CacheErrorEvent() override;
  explicit constexpr CacheErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheErrorEvent(const CacheErrorEvent& from);
  CacheErrorEvent(CacheErrorEvent&& from) noexcept
    : CacheErrorEvent() {
    *this = ::std::move(from);
  }

  inline CacheErrorEvent& operator=(const CacheErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheErrorEvent& operator=(CacheErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheErrorEvent* internal_default_instance() {
    return reinterpret_cast<const CacheErrorEvent*>(
               &_CacheErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CacheErrorEvent& a, CacheErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CacheErrorEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.CacheErrorEvent";
  }
  protected:
  explicit CacheErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .grpc.CacheErrorType type = 1;
  void clear_type();
  ::grpc::CacheErrorType type() const;
  void set_type(::grpc::CacheErrorType value);
  private:
  ::grpc::CacheErrorType _internal_type() const;
  void _internal_set_type(::grpc::CacheErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.CacheErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class CacheLocationChangeSuccessEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.CacheLocationChangeSuccessEvent) */ {
 public:
  inline CacheLocationChangeSuccessEvent() : CacheLocationChangeSuccessEvent(nullptr) {}
  explicit constexpr CacheLocationChangeSuccessEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheLocationChangeSuccessEvent(const CacheLocationChangeSuccessEvent& from);
  CacheLocationChangeSuccessEvent(CacheLocationChangeSuccessEvent&& from) noexcept
    : CacheLocationChangeSuccessEvent() {
    *this = ::std::move(from);
  }

  inline CacheLocationChangeSuccessEvent& operator=(const CacheLocationChangeSuccessEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheLocationChangeSuccessEvent& operator=(CacheLocationChangeSuccessEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheLocationChangeSuccessEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheLocationChangeSuccessEvent* internal_default_instance() {
    return reinterpret_cast<const CacheLocationChangeSuccessEvent*>(
               &_CacheLocationChangeSuccessEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CacheLocationChangeSuccessEvent& a, CacheLocationChangeSuccessEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheLocationChangeSuccessEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheLocationChangeSuccessEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheLocationChangeSuccessEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheLocationChangeSuccessEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CacheLocationChangeSuccessEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CacheLocationChangeSuccessEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.CacheLocationChangeSuccessEvent";
  }
  protected:
  explicit CacheLocationChangeSuccessEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.CacheLocationChangeSuccessEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ChangeLocalCacheFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ChangeLocalCacheFinishedEvent) */ {
 public:
  inline ChangeLocalCacheFinishedEvent() : ChangeLocalCacheFinishedEvent(nullptr) {}
  explicit constexpr ChangeLocalCacheFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeLocalCacheFinishedEvent(const ChangeLocalCacheFinishedEvent& from);
  ChangeLocalCacheFinishedEvent(ChangeLocalCacheFinishedEvent&& from) noexcept
    : ChangeLocalCacheFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ChangeLocalCacheFinishedEvent& operator=(const ChangeLocalCacheFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLocalCacheFinishedEvent& operator=(ChangeLocalCacheFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeLocalCacheFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeLocalCacheFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ChangeLocalCacheFinishedEvent*>(
               &_ChangeLocalCacheFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ChangeLocalCacheFinishedEvent& a, ChangeLocalCacheFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLocalCacheFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeLocalCacheFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeLocalCacheFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeLocalCacheFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChangeLocalCacheFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChangeLocalCacheFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ChangeLocalCacheFinishedEvent";
  }
  protected:
  explicit ChangeLocalCacheFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ChangeLocalCacheFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class IsCacheOnDiskEnabledChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.IsCacheOnDiskEnabledChanged) */ {
 public:
  inline IsCacheOnDiskEnabledChanged() : IsCacheOnDiskEnabledChanged(nullptr) {}
  ~IsCacheOnDiskEnabledChanged() override;
  explicit constexpr IsCacheOnDiskEnabledChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsCacheOnDiskEnabledChanged(const IsCacheOnDiskEnabledChanged& from);
  IsCacheOnDiskEnabledChanged(IsCacheOnDiskEnabledChanged&& from) noexcept
    : IsCacheOnDiskEnabledChanged() {
    *this = ::std::move(from);
  }

  inline IsCacheOnDiskEnabledChanged& operator=(const IsCacheOnDiskEnabledChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsCacheOnDiskEnabledChanged& operator=(IsCacheOnDiskEnabledChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsCacheOnDiskEnabledChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsCacheOnDiskEnabledChanged* internal_default_instance() {
    return reinterpret_cast<const IsCacheOnDiskEnabledChanged*>(
               &_IsCacheOnDiskEnabledChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(IsCacheOnDiskEnabledChanged& a, IsCacheOnDiskEnabledChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(IsCacheOnDiskEnabledChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsCacheOnDiskEnabledChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsCacheOnDiskEnabledChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsCacheOnDiskEnabledChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsCacheOnDiskEnabledChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IsCacheOnDiskEnabledChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsCacheOnDiskEnabledChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.IsCacheOnDiskEnabledChanged";
  }
  protected:
  explicit IsCacheOnDiskEnabledChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // bool enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.IsCacheOnDiskEnabledChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class DiskCachePathChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.DiskCachePathChanged) */ {
 public:
  inline DiskCachePathChanged() : DiskCachePathChanged(nullptr) {}
  ~DiskCachePathChanged() override;
  explicit constexpr DiskCachePathChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskCachePathChanged(const DiskCachePathChanged& from);
  DiskCachePathChanged(DiskCachePathChanged&& from) noexcept
    : DiskCachePathChanged() {
    *this = ::std::move(from);
  }

  inline DiskCachePathChanged& operator=(const DiskCachePathChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskCachePathChanged& operator=(DiskCachePathChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskCachePathChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskCachePathChanged* internal_default_instance() {
    return reinterpret_cast<const DiskCachePathChanged*>(
               &_DiskCachePathChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DiskCachePathChanged& a, DiskCachePathChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskCachePathChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskCachePathChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskCachePathChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskCachePathChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskCachePathChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DiskCachePathChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskCachePathChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.DiskCachePathChanged";
  }
  protected:
  explicit DiskCachePathChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:grpc.DiskCachePathChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class MailSettingsEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.MailSettingsEvent) */ {
 public:
  inline MailSettingsEvent() : MailSettingsEvent(nullptr) {}
  ~MailSettingsEvent() override;
  explicit constexpr MailSettingsEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailSettingsEvent(const MailSettingsEvent& from);
  MailSettingsEvent(MailSettingsEvent&& from) noexcept
    : MailSettingsEvent() {
    *this = ::std::move(from);
  }

  inline MailSettingsEvent& operator=(const MailSettingsEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailSettingsEvent& operator=(MailSettingsEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailSettingsEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kError = 1,
    kUseSslForSmtpFinished = 2,
    kChangePortsFinished = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const MailSettingsEvent* internal_default_instance() {
    return reinterpret_cast<const MailSettingsEvent*>(
               &_MailSettingsEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(MailSettingsEvent& a, MailSettingsEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MailSettingsEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailSettingsEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailSettingsEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailSettingsEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailSettingsEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MailSettingsEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailSettingsEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.MailSettingsEvent";
  }
  protected:
  explicit MailSettingsEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
    kUseSslForSmtpFinishedFieldNumber = 2,
    kChangePortsFinishedFieldNumber = 3,
  };
  // .grpc.MailSettingsErrorEvent error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::grpc::MailSettingsErrorEvent& error() const;
  PROTOBUF_NODISCARD ::grpc::MailSettingsErrorEvent* release_error();
  ::grpc::MailSettingsErrorEvent* mutable_error();
  void set_allocated_error(::grpc::MailSettingsErrorEvent* error);
  private:
  const ::grpc::MailSettingsErrorEvent& _internal_error() const;
  ::grpc::MailSettingsErrorEvent* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::grpc::MailSettingsErrorEvent* error);
  ::grpc::MailSettingsErrorEvent* unsafe_arena_release_error();

  // .grpc.UseSslForSmtpFinishedEvent useSslForSmtpFinished = 2;
  bool has_usesslforsmtpfinished() const;
  private:
  bool _internal_has_usesslforsmtpfinished() const;
  public:
  void clear_usesslforsmtpfinished();
  const ::grpc::UseSslForSmtpFinishedEvent& usesslforsmtpfinished() const;
  PROTOBUF_NODISCARD ::grpc::UseSslForSmtpFinishedEvent* release_usesslforsmtpfinished();
  ::grpc::UseSslForSmtpFinishedEvent* mutable_usesslforsmtpfinished();
  void set_allocated_usesslforsmtpfinished(::grpc::UseSslForSmtpFinishedEvent* usesslforsmtpfinished);
  private:
  const ::grpc::UseSslForSmtpFinishedEvent& _internal_usesslforsmtpfinished() const;
  ::grpc::UseSslForSmtpFinishedEvent* _internal_mutable_usesslforsmtpfinished();
  public:
  void unsafe_arena_set_allocated_usesslforsmtpfinished(
      ::grpc::UseSslForSmtpFinishedEvent* usesslforsmtpfinished);
  ::grpc::UseSslForSmtpFinishedEvent* unsafe_arena_release_usesslforsmtpfinished();

  // .grpc.ChangePortsFinishedEvent changePortsFinished = 3;
  bool has_changeportsfinished() const;
  private:
  bool _internal_has_changeportsfinished() const;
  public:
  void clear_changeportsfinished();
  const ::grpc::ChangePortsFinishedEvent& changeportsfinished() const;
  PROTOBUF_NODISCARD ::grpc::ChangePortsFinishedEvent* release_changeportsfinished();
  ::grpc::ChangePortsFinishedEvent* mutable_changeportsfinished();
  void set_allocated_changeportsfinished(::grpc::ChangePortsFinishedEvent* changeportsfinished);
  private:
  const ::grpc::ChangePortsFinishedEvent& _internal_changeportsfinished() const;
  ::grpc::ChangePortsFinishedEvent* _internal_mutable_changeportsfinished();
  public:
  void unsafe_arena_set_allocated_changeportsfinished(
      ::grpc::ChangePortsFinishedEvent* changeportsfinished);
  ::grpc::ChangePortsFinishedEvent* unsafe_arena_release_changeportsfinished();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.MailSettingsEvent)
 private:
  class _Internal;
  void set_has_error();
  void set_has_usesslforsmtpfinished();
  void set_has_changeportsfinished();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::MailSettingsErrorEvent* error_;
    ::grpc::UseSslForSmtpFinishedEvent* usesslforsmtpfinished_;
    ::grpc::ChangePortsFinishedEvent* changeportsfinished_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class MailSettingsErrorEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.MailSettingsErrorEvent) */ {
 public:
  inline MailSettingsErrorEvent() : MailSettingsErrorEvent(nullptr) {}
  ~MailSettingsErrorEvent() override;
  explicit constexpr MailSettingsErrorEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailSettingsErrorEvent(const MailSettingsErrorEvent& from);
  MailSettingsErrorEvent(MailSettingsErrorEvent&& from) noexcept
    : MailSettingsErrorEvent() {
    *this = ::std::move(from);
  }

  inline MailSettingsErrorEvent& operator=(const MailSettingsErrorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailSettingsErrorEvent& operator=(MailSettingsErrorEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailSettingsErrorEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailSettingsErrorEvent* internal_default_instance() {
    return reinterpret_cast<const MailSettingsErrorEvent*>(
               &_MailSettingsErrorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(MailSettingsErrorEvent& a, MailSettingsErrorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MailSettingsErrorEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailSettingsErrorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailSettingsErrorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailSettingsErrorEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailSettingsErrorEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MailSettingsErrorEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailSettingsErrorEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.MailSettingsErrorEvent";
  }
  protected:
  explicit MailSettingsErrorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .grpc.MailSettingsErrorType type = 1;
  void clear_type();
  ::grpc::MailSettingsErrorType type() const;
  void set_type(::grpc::MailSettingsErrorType value);
  private:
  ::grpc::MailSettingsErrorType _internal_type() const;
  void _internal_set_type(::grpc::MailSettingsErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:grpc.MailSettingsErrorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UseSslForSmtpFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.UseSslForSmtpFinishedEvent) */ {
 public:
  inline UseSslForSmtpFinishedEvent() : UseSslForSmtpFinishedEvent(nullptr) {}
  explicit constexpr UseSslForSmtpFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseSslForSmtpFinishedEvent(const UseSslForSmtpFinishedEvent& from);
  UseSslForSmtpFinishedEvent(UseSslForSmtpFinishedEvent&& from) noexcept
    : UseSslForSmtpFinishedEvent() {
    *this = ::std::move(from);
  }

  inline UseSslForSmtpFinishedEvent& operator=(const UseSslForSmtpFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseSslForSmtpFinishedEvent& operator=(UseSslForSmtpFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseSslForSmtpFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseSslForSmtpFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const UseSslForSmtpFinishedEvent*>(
               &_UseSslForSmtpFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(UseSslForSmtpFinishedEvent& a, UseSslForSmtpFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UseSslForSmtpFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseSslForSmtpFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseSslForSmtpFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UseSslForSmtpFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UseSslForSmtpFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UseSslForSmtpFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UseSslForSmtpFinishedEvent";
  }
  protected:
  explicit UseSslForSmtpFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.UseSslForSmtpFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ChangePortsFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ChangePortsFinishedEvent) */ {
 public:
  inline ChangePortsFinishedEvent() : ChangePortsFinishedEvent(nullptr) {}
  explicit constexpr ChangePortsFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangePortsFinishedEvent(const ChangePortsFinishedEvent& from);
  ChangePortsFinishedEvent(ChangePortsFinishedEvent&& from) noexcept
    : ChangePortsFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ChangePortsFinishedEvent& operator=(const ChangePortsFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePortsFinishedEvent& operator=(ChangePortsFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePortsFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePortsFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ChangePortsFinishedEvent*>(
               &_ChangePortsFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ChangePortsFinishedEvent& a, ChangePortsFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePortsFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePortsFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePortsFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePortsFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChangePortsFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChangePortsFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ChangePortsFinishedEvent";
  }
  protected:
  explicit ChangePortsFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ChangePortsFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class KeychainEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.KeychainEvent) */ {
 public:
  inline KeychainEvent() : KeychainEvent(nullptr) {}
  ~KeychainEvent() override;
  explicit constexpr KeychainEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeychainEvent(const KeychainEvent& from);
  KeychainEvent(KeychainEvent&& from) noexcept
    : KeychainEvent() {
    *this = ::std::move(from);
  }

  inline KeychainEvent& operator=(const KeychainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeychainEvent& operator=(KeychainEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeychainEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kChangeKeychainFinished = 1,
    kHasNoKeychain = 2,
    kRebuildKeychain = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const KeychainEvent* internal_default_instance() {
    return reinterpret_cast<const KeychainEvent*>(
               &_KeychainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(KeychainEvent& a, KeychainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeychainEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeychainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeychainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeychainEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeychainEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeychainEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeychainEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.KeychainEvent";
  }
  protected:
  explicit KeychainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeKeychainFinishedFieldNumber = 1,
    kHasNoKeychainFieldNumber = 2,
    kRebuildKeychainFieldNumber = 3,
  };
  // .grpc.ChangeKeychainFinishedEvent changeKeychainFinished = 1;
  bool has_changekeychainfinished() const;
  private:
  bool _internal_has_changekeychainfinished() const;
  public:
  void clear_changekeychainfinished();
  const ::grpc::ChangeKeychainFinishedEvent& changekeychainfinished() const;
  PROTOBUF_NODISCARD ::grpc::ChangeKeychainFinishedEvent* release_changekeychainfinished();
  ::grpc::ChangeKeychainFinishedEvent* mutable_changekeychainfinished();
  void set_allocated_changekeychainfinished(::grpc::ChangeKeychainFinishedEvent* changekeychainfinished);
  private:
  const ::grpc::ChangeKeychainFinishedEvent& _internal_changekeychainfinished() const;
  ::grpc::ChangeKeychainFinishedEvent* _internal_mutable_changekeychainfinished();
  public:
  void unsafe_arena_set_allocated_changekeychainfinished(
      ::grpc::ChangeKeychainFinishedEvent* changekeychainfinished);
  ::grpc::ChangeKeychainFinishedEvent* unsafe_arena_release_changekeychainfinished();

  // .grpc.HasNoKeychainEvent hasNoKeychain = 2;
  bool has_hasnokeychain() const;
  private:
  bool _internal_has_hasnokeychain() const;
  public:
  void clear_hasnokeychain();
  const ::grpc::HasNoKeychainEvent& hasnokeychain() const;
  PROTOBUF_NODISCARD ::grpc::HasNoKeychainEvent* release_hasnokeychain();
  ::grpc::HasNoKeychainEvent* mutable_hasnokeychain();
  void set_allocated_hasnokeychain(::grpc::HasNoKeychainEvent* hasnokeychain);
  private:
  const ::grpc::HasNoKeychainEvent& _internal_hasnokeychain() const;
  ::grpc::HasNoKeychainEvent* _internal_mutable_hasnokeychain();
  public:
  void unsafe_arena_set_allocated_hasnokeychain(
      ::grpc::HasNoKeychainEvent* hasnokeychain);
  ::grpc::HasNoKeychainEvent* unsafe_arena_release_hasnokeychain();

  // .grpc.RebuildKeychainEvent rebuildKeychain = 3;
  bool has_rebuildkeychain() const;
  private:
  bool _internal_has_rebuildkeychain() const;
  public:
  void clear_rebuildkeychain();
  const ::grpc::RebuildKeychainEvent& rebuildkeychain() const;
  PROTOBUF_NODISCARD ::grpc::RebuildKeychainEvent* release_rebuildkeychain();
  ::grpc::RebuildKeychainEvent* mutable_rebuildkeychain();
  void set_allocated_rebuildkeychain(::grpc::RebuildKeychainEvent* rebuildkeychain);
  private:
  const ::grpc::RebuildKeychainEvent& _internal_rebuildkeychain() const;
  ::grpc::RebuildKeychainEvent* _internal_mutable_rebuildkeychain();
  public:
  void unsafe_arena_set_allocated_rebuildkeychain(
      ::grpc::RebuildKeychainEvent* rebuildkeychain);
  ::grpc::RebuildKeychainEvent* unsafe_arena_release_rebuildkeychain();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.KeychainEvent)
 private:
  class _Internal;
  void set_has_changekeychainfinished();
  void set_has_hasnokeychain();
  void set_has_rebuildkeychain();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::ChangeKeychainFinishedEvent* changekeychainfinished_;
    ::grpc::HasNoKeychainEvent* hasnokeychain_;
    ::grpc::RebuildKeychainEvent* rebuildkeychain_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ChangeKeychainFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ChangeKeychainFinishedEvent) */ {
 public:
  inline ChangeKeychainFinishedEvent() : ChangeKeychainFinishedEvent(nullptr) {}
  explicit constexpr ChangeKeychainFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeKeychainFinishedEvent(const ChangeKeychainFinishedEvent& from);
  ChangeKeychainFinishedEvent(ChangeKeychainFinishedEvent&& from) noexcept
    : ChangeKeychainFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ChangeKeychainFinishedEvent& operator=(const ChangeKeychainFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeKeychainFinishedEvent& operator=(ChangeKeychainFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeKeychainFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeKeychainFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ChangeKeychainFinishedEvent*>(
               &_ChangeKeychainFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ChangeKeychainFinishedEvent& a, ChangeKeychainFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeKeychainFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeKeychainFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeKeychainFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeKeychainFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ChangeKeychainFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ChangeKeychainFinishedEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ChangeKeychainFinishedEvent";
  }
  protected:
  explicit ChangeKeychainFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ChangeKeychainFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class HasNoKeychainEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.HasNoKeychainEvent) */ {
 public:
  inline HasNoKeychainEvent() : HasNoKeychainEvent(nullptr) {}
  explicit constexpr HasNoKeychainEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HasNoKeychainEvent(const HasNoKeychainEvent& from);
  HasNoKeychainEvent(HasNoKeychainEvent&& from) noexcept
    : HasNoKeychainEvent() {
    *this = ::std::move(from);
  }

  inline HasNoKeychainEvent& operator=(const HasNoKeychainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HasNoKeychainEvent& operator=(HasNoKeychainEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HasNoKeychainEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const HasNoKeychainEvent* internal_default_instance() {
    return reinterpret_cast<const HasNoKeychainEvent*>(
               &_HasNoKeychainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(HasNoKeychainEvent& a, HasNoKeychainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(HasNoKeychainEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HasNoKeychainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HasNoKeychainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HasNoKeychainEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HasNoKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HasNoKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.HasNoKeychainEvent";
  }
  protected:
  explicit HasNoKeychainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.HasNoKeychainEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class RebuildKeychainEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.RebuildKeychainEvent) */ {
 public:
  inline RebuildKeychainEvent() : RebuildKeychainEvent(nullptr) {}
  explicit constexpr RebuildKeychainEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RebuildKeychainEvent(const RebuildKeychainEvent& from);
  RebuildKeychainEvent(RebuildKeychainEvent&& from) noexcept
    : RebuildKeychainEvent() {
    *this = ::std::move(from);
  }

  inline RebuildKeychainEvent& operator=(const RebuildKeychainEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RebuildKeychainEvent& operator=(RebuildKeychainEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RebuildKeychainEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const RebuildKeychainEvent* internal_default_instance() {
    return reinterpret_cast<const RebuildKeychainEvent*>(
               &_RebuildKeychainEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(RebuildKeychainEvent& a, RebuildKeychainEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RebuildKeychainEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RebuildKeychainEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RebuildKeychainEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RebuildKeychainEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RebuildKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RebuildKeychainEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.RebuildKeychainEvent";
  }
  protected:
  explicit RebuildKeychainEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.RebuildKeychainEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class MailEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.MailEvent) */ {
 public:
  inline MailEvent() : MailEvent(nullptr) {}
  ~MailEvent() override;
  explicit constexpr MailEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MailEvent(const MailEvent& from);
  MailEvent(MailEvent&& from) noexcept
    : MailEvent() {
    *this = ::std::move(from);
  }

  inline MailEvent& operator=(const MailEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailEvent& operator=(MailEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kNoActiveKeyForRecipientEvent = 1,
    kAddressChanged = 2,
    kAddressChangedLogout = 3,
    kApiCertIssue = 6,
    EVENT_NOT_SET = 0,
  };

  static inline const MailEvent* internal_default_instance() {
    return reinterpret_cast<const MailEvent*>(
               &_MailEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MailEvent& a, MailEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MailEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MailEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MailEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MailEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MailEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.MailEvent";
  }
  protected:
  explicit MailEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNoActiveKeyForRecipientEventFieldNumber = 1,
    kAddressChangedFieldNumber = 2,
    kAddressChangedLogoutFieldNumber = 3,
    kApiCertIssueFieldNumber = 6,
  };
  // .grpc.NoActiveKeyForRecipientEvent noActiveKeyForRecipientEvent = 1;
  bool has_noactivekeyforrecipientevent() const;
  private:
  bool _internal_has_noactivekeyforrecipientevent() const;
  public:
  void clear_noactivekeyforrecipientevent();
  const ::grpc::NoActiveKeyForRecipientEvent& noactivekeyforrecipientevent() const;
  PROTOBUF_NODISCARD ::grpc::NoActiveKeyForRecipientEvent* release_noactivekeyforrecipientevent();
  ::grpc::NoActiveKeyForRecipientEvent* mutable_noactivekeyforrecipientevent();
  void set_allocated_noactivekeyforrecipientevent(::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent);
  private:
  const ::grpc::NoActiveKeyForRecipientEvent& _internal_noactivekeyforrecipientevent() const;
  ::grpc::NoActiveKeyForRecipientEvent* _internal_mutable_noactivekeyforrecipientevent();
  public:
  void unsafe_arena_set_allocated_noactivekeyforrecipientevent(
      ::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent);
  ::grpc::NoActiveKeyForRecipientEvent* unsafe_arena_release_noactivekeyforrecipientevent();

  // .grpc.AddressChangedEvent addressChanged = 2;
  bool has_addresschanged() const;
  private:
  bool _internal_has_addresschanged() const;
  public:
  void clear_addresschanged();
  const ::grpc::AddressChangedEvent& addresschanged() const;
  PROTOBUF_NODISCARD ::grpc::AddressChangedEvent* release_addresschanged();
  ::grpc::AddressChangedEvent* mutable_addresschanged();
  void set_allocated_addresschanged(::grpc::AddressChangedEvent* addresschanged);
  private:
  const ::grpc::AddressChangedEvent& _internal_addresschanged() const;
  ::grpc::AddressChangedEvent* _internal_mutable_addresschanged();
  public:
  void unsafe_arena_set_allocated_addresschanged(
      ::grpc::AddressChangedEvent* addresschanged);
  ::grpc::AddressChangedEvent* unsafe_arena_release_addresschanged();

  // .grpc.AddressChangedLogoutEvent addressChangedLogout = 3;
  bool has_addresschangedlogout() const;
  private:
  bool _internal_has_addresschangedlogout() const;
  public:
  void clear_addresschangedlogout();
  const ::grpc::AddressChangedLogoutEvent& addresschangedlogout() const;
  PROTOBUF_NODISCARD ::grpc::AddressChangedLogoutEvent* release_addresschangedlogout();
  ::grpc::AddressChangedLogoutEvent* mutable_addresschangedlogout();
  void set_allocated_addresschangedlogout(::grpc::AddressChangedLogoutEvent* addresschangedlogout);
  private:
  const ::grpc::AddressChangedLogoutEvent& _internal_addresschangedlogout() const;
  ::grpc::AddressChangedLogoutEvent* _internal_mutable_addresschangedlogout();
  public:
  void unsafe_arena_set_allocated_addresschangedlogout(
      ::grpc::AddressChangedLogoutEvent* addresschangedlogout);
  ::grpc::AddressChangedLogoutEvent* unsafe_arena_release_addresschangedlogout();

  // .grpc.ApiCertIssueEvent apiCertIssue = 6;
  bool has_apicertissue() const;
  private:
  bool _internal_has_apicertissue() const;
  public:
  void clear_apicertissue();
  const ::grpc::ApiCertIssueEvent& apicertissue() const;
  PROTOBUF_NODISCARD ::grpc::ApiCertIssueEvent* release_apicertissue();
  ::grpc::ApiCertIssueEvent* mutable_apicertissue();
  void set_allocated_apicertissue(::grpc::ApiCertIssueEvent* apicertissue);
  private:
  const ::grpc::ApiCertIssueEvent& _internal_apicertissue() const;
  ::grpc::ApiCertIssueEvent* _internal_mutable_apicertissue();
  public:
  void unsafe_arena_set_allocated_apicertissue(
      ::grpc::ApiCertIssueEvent* apicertissue);
  ::grpc::ApiCertIssueEvent* unsafe_arena_release_apicertissue();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.MailEvent)
 private:
  class _Internal;
  void set_has_noactivekeyforrecipientevent();
  void set_has_addresschanged();
  void set_has_addresschangedlogout();
  void set_has_apicertissue();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent_;
    ::grpc::AddressChangedEvent* addresschanged_;
    ::grpc::AddressChangedLogoutEvent* addresschangedlogout_;
    ::grpc::ApiCertIssueEvent* apicertissue_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class NoActiveKeyForRecipientEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.NoActiveKeyForRecipientEvent) */ {
 public:
  inline NoActiveKeyForRecipientEvent() : NoActiveKeyForRecipientEvent(nullptr) {}
  ~NoActiveKeyForRecipientEvent() override;
  explicit constexpr NoActiveKeyForRecipientEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoActiveKeyForRecipientEvent(const NoActiveKeyForRecipientEvent& from);
  NoActiveKeyForRecipientEvent(NoActiveKeyForRecipientEvent&& from) noexcept
    : NoActiveKeyForRecipientEvent() {
    *this = ::std::move(from);
  }

  inline NoActiveKeyForRecipientEvent& operator=(const NoActiveKeyForRecipientEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoActiveKeyForRecipientEvent& operator=(NoActiveKeyForRecipientEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoActiveKeyForRecipientEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoActiveKeyForRecipientEvent* internal_default_instance() {
    return reinterpret_cast<const NoActiveKeyForRecipientEvent*>(
               &_NoActiveKeyForRecipientEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(NoActiveKeyForRecipientEvent& a, NoActiveKeyForRecipientEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(NoActiveKeyForRecipientEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoActiveKeyForRecipientEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoActiveKeyForRecipientEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoActiveKeyForRecipientEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoActiveKeyForRecipientEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NoActiveKeyForRecipientEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoActiveKeyForRecipientEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.NoActiveKeyForRecipientEvent";
  }
  protected:
  explicit NoActiveKeyForRecipientEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // @@protoc_insertion_point(class_scope:grpc.NoActiveKeyForRecipientEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AddressChangedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AddressChangedEvent) */ {
 public:
  inline AddressChangedEvent() : AddressChangedEvent(nullptr) {}
  ~AddressChangedEvent() override;
  explicit constexpr AddressChangedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressChangedEvent(const AddressChangedEvent& from);
  AddressChangedEvent(AddressChangedEvent&& from) noexcept
    : AddressChangedEvent() {
    *this = ::std::move(from);
  }

  inline AddressChangedEvent& operator=(const AddressChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressChangedEvent& operator=(AddressChangedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressChangedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressChangedEvent* internal_default_instance() {
    return reinterpret_cast<const AddressChangedEvent*>(
               &_AddressChangedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(AddressChangedEvent& a, AddressChangedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressChangedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressChangedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddressChangedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddressChangedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressChangedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressChangedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressChangedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AddressChangedEvent";
  }
  protected:
  explicit AddressChangedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:grpc.AddressChangedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class AddressChangedLogoutEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.AddressChangedLogoutEvent) */ {
 public:
  inline AddressChangedLogoutEvent() : AddressChangedLogoutEvent(nullptr) {}
  ~AddressChangedLogoutEvent() override;
  explicit constexpr AddressChangedLogoutEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddressChangedLogoutEvent(const AddressChangedLogoutEvent& from);
  AddressChangedLogoutEvent(AddressChangedLogoutEvent&& from) noexcept
    : AddressChangedLogoutEvent() {
    *this = ::std::move(from);
  }

  inline AddressChangedLogoutEvent& operator=(const AddressChangedLogoutEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddressChangedLogoutEvent& operator=(AddressChangedLogoutEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddressChangedLogoutEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddressChangedLogoutEvent* internal_default_instance() {
    return reinterpret_cast<const AddressChangedLogoutEvent*>(
               &_AddressChangedLogoutEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(AddressChangedLogoutEvent& a, AddressChangedLogoutEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AddressChangedLogoutEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddressChangedLogoutEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddressChangedLogoutEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddressChangedLogoutEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddressChangedLogoutEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddressChangedLogoutEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddressChangedLogoutEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.AddressChangedLogoutEvent";
  }
  protected:
  explicit AddressChangedLogoutEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:grpc.AddressChangedLogoutEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ApiCertIssueEvent final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:grpc.ApiCertIssueEvent) */ {
 public:
  inline ApiCertIssueEvent() : ApiCertIssueEvent(nullptr) {}
  explicit constexpr ApiCertIssueEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApiCertIssueEvent(const ApiCertIssueEvent& from);
  ApiCertIssueEvent(ApiCertIssueEvent&& from) noexcept
    : ApiCertIssueEvent() {
    *this = ::std::move(from);
  }

  inline ApiCertIssueEvent& operator=(const ApiCertIssueEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApiCertIssueEvent& operator=(ApiCertIssueEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApiCertIssueEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApiCertIssueEvent* internal_default_instance() {
    return reinterpret_cast<const ApiCertIssueEvent*>(
               &_ApiCertIssueEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(ApiCertIssueEvent& a, ApiCertIssueEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ApiCertIssueEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApiCertIssueEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApiCertIssueEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApiCertIssueEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ApiCertIssueEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ApiCertIssueEvent& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ApiCertIssueEvent";
  }
  protected:
  explicit ApiCertIssueEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:grpc.ApiCertIssueEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserEvent) */ {
 public:
  inline UserEvent() : UserEvent(nullptr) {}
  ~UserEvent() override;
  explicit constexpr UserEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserEvent(const UserEvent& from);
  UserEvent(UserEvent&& from) noexcept
    : UserEvent() {
    *this = ::std::move(from);
  }

  inline UserEvent& operator=(const UserEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserEvent& operator=(UserEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kToggleSplitModeFinished = 1,
    kUserDisconnected = 2,
    kUserChanged = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const UserEvent* internal_default_instance() {
    return reinterpret_cast<const UserEvent*>(
               &_UserEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(UserEvent& a, UserEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserEvent";
  }
  protected:
  explicit UserEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToggleSplitModeFinishedFieldNumber = 1,
    kUserDisconnectedFieldNumber = 2,
    kUserChangedFieldNumber = 3,
  };
  // .grpc.ToggleSplitModeFinishedEvent toggleSplitModeFinished = 1;
  bool has_togglesplitmodefinished() const;
  private:
  bool _internal_has_togglesplitmodefinished() const;
  public:
  void clear_togglesplitmodefinished();
  const ::grpc::ToggleSplitModeFinishedEvent& togglesplitmodefinished() const;
  PROTOBUF_NODISCARD ::grpc::ToggleSplitModeFinishedEvent* release_togglesplitmodefinished();
  ::grpc::ToggleSplitModeFinishedEvent* mutable_togglesplitmodefinished();
  void set_allocated_togglesplitmodefinished(::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished);
  private:
  const ::grpc::ToggleSplitModeFinishedEvent& _internal_togglesplitmodefinished() const;
  ::grpc::ToggleSplitModeFinishedEvent* _internal_mutable_togglesplitmodefinished();
  public:
  void unsafe_arena_set_allocated_togglesplitmodefinished(
      ::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished);
  ::grpc::ToggleSplitModeFinishedEvent* unsafe_arena_release_togglesplitmodefinished();

  // .grpc.UserDisconnectedEvent userDisconnected = 2;
  bool has_userdisconnected() const;
  private:
  bool _internal_has_userdisconnected() const;
  public:
  void clear_userdisconnected();
  const ::grpc::UserDisconnectedEvent& userdisconnected() const;
  PROTOBUF_NODISCARD ::grpc::UserDisconnectedEvent* release_userdisconnected();
  ::grpc::UserDisconnectedEvent* mutable_userdisconnected();
  void set_allocated_userdisconnected(::grpc::UserDisconnectedEvent* userdisconnected);
  private:
  const ::grpc::UserDisconnectedEvent& _internal_userdisconnected() const;
  ::grpc::UserDisconnectedEvent* _internal_mutable_userdisconnected();
  public:
  void unsafe_arena_set_allocated_userdisconnected(
      ::grpc::UserDisconnectedEvent* userdisconnected);
  ::grpc::UserDisconnectedEvent* unsafe_arena_release_userdisconnected();

  // .grpc.UserChangedEvent userChanged = 3;
  bool has_userchanged() const;
  private:
  bool _internal_has_userchanged() const;
  public:
  void clear_userchanged();
  const ::grpc::UserChangedEvent& userchanged() const;
  PROTOBUF_NODISCARD ::grpc::UserChangedEvent* release_userchanged();
  ::grpc::UserChangedEvent* mutable_userchanged();
  void set_allocated_userchanged(::grpc::UserChangedEvent* userchanged);
  private:
  const ::grpc::UserChangedEvent& _internal_userchanged() const;
  ::grpc::UserChangedEvent* _internal_mutable_userchanged();
  public:
  void unsafe_arena_set_allocated_userchanged(
      ::grpc::UserChangedEvent* userchanged);
  ::grpc::UserChangedEvent* unsafe_arena_release_userchanged();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:grpc.UserEvent)
 private:
  class _Internal;
  void set_has_togglesplitmodefinished();
  void set_has_userdisconnected();
  void set_has_userchanged();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EventUnion {
    constexpr EventUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished_;
    ::grpc::UserDisconnectedEvent* userdisconnected_;
    ::grpc::UserChangedEvent* userchanged_;
  } event_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class ToggleSplitModeFinishedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.ToggleSplitModeFinishedEvent) */ {
 public:
  inline ToggleSplitModeFinishedEvent() : ToggleSplitModeFinishedEvent(nullptr) {}
  ~ToggleSplitModeFinishedEvent() override;
  explicit constexpr ToggleSplitModeFinishedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ToggleSplitModeFinishedEvent(const ToggleSplitModeFinishedEvent& from);
  ToggleSplitModeFinishedEvent(ToggleSplitModeFinishedEvent&& from) noexcept
    : ToggleSplitModeFinishedEvent() {
    *this = ::std::move(from);
  }

  inline ToggleSplitModeFinishedEvent& operator=(const ToggleSplitModeFinishedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleSplitModeFinishedEvent& operator=(ToggleSplitModeFinishedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ToggleSplitModeFinishedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleSplitModeFinishedEvent* internal_default_instance() {
    return reinterpret_cast<const ToggleSplitModeFinishedEvent*>(
               &_ToggleSplitModeFinishedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ToggleSplitModeFinishedEvent& a, ToggleSplitModeFinishedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ToggleSplitModeFinishedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleSplitModeFinishedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleSplitModeFinishedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ToggleSplitModeFinishedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ToggleSplitModeFinishedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ToggleSplitModeFinishedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ToggleSplitModeFinishedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.ToggleSplitModeFinishedEvent";
  }
  protected:
  explicit ToggleSplitModeFinishedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:grpc.ToggleSplitModeFinishedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserDisconnectedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserDisconnectedEvent) */ {
 public:
  inline UserDisconnectedEvent() : UserDisconnectedEvent(nullptr) {}
  ~UserDisconnectedEvent() override;
  explicit constexpr UserDisconnectedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDisconnectedEvent(const UserDisconnectedEvent& from);
  UserDisconnectedEvent(UserDisconnectedEvent&& from) noexcept
    : UserDisconnectedEvent() {
    *this = ::std::move(from);
  }

  inline UserDisconnectedEvent& operator=(const UserDisconnectedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDisconnectedEvent& operator=(UserDisconnectedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDisconnectedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDisconnectedEvent* internal_default_instance() {
    return reinterpret_cast<const UserDisconnectedEvent*>(
               &_UserDisconnectedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(UserDisconnectedEvent& a, UserDisconnectedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDisconnectedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDisconnectedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDisconnectedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDisconnectedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserDisconnectedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserDisconnectedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDisconnectedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserDisconnectedEvent";
  }
  protected:
  explicit UserDisconnectedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserDisconnectedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// -------------------------------------------------------------------

class UserChangedEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpc.UserChangedEvent) */ {
 public:
  inline UserChangedEvent() : UserChangedEvent(nullptr) {}
  ~UserChangedEvent() override;
  explicit constexpr UserChangedEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserChangedEvent(const UserChangedEvent& from);
  UserChangedEvent(UserChangedEvent&& from) noexcept
    : UserChangedEvent() {
    *this = ::std::move(from);
  }

  inline UserChangedEvent& operator=(const UserChangedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserChangedEvent& operator=(UserChangedEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserChangedEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserChangedEvent* internal_default_instance() {
    return reinterpret_cast<const UserChangedEvent*>(
               &_UserChangedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(UserChangedEvent& a, UserChangedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(UserChangedEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserChangedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserChangedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserChangedEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserChangedEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserChangedEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserChangedEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpc.UserChangedEvent";
  }
  protected:
  explicit UserChangedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:grpc.UserChangedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bridge_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReportBugRequest

// string description = 1;
inline void ReportBugRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::description() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.description)
}
inline std::string* ReportBugRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.description)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_description() const {
  return description_.Get();
}
inline void ReportBugRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_description() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReportBugRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.description)
}

// string address = 2;
inline void ReportBugRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::address() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.address)
}
inline std::string* ReportBugRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.address)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_address() const {
  return address_.Get();
}
inline void ReportBugRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_address() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReportBugRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.address)
}

// string emailClient = 3;
inline void ReportBugRequest::clear_emailclient() {
  emailclient_.ClearToEmpty();
}
inline const std::string& ReportBugRequest::emailclient() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.emailClient)
  return _internal_emailclient();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportBugRequest::set_emailclient(ArgT0&& arg0, ArgT... args) {
 
 emailclient_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.emailClient)
}
inline std::string* ReportBugRequest::mutable_emailclient() {
  std::string* _s = _internal_mutable_emailclient();
  // @@protoc_insertion_point(field_mutable:grpc.ReportBugRequest.emailClient)
  return _s;
}
inline const std::string& ReportBugRequest::_internal_emailclient() const {
  return emailclient_.Get();
}
inline void ReportBugRequest::_internal_set_emailclient(const std::string& value) {
  
  emailclient_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::_internal_mutable_emailclient() {
  
  return emailclient_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReportBugRequest::release_emailclient() {
  // @@protoc_insertion_point(field_release:grpc.ReportBugRequest.emailClient)
  return emailclient_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReportBugRequest::set_allocated_emailclient(std::string* emailclient) {
  if (emailclient != nullptr) {
    
  } else {
    
  }
  emailclient_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), emailclient,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (emailclient_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    emailclient_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ReportBugRequest.emailClient)
}

// bool includeLogs = 4;
inline void ReportBugRequest::clear_includelogs() {
  includelogs_ = false;
}
inline bool ReportBugRequest::_internal_includelogs() const {
  return includelogs_;
}
inline bool ReportBugRequest::includelogs() const {
  // @@protoc_insertion_point(field_get:grpc.ReportBugRequest.includeLogs)
  return _internal_includelogs();
}
inline void ReportBugRequest::_internal_set_includelogs(bool value) {
  
  includelogs_ = value;
}
inline void ReportBugRequest::set_includelogs(bool value) {
  _internal_set_includelogs(value);
  // @@protoc_insertion_point(field_set:grpc.ReportBugRequest.includeLogs)
}

// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:grpc.LoginRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  return username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:grpc.LoginRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginRequest.username)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:grpc.LoginRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:grpc.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  return password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:grpc.LoginRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginAbortRequest

// string username = 1;
inline void LoginAbortRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& LoginAbortRequest::username() const {
  // @@protoc_insertion_point(field_get:grpc.LoginAbortRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginAbortRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginAbortRequest.username)
}
inline std::string* LoginAbortRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.LoginAbortRequest.username)
  return _s;
}
inline const std::string& LoginAbortRequest::_internal_username() const {
  return username_.Get();
}
inline void LoginAbortRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginAbortRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginAbortRequest::release_username() {
  // @@protoc_insertion_point(field_release:grpc.LoginAbortRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginAbortRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginAbortRequest.username)
}

// -------------------------------------------------------------------

// ChangeLocalCacheRequest

// bool enableDiskCache = 1;
inline void ChangeLocalCacheRequest::clear_enablediskcache() {
  enablediskcache_ = false;
}
inline bool ChangeLocalCacheRequest::_internal_enablediskcache() const {
  return enablediskcache_;
}
inline bool ChangeLocalCacheRequest::enablediskcache() const {
  // @@protoc_insertion_point(field_get:grpc.ChangeLocalCacheRequest.enableDiskCache)
  return _internal_enablediskcache();
}
inline void ChangeLocalCacheRequest::_internal_set_enablediskcache(bool value) {
  
  enablediskcache_ = value;
}
inline void ChangeLocalCacheRequest::set_enablediskcache(bool value) {
  _internal_set_enablediskcache(value);
  // @@protoc_insertion_point(field_set:grpc.ChangeLocalCacheRequest.enableDiskCache)
}

// string diskCachePath = 2;
inline void ChangeLocalCacheRequest::clear_diskcachepath() {
  diskcachepath_.ClearToEmpty();
}
inline const std::string& ChangeLocalCacheRequest::diskcachepath() const {
  // @@protoc_insertion_point(field_get:grpc.ChangeLocalCacheRequest.diskCachePath)
  return _internal_diskcachepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeLocalCacheRequest::set_diskcachepath(ArgT0&& arg0, ArgT... args) {
 
 diskcachepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ChangeLocalCacheRequest.diskCachePath)
}
inline std::string* ChangeLocalCacheRequest::mutable_diskcachepath() {
  std::string* _s = _internal_mutable_diskcachepath();
  // @@protoc_insertion_point(field_mutable:grpc.ChangeLocalCacheRequest.diskCachePath)
  return _s;
}
inline const std::string& ChangeLocalCacheRequest::_internal_diskcachepath() const {
  return diskcachepath_.Get();
}
inline void ChangeLocalCacheRequest::_internal_set_diskcachepath(const std::string& value) {
  
  diskcachepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChangeLocalCacheRequest::_internal_mutable_diskcachepath() {
  
  return diskcachepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChangeLocalCacheRequest::release_diskcachepath() {
  // @@protoc_insertion_point(field_release:grpc.ChangeLocalCacheRequest.diskCachePath)
  return diskcachepath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChangeLocalCacheRequest::set_allocated_diskcachepath(std::string* diskcachepath) {
  if (diskcachepath != nullptr) {
    
  } else {
    
  }
  diskcachepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), diskcachepath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (diskcachepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    diskcachepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ChangeLocalCacheRequest.diskCachePath)
}

// -------------------------------------------------------------------

// ChangePortsRequest

// int32 imapPort = 1;
inline void ChangePortsRequest::clear_imapport() {
  imapport_ = 0;
}
inline int32_t ChangePortsRequest::_internal_imapport() const {
  return imapport_;
}
inline int32_t ChangePortsRequest::imapport() const {
  // @@protoc_insertion_point(field_get:grpc.ChangePortsRequest.imapPort)
  return _internal_imapport();
}
inline void ChangePortsRequest::_internal_set_imapport(int32_t value) {
  
  imapport_ = value;
}
inline void ChangePortsRequest::set_imapport(int32_t value) {
  _internal_set_imapport(value);
  // @@protoc_insertion_point(field_set:grpc.ChangePortsRequest.imapPort)
}

// int32 smtpPort = 2;
inline void ChangePortsRequest::clear_smtpport() {
  smtpport_ = 0;
}
inline int32_t ChangePortsRequest::_internal_smtpport() const {
  return smtpport_;
}
inline int32_t ChangePortsRequest::smtpport() const {
  // @@protoc_insertion_point(field_get:grpc.ChangePortsRequest.smtpPort)
  return _internal_smtpport();
}
inline void ChangePortsRequest::_internal_set_smtpport(int32_t value) {
  
  smtpport_ = value;
}
inline void ChangePortsRequest::set_smtpport(int32_t value) {
  _internal_set_smtpport(value);
  // @@protoc_insertion_point(field_set:grpc.ChangePortsRequest.smtpPort)
}

// -------------------------------------------------------------------

// AvailableKeychainsResponse

// repeated string keychains = 1;
inline int AvailableKeychainsResponse::_internal_keychains_size() const {
  return keychains_.size();
}
inline int AvailableKeychainsResponse::keychains_size() const {
  return _internal_keychains_size();
}
inline void AvailableKeychainsResponse::clear_keychains() {
  keychains_.Clear();
}
inline std::string* AvailableKeychainsResponse::add_keychains() {
  std::string* _s = _internal_add_keychains();
  // @@protoc_insertion_point(field_add_mutable:grpc.AvailableKeychainsResponse.keychains)
  return _s;
}
inline const std::string& AvailableKeychainsResponse::_internal_keychains(int index) const {
  return keychains_.Get(index);
}
inline const std::string& AvailableKeychainsResponse::keychains(int index) const {
  // @@protoc_insertion_point(field_get:grpc.AvailableKeychainsResponse.keychains)
  return _internal_keychains(index);
}
inline std::string* AvailableKeychainsResponse::mutable_keychains(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.AvailableKeychainsResponse.keychains)
  return keychains_.Mutable(index);
}
inline void AvailableKeychainsResponse::set_keychains(int index, const std::string& value) {
  keychains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::set_keychains(int index, std::string&& value) {
  keychains_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::set_keychains(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keychains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::set_keychains(int index, const char* value, size_t size) {
  keychains_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.AvailableKeychainsResponse.keychains)
}
inline std::string* AvailableKeychainsResponse::_internal_add_keychains() {
  return keychains_.Add();
}
inline void AvailableKeychainsResponse::add_keychains(const std::string& value) {
  keychains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::add_keychains(std::string&& value) {
  keychains_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::add_keychains(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keychains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.AvailableKeychainsResponse.keychains)
}
inline void AvailableKeychainsResponse::add_keychains(const char* value, size_t size) {
  keychains_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.AvailableKeychainsResponse.keychains)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AvailableKeychainsResponse::keychains() const {
  // @@protoc_insertion_point(field_list:grpc.AvailableKeychainsResponse.keychains)
  return keychains_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AvailableKeychainsResponse::mutable_keychains() {
  // @@protoc_insertion_point(field_mutable_list:grpc.AvailableKeychainsResponse.keychains)
  return &keychains_;
}

// -------------------------------------------------------------------

// User

// string id = 1;
inline void User::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:grpc.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:grpc.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:grpc.User.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.id)
}

// string username = 2;
inline void User::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:grpc.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.username)
}
inline std::string* User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  return username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:grpc.User.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.username)
}

// string avatarText = 3;
inline void User::clear_avatartext() {
  avatartext_.ClearToEmpty();
}
inline const std::string& User::avatartext() const {
  // @@protoc_insertion_point(field_get:grpc.User.avatarText)
  return _internal_avatartext();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_avatartext(ArgT0&& arg0, ArgT... args) {
 
 avatartext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.avatarText)
}
inline std::string* User::mutable_avatartext() {
  std::string* _s = _internal_mutable_avatartext();
  // @@protoc_insertion_point(field_mutable:grpc.User.avatarText)
  return _s;
}
inline const std::string& User::_internal_avatartext() const {
  return avatartext_.Get();
}
inline void User::_internal_set_avatartext(const std::string& value) {
  
  avatartext_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_avatartext() {
  
  return avatartext_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_avatartext() {
  // @@protoc_insertion_point(field_release:grpc.User.avatarText)
  return avatartext_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_avatartext(std::string* avatartext) {
  if (avatartext != nullptr) {
    
  } else {
    
  }
  avatartext_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatartext,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatartext_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatartext_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.avatarText)
}

// bool loggedIn = 4;
inline void User::clear_loggedin() {
  loggedin_ = false;
}
inline bool User::_internal_loggedin() const {
  return loggedin_;
}
inline bool User::loggedin() const {
  // @@protoc_insertion_point(field_get:grpc.User.loggedIn)
  return _internal_loggedin();
}
inline void User::_internal_set_loggedin(bool value) {
  
  loggedin_ = value;
}
inline void User::set_loggedin(bool value) {
  _internal_set_loggedin(value);
  // @@protoc_insertion_point(field_set:grpc.User.loggedIn)
}

// bool splitMode = 5;
inline void User::clear_splitmode() {
  splitmode_ = false;
}
inline bool User::_internal_splitmode() const {
  return splitmode_;
}
inline bool User::splitmode() const {
  // @@protoc_insertion_point(field_get:grpc.User.splitMode)
  return _internal_splitmode();
}
inline void User::_internal_set_splitmode(bool value) {
  
  splitmode_ = value;
}
inline void User::set_splitmode(bool value) {
  _internal_set_splitmode(value);
  // @@protoc_insertion_point(field_set:grpc.User.splitMode)
}

// bool setupGuideSeen = 6;
inline void User::clear_setupguideseen() {
  setupguideseen_ = false;
}
inline bool User::_internal_setupguideseen() const {
  return setupguideseen_;
}
inline bool User::setupguideseen() const {
  // @@protoc_insertion_point(field_get:grpc.User.setupGuideSeen)
  return _internal_setupguideseen();
}
inline void User::_internal_set_setupguideseen(bool value) {
  
  setupguideseen_ = value;
}
inline void User::set_setupguideseen(bool value) {
  _internal_set_setupguideseen(value);
  // @@protoc_insertion_point(field_set:grpc.User.setupGuideSeen)
}

// int64 usedBytes = 7;
inline void User::clear_usedbytes() {
  usedbytes_ = int64_t{0};
}
inline int64_t User::_internal_usedbytes() const {
  return usedbytes_;
}
inline int64_t User::usedbytes() const {
  // @@protoc_insertion_point(field_get:grpc.User.usedBytes)
  return _internal_usedbytes();
}
inline void User::_internal_set_usedbytes(int64_t value) {
  
  usedbytes_ = value;
}
inline void User::set_usedbytes(int64_t value) {
  _internal_set_usedbytes(value);
  // @@protoc_insertion_point(field_set:grpc.User.usedBytes)
}

// int64 totalBytes = 8;
inline void User::clear_totalbytes() {
  totalbytes_ = int64_t{0};
}
inline int64_t User::_internal_totalbytes() const {
  return totalbytes_;
}
inline int64_t User::totalbytes() const {
  // @@protoc_insertion_point(field_get:grpc.User.totalBytes)
  return _internal_totalbytes();
}
inline void User::_internal_set_totalbytes(int64_t value) {
  
  totalbytes_ = value;
}
inline void User::set_totalbytes(int64_t value) {
  _internal_set_totalbytes(value);
  // @@protoc_insertion_point(field_set:grpc.User.totalBytes)
}

// string password = 9;
inline void User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& User::password() const {
  // @@protoc_insertion_point(field_get:grpc.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.User.password)
}
inline std::string* User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:grpc.User.password)
  return _s;
}
inline const std::string& User::_internal_password() const {
  return password_.Get();
}
inline void User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_password() {
  // @@protoc_insertion_point(field_release:grpc.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.User.password)
}

// repeated string addresses = 10;
inline int User::_internal_addresses_size() const {
  return addresses_.size();
}
inline int User::addresses_size() const {
  return _internal_addresses_size();
}
inline void User::clear_addresses() {
  addresses_.Clear();
}
inline std::string* User::add_addresses() {
  std::string* _s = _internal_add_addresses();
  // @@protoc_insertion_point(field_add_mutable:grpc.User.addresses)
  return _s;
}
inline const std::string& User::_internal_addresses(int index) const {
  return addresses_.Get(index);
}
inline const std::string& User::addresses(int index) const {
  // @@protoc_insertion_point(field_get:grpc.User.addresses)
  return _internal_addresses(index);
}
inline std::string* User::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.User.addresses)
  return addresses_.Mutable(index);
}
inline void User::set_addresses(int index, const std::string& value) {
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:grpc.User.addresses)
}
inline void User::set_addresses(int index, std::string&& value) {
  addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:grpc.User.addresses)
}
inline void User::set_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:grpc.User.addresses)
}
inline void User::set_addresses(int index, const char* value, size_t size) {
  addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:grpc.User.addresses)
}
inline std::string* User::_internal_add_addresses() {
  return addresses_.Add();
}
inline void User::add_addresses(const std::string& value) {
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:grpc.User.addresses)
}
inline void User::add_addresses(std::string&& value) {
  addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:grpc.User.addresses)
}
inline void User::add_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:grpc.User.addresses)
}
inline void User::add_addresses(const char* value, size_t size) {
  addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:grpc.User.addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
User::addresses() const {
  // @@protoc_insertion_point(field_list:grpc.User.addresses)
  return addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
User::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:grpc.User.addresses)
  return &addresses_;
}

// -------------------------------------------------------------------

// UserSplitModeRequest

// string userID = 1;
inline void UserSplitModeRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& UserSplitModeRequest::userid() const {
  // @@protoc_insertion_point(field_get:grpc.UserSplitModeRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserSplitModeRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserSplitModeRequest.userID)
}
inline std::string* UserSplitModeRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.UserSplitModeRequest.userID)
  return _s;
}
inline const std::string& UserSplitModeRequest::_internal_userid() const {
  return userid_.Get();
}
inline void UserSplitModeRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserSplitModeRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserSplitModeRequest::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.UserSplitModeRequest.userID)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserSplitModeRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserSplitModeRequest.userID)
}

// bool active = 2;
inline void UserSplitModeRequest::clear_active() {
  active_ = false;
}
inline bool UserSplitModeRequest::_internal_active() const {
  return active_;
}
inline bool UserSplitModeRequest::active() const {
  // @@protoc_insertion_point(field_get:grpc.UserSplitModeRequest.active)
  return _internal_active();
}
inline void UserSplitModeRequest::_internal_set_active(bool value) {
  
  active_ = value;
}
inline void UserSplitModeRequest::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:grpc.UserSplitModeRequest.active)
}

// -------------------------------------------------------------------

// UserListResponse

// repeated .grpc.User users = 1;
inline int UserListResponse::_internal_users_size() const {
  return users_.size();
}
inline int UserListResponse::users_size() const {
  return _internal_users_size();
}
inline void UserListResponse::clear_users() {
  users_.Clear();
}
inline ::grpc::User* UserListResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:grpc.UserListResponse.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >*
UserListResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:grpc.UserListResponse.users)
  return &users_;
}
inline const ::grpc::User& UserListResponse::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::grpc::User& UserListResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:grpc.UserListResponse.users)
  return _internal_users(index);
}
inline ::grpc::User* UserListResponse::_internal_add_users() {
  return users_.Add();
}
inline ::grpc::User* UserListResponse::add_users() {
  ::grpc::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:grpc.UserListResponse.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::grpc::User >&
UserListResponse::users() const {
  // @@protoc_insertion_point(field_list:grpc.UserListResponse.users)
  return users_;
}

// -------------------------------------------------------------------

// ConfigureAppleMailRequest

// string userID = 1;
inline void ConfigureAppleMailRequest::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& ConfigureAppleMailRequest::userid() const {
  // @@protoc_insertion_point(field_get:grpc.ConfigureAppleMailRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigureAppleMailRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ConfigureAppleMailRequest.userID)
}
inline std::string* ConfigureAppleMailRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.ConfigureAppleMailRequest.userID)
  return _s;
}
inline const std::string& ConfigureAppleMailRequest::_internal_userid() const {
  return userid_.Get();
}
inline void ConfigureAppleMailRequest::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.ConfigureAppleMailRequest.userID)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigureAppleMailRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ConfigureAppleMailRequest.userID)
}

// string address = 2;
inline void ConfigureAppleMailRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& ConfigureAppleMailRequest::address() const {
  // @@protoc_insertion_point(field_get:grpc.ConfigureAppleMailRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigureAppleMailRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ConfigureAppleMailRequest.address)
}
inline std::string* ConfigureAppleMailRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.ConfigureAppleMailRequest.address)
  return _s;
}
inline const std::string& ConfigureAppleMailRequest::_internal_address() const {
  return address_.Get();
}
inline void ConfigureAppleMailRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigureAppleMailRequest::release_address() {
  // @@protoc_insertion_point(field_release:grpc.ConfigureAppleMailRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigureAppleMailRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ConfigureAppleMailRequest.address)
}

// -------------------------------------------------------------------

// StreamEvent

// .grpc.AppEvent app = 1;
inline bool StreamEvent::_internal_has_app() const {
  return event_case() == kApp;
}
inline bool StreamEvent::has_app() const {
  return _internal_has_app();
}
inline void StreamEvent::set_has_app() {
  _oneof_case_[0] = kApp;
}
inline void StreamEvent::clear_app() {
  if (_internal_has_app()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.app_;
    }
    clear_has_event();
  }
}
inline ::grpc::AppEvent* StreamEvent::release_app() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.app)
  if (_internal_has_app()) {
    clear_has_event();
      ::grpc::AppEvent* temp = event_.app_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.app_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::AppEvent& StreamEvent::_internal_app() const {
  return _internal_has_app()
      ? *event_.app_
      : reinterpret_cast< ::grpc::AppEvent&>(::grpc::_AppEvent_default_instance_);
}
inline const ::grpc::AppEvent& StreamEvent::app() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.app)
  return _internal_app();
}
inline ::grpc::AppEvent* StreamEvent::unsafe_arena_release_app() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.app)
  if (_internal_has_app()) {
    clear_has_event();
    ::grpc::AppEvent* temp = event_.app_;
    event_.app_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_app(::grpc::AppEvent* app) {
  clear_event();
  if (app) {
    set_has_app();
    event_.app_ = app;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.app)
}
inline ::grpc::AppEvent* StreamEvent::_internal_mutable_app() {
  if (!_internal_has_app()) {
    clear_event();
    set_has_app();
    event_.app_ = CreateMaybeMessage< ::grpc::AppEvent >(GetArenaForAllocation());
  }
  return event_.app_;
}
inline ::grpc::AppEvent* StreamEvent::mutable_app() {
  ::grpc::AppEvent* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.app)
  return _msg;
}

// .grpc.LoginEvent login = 2;
inline bool StreamEvent::_internal_has_login() const {
  return event_case() == kLogin;
}
inline bool StreamEvent::has_login() const {
  return _internal_has_login();
}
inline void StreamEvent::set_has_login() {
  _oneof_case_[0] = kLogin;
}
inline void StreamEvent::clear_login() {
  if (_internal_has_login()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.login_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginEvent* StreamEvent::release_login() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.login)
  if (_internal_has_login()) {
    clear_has_event();
      ::grpc::LoginEvent* temp = event_.login_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginEvent& StreamEvent::_internal_login() const {
  return _internal_has_login()
      ? *event_.login_
      : reinterpret_cast< ::grpc::LoginEvent&>(::grpc::_LoginEvent_default_instance_);
}
inline const ::grpc::LoginEvent& StreamEvent::login() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.login)
  return _internal_login();
}
inline ::grpc::LoginEvent* StreamEvent::unsafe_arena_release_login() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.login)
  if (_internal_has_login()) {
    clear_has_event();
    ::grpc::LoginEvent* temp = event_.login_;
    event_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_login(::grpc::LoginEvent* login) {
  clear_event();
  if (login) {
    set_has_login();
    event_.login_ = login;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.login)
}
inline ::grpc::LoginEvent* StreamEvent::_internal_mutable_login() {
  if (!_internal_has_login()) {
    clear_event();
    set_has_login();
    event_.login_ = CreateMaybeMessage< ::grpc::LoginEvent >(GetArenaForAllocation());
  }
  return event_.login_;
}
inline ::grpc::LoginEvent* StreamEvent::mutable_login() {
  ::grpc::LoginEvent* _msg = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.login)
  return _msg;
}

// .grpc.UpdateEvent update = 3;
inline bool StreamEvent::_internal_has_update() const {
  return event_case() == kUpdate;
}
inline bool StreamEvent::has_update() const {
  return _internal_has_update();
}
inline void StreamEvent::set_has_update() {
  _oneof_case_[0] = kUpdate;
}
inline void StreamEvent::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.update_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateEvent* StreamEvent::release_update() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.update)
  if (_internal_has_update()) {
    clear_has_event();
      ::grpc::UpdateEvent* temp = event_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateEvent& StreamEvent::_internal_update() const {
  return _internal_has_update()
      ? *event_.update_
      : reinterpret_cast< ::grpc::UpdateEvent&>(::grpc::_UpdateEvent_default_instance_);
}
inline const ::grpc::UpdateEvent& StreamEvent::update() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.update)
  return _internal_update();
}
inline ::grpc::UpdateEvent* StreamEvent::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.update)
  if (_internal_has_update()) {
    clear_has_event();
    ::grpc::UpdateEvent* temp = event_.update_;
    event_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_update(::grpc::UpdateEvent* update) {
  clear_event();
  if (update) {
    set_has_update();
    event_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.update)
}
inline ::grpc::UpdateEvent* StreamEvent::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_event();
    set_has_update();
    event_.update_ = CreateMaybeMessage< ::grpc::UpdateEvent >(GetArenaForAllocation());
  }
  return event_.update_;
}
inline ::grpc::UpdateEvent* StreamEvent::mutable_update() {
  ::grpc::UpdateEvent* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.update)
  return _msg;
}

// .grpc.CacheEvent cache = 4;
inline bool StreamEvent::_internal_has_cache() const {
  return event_case() == kCache;
}
inline bool StreamEvent::has_cache() const {
  return _internal_has_cache();
}
inline void StreamEvent::set_has_cache() {
  _oneof_case_[0] = kCache;
}
inline void StreamEvent::clear_cache() {
  if (_internal_has_cache()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.cache_;
    }
    clear_has_event();
  }
}
inline ::grpc::CacheEvent* StreamEvent::release_cache() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.cache)
  if (_internal_has_cache()) {
    clear_has_event();
      ::grpc::CacheEvent* temp = event_.cache_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.cache_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::CacheEvent& StreamEvent::_internal_cache() const {
  return _internal_has_cache()
      ? *event_.cache_
      : reinterpret_cast< ::grpc::CacheEvent&>(::grpc::_CacheEvent_default_instance_);
}
inline const ::grpc::CacheEvent& StreamEvent::cache() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.cache)
  return _internal_cache();
}
inline ::grpc::CacheEvent* StreamEvent::unsafe_arena_release_cache() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.cache)
  if (_internal_has_cache()) {
    clear_has_event();
    ::grpc::CacheEvent* temp = event_.cache_;
    event_.cache_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_cache(::grpc::CacheEvent* cache) {
  clear_event();
  if (cache) {
    set_has_cache();
    event_.cache_ = cache;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.cache)
}
inline ::grpc::CacheEvent* StreamEvent::_internal_mutable_cache() {
  if (!_internal_has_cache()) {
    clear_event();
    set_has_cache();
    event_.cache_ = CreateMaybeMessage< ::grpc::CacheEvent >(GetArenaForAllocation());
  }
  return event_.cache_;
}
inline ::grpc::CacheEvent* StreamEvent::mutable_cache() {
  ::grpc::CacheEvent* _msg = _internal_mutable_cache();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.cache)
  return _msg;
}

// .grpc.MailSettingsEvent mailSettings = 5;
inline bool StreamEvent::_internal_has_mailsettings() const {
  return event_case() == kMailSettings;
}
inline bool StreamEvent::has_mailsettings() const {
  return _internal_has_mailsettings();
}
inline void StreamEvent::set_has_mailsettings() {
  _oneof_case_[0] = kMailSettings;
}
inline void StreamEvent::clear_mailsettings() {
  if (_internal_has_mailsettings()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.mailsettings_;
    }
    clear_has_event();
  }
}
inline ::grpc::MailSettingsEvent* StreamEvent::release_mailsettings() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.mailSettings)
  if (_internal_has_mailsettings()) {
    clear_has_event();
      ::grpc::MailSettingsEvent* temp = event_.mailsettings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.mailsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::MailSettingsEvent& StreamEvent::_internal_mailsettings() const {
  return _internal_has_mailsettings()
      ? *event_.mailsettings_
      : reinterpret_cast< ::grpc::MailSettingsEvent&>(::grpc::_MailSettingsEvent_default_instance_);
}
inline const ::grpc::MailSettingsEvent& StreamEvent::mailsettings() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.mailSettings)
  return _internal_mailsettings();
}
inline ::grpc::MailSettingsEvent* StreamEvent::unsafe_arena_release_mailsettings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.mailSettings)
  if (_internal_has_mailsettings()) {
    clear_has_event();
    ::grpc::MailSettingsEvent* temp = event_.mailsettings_;
    event_.mailsettings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_mailsettings(::grpc::MailSettingsEvent* mailsettings) {
  clear_event();
  if (mailsettings) {
    set_has_mailsettings();
    event_.mailsettings_ = mailsettings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.mailSettings)
}
inline ::grpc::MailSettingsEvent* StreamEvent::_internal_mutable_mailsettings() {
  if (!_internal_has_mailsettings()) {
    clear_event();
    set_has_mailsettings();
    event_.mailsettings_ = CreateMaybeMessage< ::grpc::MailSettingsEvent >(GetArenaForAllocation());
  }
  return event_.mailsettings_;
}
inline ::grpc::MailSettingsEvent* StreamEvent::mutable_mailsettings() {
  ::grpc::MailSettingsEvent* _msg = _internal_mutable_mailsettings();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.mailSettings)
  return _msg;
}

// .grpc.KeychainEvent keychain = 6;
inline bool StreamEvent::_internal_has_keychain() const {
  return event_case() == kKeychain;
}
inline bool StreamEvent::has_keychain() const {
  return _internal_has_keychain();
}
inline void StreamEvent::set_has_keychain() {
  _oneof_case_[0] = kKeychain;
}
inline void StreamEvent::clear_keychain() {
  if (_internal_has_keychain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.keychain_;
    }
    clear_has_event();
  }
}
inline ::grpc::KeychainEvent* StreamEvent::release_keychain() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.keychain)
  if (_internal_has_keychain()) {
    clear_has_event();
      ::grpc::KeychainEvent* temp = event_.keychain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.keychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::KeychainEvent& StreamEvent::_internal_keychain() const {
  return _internal_has_keychain()
      ? *event_.keychain_
      : reinterpret_cast< ::grpc::KeychainEvent&>(::grpc::_KeychainEvent_default_instance_);
}
inline const ::grpc::KeychainEvent& StreamEvent::keychain() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.keychain)
  return _internal_keychain();
}
inline ::grpc::KeychainEvent* StreamEvent::unsafe_arena_release_keychain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.keychain)
  if (_internal_has_keychain()) {
    clear_has_event();
    ::grpc::KeychainEvent* temp = event_.keychain_;
    event_.keychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_keychain(::grpc::KeychainEvent* keychain) {
  clear_event();
  if (keychain) {
    set_has_keychain();
    event_.keychain_ = keychain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.keychain)
}
inline ::grpc::KeychainEvent* StreamEvent::_internal_mutable_keychain() {
  if (!_internal_has_keychain()) {
    clear_event();
    set_has_keychain();
    event_.keychain_ = CreateMaybeMessage< ::grpc::KeychainEvent >(GetArenaForAllocation());
  }
  return event_.keychain_;
}
inline ::grpc::KeychainEvent* StreamEvent::mutable_keychain() {
  ::grpc::KeychainEvent* _msg = _internal_mutable_keychain();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.keychain)
  return _msg;
}

// .grpc.MailEvent mail = 7;
inline bool StreamEvent::_internal_has_mail() const {
  return event_case() == kMail;
}
inline bool StreamEvent::has_mail() const {
  return _internal_has_mail();
}
inline void StreamEvent::set_has_mail() {
  _oneof_case_[0] = kMail;
}
inline void StreamEvent::clear_mail() {
  if (_internal_has_mail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.mail_;
    }
    clear_has_event();
  }
}
inline ::grpc::MailEvent* StreamEvent::release_mail() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.mail)
  if (_internal_has_mail()) {
    clear_has_event();
      ::grpc::MailEvent* temp = event_.mail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.mail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::MailEvent& StreamEvent::_internal_mail() const {
  return _internal_has_mail()
      ? *event_.mail_
      : reinterpret_cast< ::grpc::MailEvent&>(::grpc::_MailEvent_default_instance_);
}
inline const ::grpc::MailEvent& StreamEvent::mail() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.mail)
  return _internal_mail();
}
inline ::grpc::MailEvent* StreamEvent::unsafe_arena_release_mail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.mail)
  if (_internal_has_mail()) {
    clear_has_event();
    ::grpc::MailEvent* temp = event_.mail_;
    event_.mail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_mail(::grpc::MailEvent* mail) {
  clear_event();
  if (mail) {
    set_has_mail();
    event_.mail_ = mail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.mail)
}
inline ::grpc::MailEvent* StreamEvent::_internal_mutable_mail() {
  if (!_internal_has_mail()) {
    clear_event();
    set_has_mail();
    event_.mail_ = CreateMaybeMessage< ::grpc::MailEvent >(GetArenaForAllocation());
  }
  return event_.mail_;
}
inline ::grpc::MailEvent* StreamEvent::mutable_mail() {
  ::grpc::MailEvent* _msg = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.mail)
  return _msg;
}

// .grpc.UserEvent user = 8;
inline bool StreamEvent::_internal_has_user() const {
  return event_case() == kUser;
}
inline bool StreamEvent::has_user() const {
  return _internal_has_user();
}
inline void StreamEvent::set_has_user() {
  _oneof_case_[0] = kUser;
}
inline void StreamEvent::clear_user() {
  if (_internal_has_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.user_;
    }
    clear_has_event();
  }
}
inline ::grpc::UserEvent* StreamEvent::release_user() {
  // @@protoc_insertion_point(field_release:grpc.StreamEvent.user)
  if (_internal_has_user()) {
    clear_has_event();
      ::grpc::UserEvent* temp = event_.user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UserEvent& StreamEvent::_internal_user() const {
  return _internal_has_user()
      ? *event_.user_
      : reinterpret_cast< ::grpc::UserEvent&>(::grpc::_UserEvent_default_instance_);
}
inline const ::grpc::UserEvent& StreamEvent::user() const {
  // @@protoc_insertion_point(field_get:grpc.StreamEvent.user)
  return _internal_user();
}
inline ::grpc::UserEvent* StreamEvent::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.StreamEvent.user)
  if (_internal_has_user()) {
    clear_has_event();
    ::grpc::UserEvent* temp = event_.user_;
    event_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamEvent::unsafe_arena_set_allocated_user(::grpc::UserEvent* user) {
  clear_event();
  if (user) {
    set_has_user();
    event_.user_ = user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.StreamEvent.user)
}
inline ::grpc::UserEvent* StreamEvent::_internal_mutable_user() {
  if (!_internal_has_user()) {
    clear_event();
    set_has_user();
    event_.user_ = CreateMaybeMessage< ::grpc::UserEvent >(GetArenaForAllocation());
  }
  return event_.user_;
}
inline ::grpc::UserEvent* StreamEvent::mutable_user() {
  ::grpc::UserEvent* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:grpc.StreamEvent.user)
  return _msg;
}

inline bool StreamEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void StreamEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline StreamEvent::EventCase StreamEvent::event_case() const {
  return StreamEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AppEvent

// .grpc.InternetStatusEvent internetStatus = 1;
inline bool AppEvent::_internal_has_internetstatus() const {
  return event_case() == kInternetStatus;
}
inline bool AppEvent::has_internetstatus() const {
  return _internal_has_internetstatus();
}
inline void AppEvent::set_has_internetstatus() {
  _oneof_case_[0] = kInternetStatus;
}
inline void AppEvent::clear_internetstatus() {
  if (_internal_has_internetstatus()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.internetstatus_;
    }
    clear_has_event();
  }
}
inline ::grpc::InternetStatusEvent* AppEvent::release_internetstatus() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.internetStatus)
  if (_internal_has_internetstatus()) {
    clear_has_event();
      ::grpc::InternetStatusEvent* temp = event_.internetstatus_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.internetstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::InternetStatusEvent& AppEvent::_internal_internetstatus() const {
  return _internal_has_internetstatus()
      ? *event_.internetstatus_
      : reinterpret_cast< ::grpc::InternetStatusEvent&>(::grpc::_InternetStatusEvent_default_instance_);
}
inline const ::grpc::InternetStatusEvent& AppEvent::internetstatus() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.internetStatus)
  return _internal_internetstatus();
}
inline ::grpc::InternetStatusEvent* AppEvent::unsafe_arena_release_internetstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.internetStatus)
  if (_internal_has_internetstatus()) {
    clear_has_event();
    ::grpc::InternetStatusEvent* temp = event_.internetstatus_;
    event_.internetstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_internetstatus(::grpc::InternetStatusEvent* internetstatus) {
  clear_event();
  if (internetstatus) {
    set_has_internetstatus();
    event_.internetstatus_ = internetstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.internetStatus)
}
inline ::grpc::InternetStatusEvent* AppEvent::_internal_mutable_internetstatus() {
  if (!_internal_has_internetstatus()) {
    clear_event();
    set_has_internetstatus();
    event_.internetstatus_ = CreateMaybeMessage< ::grpc::InternetStatusEvent >(GetArenaForAllocation());
  }
  return event_.internetstatus_;
}
inline ::grpc::InternetStatusEvent* AppEvent::mutable_internetstatus() {
  ::grpc::InternetStatusEvent* _msg = _internal_mutable_internetstatus();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.internetStatus)
  return _msg;
}

// .grpc.ToggleAutostartFinishedEvent toggleAutostartFinished = 2;
inline bool AppEvent::_internal_has_toggleautostartfinished() const {
  return event_case() == kToggleAutostartFinished;
}
inline bool AppEvent::has_toggleautostartfinished() const {
  return _internal_has_toggleautostartfinished();
}
inline void AppEvent::set_has_toggleautostartfinished() {
  _oneof_case_[0] = kToggleAutostartFinished;
}
inline void AppEvent::clear_toggleautostartfinished() {
  if (_internal_has_toggleautostartfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.toggleautostartfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::release_toggleautostartfinished() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.toggleAutostartFinished)
  if (_internal_has_toggleautostartfinished()) {
    clear_has_event();
      ::grpc::ToggleAutostartFinishedEvent* temp = event_.toggleautostartfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.toggleautostartfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ToggleAutostartFinishedEvent& AppEvent::_internal_toggleautostartfinished() const {
  return _internal_has_toggleautostartfinished()
      ? *event_.toggleautostartfinished_
      : reinterpret_cast< ::grpc::ToggleAutostartFinishedEvent&>(::grpc::_ToggleAutostartFinishedEvent_default_instance_);
}
inline const ::grpc::ToggleAutostartFinishedEvent& AppEvent::toggleautostartfinished() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.toggleAutostartFinished)
  return _internal_toggleautostartfinished();
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::unsafe_arena_release_toggleautostartfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.toggleAutostartFinished)
  if (_internal_has_toggleautostartfinished()) {
    clear_has_event();
    ::grpc::ToggleAutostartFinishedEvent* temp = event_.toggleautostartfinished_;
    event_.toggleautostartfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_toggleautostartfinished(::grpc::ToggleAutostartFinishedEvent* toggleautostartfinished) {
  clear_event();
  if (toggleautostartfinished) {
    set_has_toggleautostartfinished();
    event_.toggleautostartfinished_ = toggleautostartfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.toggleAutostartFinished)
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::_internal_mutable_toggleautostartfinished() {
  if (!_internal_has_toggleautostartfinished()) {
    clear_event();
    set_has_toggleautostartfinished();
    event_.toggleautostartfinished_ = CreateMaybeMessage< ::grpc::ToggleAutostartFinishedEvent >(GetArenaForAllocation());
  }
  return event_.toggleautostartfinished_;
}
inline ::grpc::ToggleAutostartFinishedEvent* AppEvent::mutable_toggleautostartfinished() {
  ::grpc::ToggleAutostartFinishedEvent* _msg = _internal_mutable_toggleautostartfinished();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.toggleAutostartFinished)
  return _msg;
}

// .grpc.ResetFinishedEvent resetFinished = 3;
inline bool AppEvent::_internal_has_resetfinished() const {
  return event_case() == kResetFinished;
}
inline bool AppEvent::has_resetfinished() const {
  return _internal_has_resetfinished();
}
inline void AppEvent::set_has_resetfinished() {
  _oneof_case_[0] = kResetFinished;
}
inline void AppEvent::clear_resetfinished() {
  if (_internal_has_resetfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.resetfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ResetFinishedEvent* AppEvent::release_resetfinished() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.resetFinished)
  if (_internal_has_resetfinished()) {
    clear_has_event();
      ::grpc::ResetFinishedEvent* temp = event_.resetfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.resetfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ResetFinishedEvent& AppEvent::_internal_resetfinished() const {
  return _internal_has_resetfinished()
      ? *event_.resetfinished_
      : reinterpret_cast< ::grpc::ResetFinishedEvent&>(::grpc::_ResetFinishedEvent_default_instance_);
}
inline const ::grpc::ResetFinishedEvent& AppEvent::resetfinished() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.resetFinished)
  return _internal_resetfinished();
}
inline ::grpc::ResetFinishedEvent* AppEvent::unsafe_arena_release_resetfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.resetFinished)
  if (_internal_has_resetfinished()) {
    clear_has_event();
    ::grpc::ResetFinishedEvent* temp = event_.resetfinished_;
    event_.resetfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_resetfinished(::grpc::ResetFinishedEvent* resetfinished) {
  clear_event();
  if (resetfinished) {
    set_has_resetfinished();
    event_.resetfinished_ = resetfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.resetFinished)
}
inline ::grpc::ResetFinishedEvent* AppEvent::_internal_mutable_resetfinished() {
  if (!_internal_has_resetfinished()) {
    clear_event();
    set_has_resetfinished();
    event_.resetfinished_ = CreateMaybeMessage< ::grpc::ResetFinishedEvent >(GetArenaForAllocation());
  }
  return event_.resetfinished_;
}
inline ::grpc::ResetFinishedEvent* AppEvent::mutable_resetfinished() {
  ::grpc::ResetFinishedEvent* _msg = _internal_mutable_resetfinished();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.resetFinished)
  return _msg;
}

// .grpc.ReportBugFinishedEvent reportBugFinished = 4;
inline bool AppEvent::_internal_has_reportbugfinished() const {
  return event_case() == kReportBugFinished;
}
inline bool AppEvent::has_reportbugfinished() const {
  return _internal_has_reportbugfinished();
}
inline void AppEvent::set_has_reportbugfinished() {
  _oneof_case_[0] = kReportBugFinished;
}
inline void AppEvent::clear_reportbugfinished() {
  if (_internal_has_reportbugfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.reportbugfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::release_reportbugfinished() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.reportBugFinished)
  if (_internal_has_reportbugfinished()) {
    clear_has_event();
      ::grpc::ReportBugFinishedEvent* temp = event_.reportbugfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.reportbugfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ReportBugFinishedEvent& AppEvent::_internal_reportbugfinished() const {
  return _internal_has_reportbugfinished()
      ? *event_.reportbugfinished_
      : reinterpret_cast< ::grpc::ReportBugFinishedEvent&>(::grpc::_ReportBugFinishedEvent_default_instance_);
}
inline const ::grpc::ReportBugFinishedEvent& AppEvent::reportbugfinished() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.reportBugFinished)
  return _internal_reportbugfinished();
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::unsafe_arena_release_reportbugfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.reportBugFinished)
  if (_internal_has_reportbugfinished()) {
    clear_has_event();
    ::grpc::ReportBugFinishedEvent* temp = event_.reportbugfinished_;
    event_.reportbugfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_reportbugfinished(::grpc::ReportBugFinishedEvent* reportbugfinished) {
  clear_event();
  if (reportbugfinished) {
    set_has_reportbugfinished();
    event_.reportbugfinished_ = reportbugfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.reportBugFinished)
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::_internal_mutable_reportbugfinished() {
  if (!_internal_has_reportbugfinished()) {
    clear_event();
    set_has_reportbugfinished();
    event_.reportbugfinished_ = CreateMaybeMessage< ::grpc::ReportBugFinishedEvent >(GetArenaForAllocation());
  }
  return event_.reportbugfinished_;
}
inline ::grpc::ReportBugFinishedEvent* AppEvent::mutable_reportbugfinished() {
  ::grpc::ReportBugFinishedEvent* _msg = _internal_mutable_reportbugfinished();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.reportBugFinished)
  return _msg;
}

// .grpc.ReportBugSuccessEvent reportBugSuccess = 5;
inline bool AppEvent::_internal_has_reportbugsuccess() const {
  return event_case() == kReportBugSuccess;
}
inline bool AppEvent::has_reportbugsuccess() const {
  return _internal_has_reportbugsuccess();
}
inline void AppEvent::set_has_reportbugsuccess() {
  _oneof_case_[0] = kReportBugSuccess;
}
inline void AppEvent::clear_reportbugsuccess() {
  if (_internal_has_reportbugsuccess()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.reportbugsuccess_;
    }
    clear_has_event();
  }
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::release_reportbugsuccess() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.reportBugSuccess)
  if (_internal_has_reportbugsuccess()) {
    clear_has_event();
      ::grpc::ReportBugSuccessEvent* temp = event_.reportbugsuccess_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.reportbugsuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ReportBugSuccessEvent& AppEvent::_internal_reportbugsuccess() const {
  return _internal_has_reportbugsuccess()
      ? *event_.reportbugsuccess_
      : reinterpret_cast< ::grpc::ReportBugSuccessEvent&>(::grpc::_ReportBugSuccessEvent_default_instance_);
}
inline const ::grpc::ReportBugSuccessEvent& AppEvent::reportbugsuccess() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.reportBugSuccess)
  return _internal_reportbugsuccess();
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::unsafe_arena_release_reportbugsuccess() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.reportBugSuccess)
  if (_internal_has_reportbugsuccess()) {
    clear_has_event();
    ::grpc::ReportBugSuccessEvent* temp = event_.reportbugsuccess_;
    event_.reportbugsuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_reportbugsuccess(::grpc::ReportBugSuccessEvent* reportbugsuccess) {
  clear_event();
  if (reportbugsuccess) {
    set_has_reportbugsuccess();
    event_.reportbugsuccess_ = reportbugsuccess;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.reportBugSuccess)
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::_internal_mutable_reportbugsuccess() {
  if (!_internal_has_reportbugsuccess()) {
    clear_event();
    set_has_reportbugsuccess();
    event_.reportbugsuccess_ = CreateMaybeMessage< ::grpc::ReportBugSuccessEvent >(GetArenaForAllocation());
  }
  return event_.reportbugsuccess_;
}
inline ::grpc::ReportBugSuccessEvent* AppEvent::mutable_reportbugsuccess() {
  ::grpc::ReportBugSuccessEvent* _msg = _internal_mutable_reportbugsuccess();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.reportBugSuccess)
  return _msg;
}

// .grpc.ReportBugErrorEvent reportBugError = 6;
inline bool AppEvent::_internal_has_reportbugerror() const {
  return event_case() == kReportBugError;
}
inline bool AppEvent::has_reportbugerror() const {
  return _internal_has_reportbugerror();
}
inline void AppEvent::set_has_reportbugerror() {
  _oneof_case_[0] = kReportBugError;
}
inline void AppEvent::clear_reportbugerror() {
  if (_internal_has_reportbugerror()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.reportbugerror_;
    }
    clear_has_event();
  }
}
inline ::grpc::ReportBugErrorEvent* AppEvent::release_reportbugerror() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.reportBugError)
  if (_internal_has_reportbugerror()) {
    clear_has_event();
      ::grpc::ReportBugErrorEvent* temp = event_.reportbugerror_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.reportbugerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ReportBugErrorEvent& AppEvent::_internal_reportbugerror() const {
  return _internal_has_reportbugerror()
      ? *event_.reportbugerror_
      : reinterpret_cast< ::grpc::ReportBugErrorEvent&>(::grpc::_ReportBugErrorEvent_default_instance_);
}
inline const ::grpc::ReportBugErrorEvent& AppEvent::reportbugerror() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.reportBugError)
  return _internal_reportbugerror();
}
inline ::grpc::ReportBugErrorEvent* AppEvent::unsafe_arena_release_reportbugerror() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.reportBugError)
  if (_internal_has_reportbugerror()) {
    clear_has_event();
    ::grpc::ReportBugErrorEvent* temp = event_.reportbugerror_;
    event_.reportbugerror_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_reportbugerror(::grpc::ReportBugErrorEvent* reportbugerror) {
  clear_event();
  if (reportbugerror) {
    set_has_reportbugerror();
    event_.reportbugerror_ = reportbugerror;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.reportBugError)
}
inline ::grpc::ReportBugErrorEvent* AppEvent::_internal_mutable_reportbugerror() {
  if (!_internal_has_reportbugerror()) {
    clear_event();
    set_has_reportbugerror();
    event_.reportbugerror_ = CreateMaybeMessage< ::grpc::ReportBugErrorEvent >(GetArenaForAllocation());
  }
  return event_.reportbugerror_;
}
inline ::grpc::ReportBugErrorEvent* AppEvent::mutable_reportbugerror() {
  ::grpc::ReportBugErrorEvent* _msg = _internal_mutable_reportbugerror();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.reportBugError)
  return _msg;
}

// .grpc.ShowMainWindowEvent showMainWindow = 7;
inline bool AppEvent::_internal_has_showmainwindow() const {
  return event_case() == kShowMainWindow;
}
inline bool AppEvent::has_showmainwindow() const {
  return _internal_has_showmainwindow();
}
inline void AppEvent::set_has_showmainwindow() {
  _oneof_case_[0] = kShowMainWindow;
}
inline void AppEvent::clear_showmainwindow() {
  if (_internal_has_showmainwindow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.showmainwindow_;
    }
    clear_has_event();
  }
}
inline ::grpc::ShowMainWindowEvent* AppEvent::release_showmainwindow() {
  // @@protoc_insertion_point(field_release:grpc.AppEvent.showMainWindow)
  if (_internal_has_showmainwindow()) {
    clear_has_event();
      ::grpc::ShowMainWindowEvent* temp = event_.showmainwindow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.showmainwindow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ShowMainWindowEvent& AppEvent::_internal_showmainwindow() const {
  return _internal_has_showmainwindow()
      ? *event_.showmainwindow_
      : reinterpret_cast< ::grpc::ShowMainWindowEvent&>(::grpc::_ShowMainWindowEvent_default_instance_);
}
inline const ::grpc::ShowMainWindowEvent& AppEvent::showmainwindow() const {
  // @@protoc_insertion_point(field_get:grpc.AppEvent.showMainWindow)
  return _internal_showmainwindow();
}
inline ::grpc::ShowMainWindowEvent* AppEvent::unsafe_arena_release_showmainwindow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.AppEvent.showMainWindow)
  if (_internal_has_showmainwindow()) {
    clear_has_event();
    ::grpc::ShowMainWindowEvent* temp = event_.showmainwindow_;
    event_.showmainwindow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AppEvent::unsafe_arena_set_allocated_showmainwindow(::grpc::ShowMainWindowEvent* showmainwindow) {
  clear_event();
  if (showmainwindow) {
    set_has_showmainwindow();
    event_.showmainwindow_ = showmainwindow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.AppEvent.showMainWindow)
}
inline ::grpc::ShowMainWindowEvent* AppEvent::_internal_mutable_showmainwindow() {
  if (!_internal_has_showmainwindow()) {
    clear_event();
    set_has_showmainwindow();
    event_.showmainwindow_ = CreateMaybeMessage< ::grpc::ShowMainWindowEvent >(GetArenaForAllocation());
  }
  return event_.showmainwindow_;
}
inline ::grpc::ShowMainWindowEvent* AppEvent::mutable_showmainwindow() {
  ::grpc::ShowMainWindowEvent* _msg = _internal_mutable_showmainwindow();
  // @@protoc_insertion_point(field_mutable:grpc.AppEvent.showMainWindow)
  return _msg;
}

inline bool AppEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void AppEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline AppEvent::EventCase AppEvent::event_case() const {
  return AppEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternetStatusEvent

// bool connected = 1;
inline void InternetStatusEvent::clear_connected() {
  connected_ = false;
}
inline bool InternetStatusEvent::_internal_connected() const {
  return connected_;
}
inline bool InternetStatusEvent::connected() const {
  // @@protoc_insertion_point(field_get:grpc.InternetStatusEvent.connected)
  return _internal_connected();
}
inline void InternetStatusEvent::_internal_set_connected(bool value) {
  
  connected_ = value;
}
inline void InternetStatusEvent::set_connected(bool value) {
  _internal_set_connected(value);
  // @@protoc_insertion_point(field_set:grpc.InternetStatusEvent.connected)
}

// -------------------------------------------------------------------

// ToggleAutostartFinishedEvent

// -------------------------------------------------------------------

// ResetFinishedEvent

// -------------------------------------------------------------------

// ReportBugFinishedEvent

// -------------------------------------------------------------------

// ReportBugSuccessEvent

// -------------------------------------------------------------------

// ReportBugErrorEvent

// -------------------------------------------------------------------

// ShowMainWindowEvent

// -------------------------------------------------------------------

// LoginEvent

// .grpc.LoginErrorEvent error = 1;
inline bool LoginEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool LoginEvent::has_error() const {
  return _internal_has_error();
}
inline void LoginEvent::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void LoginEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginErrorEvent* LoginEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
      ::grpc::LoginErrorEvent* temp = event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginErrorEvent& LoginEvent::_internal_error() const {
  return _internal_has_error()
      ? *event_.error_
      : reinterpret_cast< ::grpc::LoginErrorEvent&>(::grpc::_LoginErrorEvent_default_instance_);
}
inline const ::grpc::LoginErrorEvent& LoginEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.error)
  return _internal_error();
}
inline ::grpc::LoginErrorEvent* LoginEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::LoginErrorEvent* temp = event_.error_;
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_error(::grpc::LoginErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.error)
}
inline ::grpc::LoginErrorEvent* LoginEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    event_.error_ = CreateMaybeMessage< ::grpc::LoginErrorEvent >(GetArenaForAllocation());
  }
  return event_.error_;
}
inline ::grpc::LoginErrorEvent* LoginEvent::mutable_error() {
  ::grpc::LoginErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.error)
  return _msg;
}

// .grpc.LoginTfaRequestedEvent tfaRequested = 2;
inline bool LoginEvent::_internal_has_tfarequested() const {
  return event_case() == kTfaRequested;
}
inline bool LoginEvent::has_tfarequested() const {
  return _internal_has_tfarequested();
}
inline void LoginEvent::set_has_tfarequested() {
  _oneof_case_[0] = kTfaRequested;
}
inline void LoginEvent::clear_tfarequested() {
  if (_internal_has_tfarequested()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.tfarequested_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::release_tfarequested() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.tfaRequested)
  if (_internal_has_tfarequested()) {
    clear_has_event();
      ::grpc::LoginTfaRequestedEvent* temp = event_.tfarequested_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.tfarequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginTfaRequestedEvent& LoginEvent::_internal_tfarequested() const {
  return _internal_has_tfarequested()
      ? *event_.tfarequested_
      : reinterpret_cast< ::grpc::LoginTfaRequestedEvent&>(::grpc::_LoginTfaRequestedEvent_default_instance_);
}
inline const ::grpc::LoginTfaRequestedEvent& LoginEvent::tfarequested() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.tfaRequested)
  return _internal_tfarequested();
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::unsafe_arena_release_tfarequested() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.tfaRequested)
  if (_internal_has_tfarequested()) {
    clear_has_event();
    ::grpc::LoginTfaRequestedEvent* temp = event_.tfarequested_;
    event_.tfarequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_tfarequested(::grpc::LoginTfaRequestedEvent* tfarequested) {
  clear_event();
  if (tfarequested) {
    set_has_tfarequested();
    event_.tfarequested_ = tfarequested;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.tfaRequested)
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::_internal_mutable_tfarequested() {
  if (!_internal_has_tfarequested()) {
    clear_event();
    set_has_tfarequested();
    event_.tfarequested_ = CreateMaybeMessage< ::grpc::LoginTfaRequestedEvent >(GetArenaForAllocation());
  }
  return event_.tfarequested_;
}
inline ::grpc::LoginTfaRequestedEvent* LoginEvent::mutable_tfarequested() {
  ::grpc::LoginTfaRequestedEvent* _msg = _internal_mutable_tfarequested();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.tfaRequested)
  return _msg;
}

// .grpc.LoginTwoPasswordsRequestedEvent twoPasswordRequested = 3;
inline bool LoginEvent::_internal_has_twopasswordrequested() const {
  return event_case() == kTwoPasswordRequested;
}
inline bool LoginEvent::has_twopasswordrequested() const {
  return _internal_has_twopasswordrequested();
}
inline void LoginEvent::set_has_twopasswordrequested() {
  _oneof_case_[0] = kTwoPasswordRequested;
}
inline void LoginEvent::clear_twopasswordrequested() {
  if (_internal_has_twopasswordrequested()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.twopasswordrequested_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::release_twopasswordrequested() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.twoPasswordRequested)
  if (_internal_has_twopasswordrequested()) {
    clear_has_event();
      ::grpc::LoginTwoPasswordsRequestedEvent* temp = event_.twopasswordrequested_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.twopasswordrequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginTwoPasswordsRequestedEvent& LoginEvent::_internal_twopasswordrequested() const {
  return _internal_has_twopasswordrequested()
      ? *event_.twopasswordrequested_
      : reinterpret_cast< ::grpc::LoginTwoPasswordsRequestedEvent&>(::grpc::_LoginTwoPasswordsRequestedEvent_default_instance_);
}
inline const ::grpc::LoginTwoPasswordsRequestedEvent& LoginEvent::twopasswordrequested() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.twoPasswordRequested)
  return _internal_twopasswordrequested();
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::unsafe_arena_release_twopasswordrequested() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.twoPasswordRequested)
  if (_internal_has_twopasswordrequested()) {
    clear_has_event();
    ::grpc::LoginTwoPasswordsRequestedEvent* temp = event_.twopasswordrequested_;
    event_.twopasswordrequested_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_twopasswordrequested(::grpc::LoginTwoPasswordsRequestedEvent* twopasswordrequested) {
  clear_event();
  if (twopasswordrequested) {
    set_has_twopasswordrequested();
    event_.twopasswordrequested_ = twopasswordrequested;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.twoPasswordRequested)
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::_internal_mutable_twopasswordrequested() {
  if (!_internal_has_twopasswordrequested()) {
    clear_event();
    set_has_twopasswordrequested();
    event_.twopasswordrequested_ = CreateMaybeMessage< ::grpc::LoginTwoPasswordsRequestedEvent >(GetArenaForAllocation());
  }
  return event_.twopasswordrequested_;
}
inline ::grpc::LoginTwoPasswordsRequestedEvent* LoginEvent::mutable_twopasswordrequested() {
  ::grpc::LoginTwoPasswordsRequestedEvent* _msg = _internal_mutable_twopasswordrequested();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.twoPasswordRequested)
  return _msg;
}

// .grpc.LoginFinishedEvent finished = 4;
inline bool LoginEvent::_internal_has_finished() const {
  return event_case() == kFinished;
}
inline bool LoginEvent::has_finished() const {
  return _internal_has_finished();
}
inline void LoginEvent::set_has_finished() {
  _oneof_case_[0] = kFinished;
}
inline void LoginEvent::clear_finished() {
  if (_internal_has_finished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.finished_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginFinishedEvent* LoginEvent::release_finished() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.finished)
  if (_internal_has_finished()) {
    clear_has_event();
      ::grpc::LoginFinishedEvent* temp = event_.finished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.finished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::_internal_finished() const {
  return _internal_has_finished()
      ? *event_.finished_
      : reinterpret_cast< ::grpc::LoginFinishedEvent&>(::grpc::_LoginFinishedEvent_default_instance_);
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::finished() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.finished)
  return _internal_finished();
}
inline ::grpc::LoginFinishedEvent* LoginEvent::unsafe_arena_release_finished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.finished)
  if (_internal_has_finished()) {
    clear_has_event();
    ::grpc::LoginFinishedEvent* temp = event_.finished_;
    event_.finished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_finished(::grpc::LoginFinishedEvent* finished) {
  clear_event();
  if (finished) {
    set_has_finished();
    event_.finished_ = finished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.finished)
}
inline ::grpc::LoginFinishedEvent* LoginEvent::_internal_mutable_finished() {
  if (!_internal_has_finished()) {
    clear_event();
    set_has_finished();
    event_.finished_ = CreateMaybeMessage< ::grpc::LoginFinishedEvent >(GetArenaForAllocation());
  }
  return event_.finished_;
}
inline ::grpc::LoginFinishedEvent* LoginEvent::mutable_finished() {
  ::grpc::LoginFinishedEvent* _msg = _internal_mutable_finished();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.finished)
  return _msg;
}

// .grpc.LoginFinishedEvent alreadyLoggedIn = 5;
inline bool LoginEvent::_internal_has_alreadyloggedin() const {
  return event_case() == kAlreadyLoggedIn;
}
inline bool LoginEvent::has_alreadyloggedin() const {
  return _internal_has_alreadyloggedin();
}
inline void LoginEvent::set_has_alreadyloggedin() {
  _oneof_case_[0] = kAlreadyLoggedIn;
}
inline void LoginEvent::clear_alreadyloggedin() {
  if (_internal_has_alreadyloggedin()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.alreadyloggedin_;
    }
    clear_has_event();
  }
}
inline ::grpc::LoginFinishedEvent* LoginEvent::release_alreadyloggedin() {
  // @@protoc_insertion_point(field_release:grpc.LoginEvent.alreadyLoggedIn)
  if (_internal_has_alreadyloggedin()) {
    clear_has_event();
      ::grpc::LoginFinishedEvent* temp = event_.alreadyloggedin_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.alreadyloggedin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::_internal_alreadyloggedin() const {
  return _internal_has_alreadyloggedin()
      ? *event_.alreadyloggedin_
      : reinterpret_cast< ::grpc::LoginFinishedEvent&>(::grpc::_LoginFinishedEvent_default_instance_);
}
inline const ::grpc::LoginFinishedEvent& LoginEvent::alreadyloggedin() const {
  // @@protoc_insertion_point(field_get:grpc.LoginEvent.alreadyLoggedIn)
  return _internal_alreadyloggedin();
}
inline ::grpc::LoginFinishedEvent* LoginEvent::unsafe_arena_release_alreadyloggedin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.LoginEvent.alreadyLoggedIn)
  if (_internal_has_alreadyloggedin()) {
    clear_has_event();
    ::grpc::LoginFinishedEvent* temp = event_.alreadyloggedin_;
    event_.alreadyloggedin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginEvent::unsafe_arena_set_allocated_alreadyloggedin(::grpc::LoginFinishedEvent* alreadyloggedin) {
  clear_event();
  if (alreadyloggedin) {
    set_has_alreadyloggedin();
    event_.alreadyloggedin_ = alreadyloggedin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.LoginEvent.alreadyLoggedIn)
}
inline ::grpc::LoginFinishedEvent* LoginEvent::_internal_mutable_alreadyloggedin() {
  if (!_internal_has_alreadyloggedin()) {
    clear_event();
    set_has_alreadyloggedin();
    event_.alreadyloggedin_ = CreateMaybeMessage< ::grpc::LoginFinishedEvent >(GetArenaForAllocation());
  }
  return event_.alreadyloggedin_;
}
inline ::grpc::LoginFinishedEvent* LoginEvent::mutable_alreadyloggedin() {
  ::grpc::LoginFinishedEvent* _msg = _internal_mutable_alreadyloggedin();
  // @@protoc_insertion_point(field_mutable:grpc.LoginEvent.alreadyLoggedIn)
  return _msg;
}

inline bool LoginEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void LoginEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline LoginEvent::EventCase LoginEvent::event_case() const {
  return LoginEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginErrorEvent

// .grpc.LoginErrorType type = 1;
inline void LoginErrorEvent::clear_type() {
  type_ = 0;
}
inline ::grpc::LoginErrorType LoginErrorEvent::_internal_type() const {
  return static_cast< ::grpc::LoginErrorType >(type_);
}
inline ::grpc::LoginErrorType LoginErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.LoginErrorEvent.type)
  return _internal_type();
}
inline void LoginErrorEvent::_internal_set_type(::grpc::LoginErrorType value) {
  
  type_ = value;
}
inline void LoginErrorEvent::set_type(::grpc::LoginErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.LoginErrorEvent.type)
}

// string message = 2;
inline void LoginErrorEvent::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& LoginErrorEvent::message() const {
  // @@protoc_insertion_point(field_get:grpc.LoginErrorEvent.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginErrorEvent::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginErrorEvent.message)
}
inline std::string* LoginErrorEvent::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:grpc.LoginErrorEvent.message)
  return _s;
}
inline const std::string& LoginErrorEvent::_internal_message() const {
  return message_.Get();
}
inline void LoginErrorEvent::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginErrorEvent::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginErrorEvent::release_message() {
  // @@protoc_insertion_point(field_release:grpc.LoginErrorEvent.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginErrorEvent::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginErrorEvent.message)
}

// -------------------------------------------------------------------

// LoginTfaRequestedEvent

// string username = 1;
inline void LoginTfaRequestedEvent::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& LoginTfaRequestedEvent::username() const {
  // @@protoc_insertion_point(field_get:grpc.LoginTfaRequestedEvent.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginTfaRequestedEvent::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginTfaRequestedEvent.username)
}
inline std::string* LoginTfaRequestedEvent::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.LoginTfaRequestedEvent.username)
  return _s;
}
inline const std::string& LoginTfaRequestedEvent::_internal_username() const {
  return username_.Get();
}
inline void LoginTfaRequestedEvent::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginTfaRequestedEvent::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginTfaRequestedEvent::release_username() {
  // @@protoc_insertion_point(field_release:grpc.LoginTfaRequestedEvent.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginTfaRequestedEvent::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginTfaRequestedEvent.username)
}

// -------------------------------------------------------------------

// LoginTwoPasswordsRequestedEvent

// -------------------------------------------------------------------

// LoginFinishedEvent

// string userID = 1;
inline void LoginFinishedEvent::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& LoginFinishedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.LoginFinishedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginFinishedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.LoginFinishedEvent.userID)
}
inline std::string* LoginFinishedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.LoginFinishedEvent.userID)
  return _s;
}
inline const std::string& LoginFinishedEvent::_internal_userid() const {
  return userid_.Get();
}
inline void LoginFinishedEvent::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginFinishedEvent::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginFinishedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.LoginFinishedEvent.userID)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginFinishedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.LoginFinishedEvent.userID)
}

// -------------------------------------------------------------------

// UpdateEvent

// .grpc.UpdateErrorEvent error = 1;
inline bool UpdateEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool UpdateEvent::has_error() const {
  return _internal_has_error();
}
inline void UpdateEvent::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void UpdateEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
      ::grpc::UpdateErrorEvent* temp = event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateErrorEvent& UpdateEvent::_internal_error() const {
  return _internal_has_error()
      ? *event_.error_
      : reinterpret_cast< ::grpc::UpdateErrorEvent&>(::grpc::_UpdateErrorEvent_default_instance_);
}
inline const ::grpc::UpdateErrorEvent& UpdateEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.error)
  return _internal_error();
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::UpdateErrorEvent* temp = event_.error_;
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_error(::grpc::UpdateErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.error)
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    event_.error_ = CreateMaybeMessage< ::grpc::UpdateErrorEvent >(GetArenaForAllocation());
  }
  return event_.error_;
}
inline ::grpc::UpdateErrorEvent* UpdateEvent::mutable_error() {
  ::grpc::UpdateErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.error)
  return _msg;
}

// .grpc.UpdateManualReadyEvent manualReady = 2;
inline bool UpdateEvent::_internal_has_manualready() const {
  return event_case() == kManualReady;
}
inline bool UpdateEvent::has_manualready() const {
  return _internal_has_manualready();
}
inline void UpdateEvent::set_has_manualready() {
  _oneof_case_[0] = kManualReady;
}
inline void UpdateEvent::clear_manualready() {
  if (_internal_has_manualready()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.manualready_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::release_manualready() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.manualReady)
  if (_internal_has_manualready()) {
    clear_has_event();
      ::grpc::UpdateManualReadyEvent* temp = event_.manualready_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.manualready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateManualReadyEvent& UpdateEvent::_internal_manualready() const {
  return _internal_has_manualready()
      ? *event_.manualready_
      : reinterpret_cast< ::grpc::UpdateManualReadyEvent&>(::grpc::_UpdateManualReadyEvent_default_instance_);
}
inline const ::grpc::UpdateManualReadyEvent& UpdateEvent::manualready() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.manualReady)
  return _internal_manualready();
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::unsafe_arena_release_manualready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.manualReady)
  if (_internal_has_manualready()) {
    clear_has_event();
    ::grpc::UpdateManualReadyEvent* temp = event_.manualready_;
    event_.manualready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_manualready(::grpc::UpdateManualReadyEvent* manualready) {
  clear_event();
  if (manualready) {
    set_has_manualready();
    event_.manualready_ = manualready;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.manualReady)
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::_internal_mutable_manualready() {
  if (!_internal_has_manualready()) {
    clear_event();
    set_has_manualready();
    event_.manualready_ = CreateMaybeMessage< ::grpc::UpdateManualReadyEvent >(GetArenaForAllocation());
  }
  return event_.manualready_;
}
inline ::grpc::UpdateManualReadyEvent* UpdateEvent::mutable_manualready() {
  ::grpc::UpdateManualReadyEvent* _msg = _internal_mutable_manualready();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.manualReady)
  return _msg;
}

// .grpc.UpdateManualRestartNeededEvent manualRestartNeeded = 3;
inline bool UpdateEvent::_internal_has_manualrestartneeded() const {
  return event_case() == kManualRestartNeeded;
}
inline bool UpdateEvent::has_manualrestartneeded() const {
  return _internal_has_manualrestartneeded();
}
inline void UpdateEvent::set_has_manualrestartneeded() {
  _oneof_case_[0] = kManualRestartNeeded;
}
inline void UpdateEvent::clear_manualrestartneeded() {
  if (_internal_has_manualrestartneeded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.manualrestartneeded_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::release_manualrestartneeded() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.manualRestartNeeded)
  if (_internal_has_manualrestartneeded()) {
    clear_has_event();
      ::grpc::UpdateManualRestartNeededEvent* temp = event_.manualrestartneeded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.manualrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateManualRestartNeededEvent& UpdateEvent::_internal_manualrestartneeded() const {
  return _internal_has_manualrestartneeded()
      ? *event_.manualrestartneeded_
      : reinterpret_cast< ::grpc::UpdateManualRestartNeededEvent&>(::grpc::_UpdateManualRestartNeededEvent_default_instance_);
}
inline const ::grpc::UpdateManualRestartNeededEvent& UpdateEvent::manualrestartneeded() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.manualRestartNeeded)
  return _internal_manualrestartneeded();
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::unsafe_arena_release_manualrestartneeded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.manualRestartNeeded)
  if (_internal_has_manualrestartneeded()) {
    clear_has_event();
    ::grpc::UpdateManualRestartNeededEvent* temp = event_.manualrestartneeded_;
    event_.manualrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_manualrestartneeded(::grpc::UpdateManualRestartNeededEvent* manualrestartneeded) {
  clear_event();
  if (manualrestartneeded) {
    set_has_manualrestartneeded();
    event_.manualrestartneeded_ = manualrestartneeded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.manualRestartNeeded)
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::_internal_mutable_manualrestartneeded() {
  if (!_internal_has_manualrestartneeded()) {
    clear_event();
    set_has_manualrestartneeded();
    event_.manualrestartneeded_ = CreateMaybeMessage< ::grpc::UpdateManualRestartNeededEvent >(GetArenaForAllocation());
  }
  return event_.manualrestartneeded_;
}
inline ::grpc::UpdateManualRestartNeededEvent* UpdateEvent::mutable_manualrestartneeded() {
  ::grpc::UpdateManualRestartNeededEvent* _msg = _internal_mutable_manualrestartneeded();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.manualRestartNeeded)
  return _msg;
}

// .grpc.UpdateForceEvent force = 4;
inline bool UpdateEvent::_internal_has_force() const {
  return event_case() == kForce;
}
inline bool UpdateEvent::has_force() const {
  return _internal_has_force();
}
inline void UpdateEvent::set_has_force() {
  _oneof_case_[0] = kForce;
}
inline void UpdateEvent::clear_force() {
  if (_internal_has_force()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.force_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateForceEvent* UpdateEvent::release_force() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.force)
  if (_internal_has_force()) {
    clear_has_event();
      ::grpc::UpdateForceEvent* temp = event_.force_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.force_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateForceEvent& UpdateEvent::_internal_force() const {
  return _internal_has_force()
      ? *event_.force_
      : reinterpret_cast< ::grpc::UpdateForceEvent&>(::grpc::_UpdateForceEvent_default_instance_);
}
inline const ::grpc::UpdateForceEvent& UpdateEvent::force() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.force)
  return _internal_force();
}
inline ::grpc::UpdateForceEvent* UpdateEvent::unsafe_arena_release_force() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.force)
  if (_internal_has_force()) {
    clear_has_event();
    ::grpc::UpdateForceEvent* temp = event_.force_;
    event_.force_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_force(::grpc::UpdateForceEvent* force) {
  clear_event();
  if (force) {
    set_has_force();
    event_.force_ = force;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.force)
}
inline ::grpc::UpdateForceEvent* UpdateEvent::_internal_mutable_force() {
  if (!_internal_has_force()) {
    clear_event();
    set_has_force();
    event_.force_ = CreateMaybeMessage< ::grpc::UpdateForceEvent >(GetArenaForAllocation());
  }
  return event_.force_;
}
inline ::grpc::UpdateForceEvent* UpdateEvent::mutable_force() {
  ::grpc::UpdateForceEvent* _msg = _internal_mutable_force();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.force)
  return _msg;
}

// .grpc.UpdateSilentRestartNeeded silentRestartNeeded = 5;
inline bool UpdateEvent::_internal_has_silentrestartneeded() const {
  return event_case() == kSilentRestartNeeded;
}
inline bool UpdateEvent::has_silentrestartneeded() const {
  return _internal_has_silentrestartneeded();
}
inline void UpdateEvent::set_has_silentrestartneeded() {
  _oneof_case_[0] = kSilentRestartNeeded;
}
inline void UpdateEvent::clear_silentrestartneeded() {
  if (_internal_has_silentrestartneeded()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.silentrestartneeded_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::release_silentrestartneeded() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.silentRestartNeeded)
  if (_internal_has_silentrestartneeded()) {
    clear_has_event();
      ::grpc::UpdateSilentRestartNeeded* temp = event_.silentrestartneeded_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.silentrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateSilentRestartNeeded& UpdateEvent::_internal_silentrestartneeded() const {
  return _internal_has_silentrestartneeded()
      ? *event_.silentrestartneeded_
      : reinterpret_cast< ::grpc::UpdateSilentRestartNeeded&>(::grpc::_UpdateSilentRestartNeeded_default_instance_);
}
inline const ::grpc::UpdateSilentRestartNeeded& UpdateEvent::silentrestartneeded() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.silentRestartNeeded)
  return _internal_silentrestartneeded();
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::unsafe_arena_release_silentrestartneeded() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.silentRestartNeeded)
  if (_internal_has_silentrestartneeded()) {
    clear_has_event();
    ::grpc::UpdateSilentRestartNeeded* temp = event_.silentrestartneeded_;
    event_.silentrestartneeded_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_silentrestartneeded(::grpc::UpdateSilentRestartNeeded* silentrestartneeded) {
  clear_event();
  if (silentrestartneeded) {
    set_has_silentrestartneeded();
    event_.silentrestartneeded_ = silentrestartneeded;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.silentRestartNeeded)
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::_internal_mutable_silentrestartneeded() {
  if (!_internal_has_silentrestartneeded()) {
    clear_event();
    set_has_silentrestartneeded();
    event_.silentrestartneeded_ = CreateMaybeMessage< ::grpc::UpdateSilentRestartNeeded >(GetArenaForAllocation());
  }
  return event_.silentrestartneeded_;
}
inline ::grpc::UpdateSilentRestartNeeded* UpdateEvent::mutable_silentrestartneeded() {
  ::grpc::UpdateSilentRestartNeeded* _msg = _internal_mutable_silentrestartneeded();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.silentRestartNeeded)
  return _msg;
}

// .grpc.UpdateIsLatestVersion isLatestVersion = 6;
inline bool UpdateEvent::_internal_has_islatestversion() const {
  return event_case() == kIsLatestVersion;
}
inline bool UpdateEvent::has_islatestversion() const {
  return _internal_has_islatestversion();
}
inline void UpdateEvent::set_has_islatestversion() {
  _oneof_case_[0] = kIsLatestVersion;
}
inline void UpdateEvent::clear_islatestversion() {
  if (_internal_has_islatestversion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.islatestversion_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::release_islatestversion() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.isLatestVersion)
  if (_internal_has_islatestversion()) {
    clear_has_event();
      ::grpc::UpdateIsLatestVersion* temp = event_.islatestversion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.islatestversion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateIsLatestVersion& UpdateEvent::_internal_islatestversion() const {
  return _internal_has_islatestversion()
      ? *event_.islatestversion_
      : reinterpret_cast< ::grpc::UpdateIsLatestVersion&>(::grpc::_UpdateIsLatestVersion_default_instance_);
}
inline const ::grpc::UpdateIsLatestVersion& UpdateEvent::islatestversion() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.isLatestVersion)
  return _internal_islatestversion();
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::unsafe_arena_release_islatestversion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.isLatestVersion)
  if (_internal_has_islatestversion()) {
    clear_has_event();
    ::grpc::UpdateIsLatestVersion* temp = event_.islatestversion_;
    event_.islatestversion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_islatestversion(::grpc::UpdateIsLatestVersion* islatestversion) {
  clear_event();
  if (islatestversion) {
    set_has_islatestversion();
    event_.islatestversion_ = islatestversion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.isLatestVersion)
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::_internal_mutable_islatestversion() {
  if (!_internal_has_islatestversion()) {
    clear_event();
    set_has_islatestversion();
    event_.islatestversion_ = CreateMaybeMessage< ::grpc::UpdateIsLatestVersion >(GetArenaForAllocation());
  }
  return event_.islatestversion_;
}
inline ::grpc::UpdateIsLatestVersion* UpdateEvent::mutable_islatestversion() {
  ::grpc::UpdateIsLatestVersion* _msg = _internal_mutable_islatestversion();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.isLatestVersion)
  return _msg;
}

// .grpc.UpdateCheckFinished checkFinished = 7;
inline bool UpdateEvent::_internal_has_checkfinished() const {
  return event_case() == kCheckFinished;
}
inline bool UpdateEvent::has_checkfinished() const {
  return _internal_has_checkfinished();
}
inline void UpdateEvent::set_has_checkfinished() {
  _oneof_case_[0] = kCheckFinished;
}
inline void UpdateEvent::clear_checkfinished() {
  if (_internal_has_checkfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.checkfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::release_checkfinished() {
  // @@protoc_insertion_point(field_release:grpc.UpdateEvent.checkFinished)
  if (_internal_has_checkfinished()) {
    clear_has_event();
      ::grpc::UpdateCheckFinished* temp = event_.checkfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.checkfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UpdateCheckFinished& UpdateEvent::_internal_checkfinished() const {
  return _internal_has_checkfinished()
      ? *event_.checkfinished_
      : reinterpret_cast< ::grpc::UpdateCheckFinished&>(::grpc::_UpdateCheckFinished_default_instance_);
}
inline const ::grpc::UpdateCheckFinished& UpdateEvent::checkfinished() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateEvent.checkFinished)
  return _internal_checkfinished();
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::unsafe_arena_release_checkfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UpdateEvent.checkFinished)
  if (_internal_has_checkfinished()) {
    clear_has_event();
    ::grpc::UpdateCheckFinished* temp = event_.checkfinished_;
    event_.checkfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateEvent::unsafe_arena_set_allocated_checkfinished(::grpc::UpdateCheckFinished* checkfinished) {
  clear_event();
  if (checkfinished) {
    set_has_checkfinished();
    event_.checkfinished_ = checkfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UpdateEvent.checkFinished)
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::_internal_mutable_checkfinished() {
  if (!_internal_has_checkfinished()) {
    clear_event();
    set_has_checkfinished();
    event_.checkfinished_ = CreateMaybeMessage< ::grpc::UpdateCheckFinished >(GetArenaForAllocation());
  }
  return event_.checkfinished_;
}
inline ::grpc::UpdateCheckFinished* UpdateEvent::mutable_checkfinished() {
  ::grpc::UpdateCheckFinished* _msg = _internal_mutable_checkfinished();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateEvent.checkFinished)
  return _msg;
}

inline bool UpdateEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void UpdateEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline UpdateEvent::EventCase UpdateEvent::event_case() const {
  return UpdateEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateErrorEvent

// .grpc.UpdateErrorType type = 1;
inline void UpdateErrorEvent::clear_type() {
  type_ = 0;
}
inline ::grpc::UpdateErrorType UpdateErrorEvent::_internal_type() const {
  return static_cast< ::grpc::UpdateErrorType >(type_);
}
inline ::grpc::UpdateErrorType UpdateErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateErrorEvent.type)
  return _internal_type();
}
inline void UpdateErrorEvent::_internal_set_type(::grpc::UpdateErrorType value) {
  
  type_ = value;
}
inline void UpdateErrorEvent::set_type(::grpc::UpdateErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.UpdateErrorEvent.type)
}

// -------------------------------------------------------------------

// UpdateManualReadyEvent

// string version = 1;
inline void UpdateManualReadyEvent::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& UpdateManualReadyEvent::version() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateManualReadyEvent.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateManualReadyEvent::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UpdateManualReadyEvent.version)
}
inline std::string* UpdateManualReadyEvent::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateManualReadyEvent.version)
  return _s;
}
inline const std::string& UpdateManualReadyEvent::_internal_version() const {
  return version_.Get();
}
inline void UpdateManualReadyEvent::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateManualReadyEvent::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateManualReadyEvent::release_version() {
  // @@protoc_insertion_point(field_release:grpc.UpdateManualReadyEvent.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateManualReadyEvent::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UpdateManualReadyEvent.version)
}

// -------------------------------------------------------------------

// UpdateManualRestartNeededEvent

// -------------------------------------------------------------------

// UpdateForceEvent

// string version = 1;
inline void UpdateForceEvent::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& UpdateForceEvent::version() const {
  // @@protoc_insertion_point(field_get:grpc.UpdateForceEvent.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateForceEvent::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UpdateForceEvent.version)
}
inline std::string* UpdateForceEvent::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:grpc.UpdateForceEvent.version)
  return _s;
}
inline const std::string& UpdateForceEvent::_internal_version() const {
  return version_.Get();
}
inline void UpdateForceEvent::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateForceEvent::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateForceEvent::release_version() {
  // @@protoc_insertion_point(field_release:grpc.UpdateForceEvent.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateForceEvent::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UpdateForceEvent.version)
}

// -------------------------------------------------------------------

// UpdateSilentRestartNeeded

// -------------------------------------------------------------------

// UpdateIsLatestVersion

// -------------------------------------------------------------------

// UpdateCheckFinished

// -------------------------------------------------------------------

// CacheEvent

// .grpc.CacheErrorEvent error = 1;
inline bool CacheEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool CacheEvent::has_error() const {
  return _internal_has_error();
}
inline void CacheEvent::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void CacheEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::CacheErrorEvent* CacheEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.CacheEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
      ::grpc::CacheErrorEvent* temp = event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::CacheErrorEvent& CacheEvent::_internal_error() const {
  return _internal_has_error()
      ? *event_.error_
      : reinterpret_cast< ::grpc::CacheErrorEvent&>(::grpc::_CacheErrorEvent_default_instance_);
}
inline const ::grpc::CacheErrorEvent& CacheEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.CacheEvent.error)
  return _internal_error();
}
inline ::grpc::CacheErrorEvent* CacheEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.CacheEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::CacheErrorEvent* temp = event_.error_;
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CacheEvent::unsafe_arena_set_allocated_error(::grpc::CacheErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.CacheEvent.error)
}
inline ::grpc::CacheErrorEvent* CacheEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    event_.error_ = CreateMaybeMessage< ::grpc::CacheErrorEvent >(GetArenaForAllocation());
  }
  return event_.error_;
}
inline ::grpc::CacheErrorEvent* CacheEvent::mutable_error() {
  ::grpc::CacheErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.CacheEvent.error)
  return _msg;
}

// .grpc.CacheLocationChangeSuccessEvent locationChangedSuccess = 2;
inline bool CacheEvent::_internal_has_locationchangedsuccess() const {
  return event_case() == kLocationChangedSuccess;
}
inline bool CacheEvent::has_locationchangedsuccess() const {
  return _internal_has_locationchangedsuccess();
}
inline void CacheEvent::set_has_locationchangedsuccess() {
  _oneof_case_[0] = kLocationChangedSuccess;
}
inline void CacheEvent::clear_locationchangedsuccess() {
  if (_internal_has_locationchangedsuccess()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.locationchangedsuccess_;
    }
    clear_has_event();
  }
}
inline ::grpc::CacheLocationChangeSuccessEvent* CacheEvent::release_locationchangedsuccess() {
  // @@protoc_insertion_point(field_release:grpc.CacheEvent.locationChangedSuccess)
  if (_internal_has_locationchangedsuccess()) {
    clear_has_event();
      ::grpc::CacheLocationChangeSuccessEvent* temp = event_.locationchangedsuccess_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.locationchangedsuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::CacheLocationChangeSuccessEvent& CacheEvent::_internal_locationchangedsuccess() const {
  return _internal_has_locationchangedsuccess()
      ? *event_.locationchangedsuccess_
      : reinterpret_cast< ::grpc::CacheLocationChangeSuccessEvent&>(::grpc::_CacheLocationChangeSuccessEvent_default_instance_);
}
inline const ::grpc::CacheLocationChangeSuccessEvent& CacheEvent::locationchangedsuccess() const {
  // @@protoc_insertion_point(field_get:grpc.CacheEvent.locationChangedSuccess)
  return _internal_locationchangedsuccess();
}
inline ::grpc::CacheLocationChangeSuccessEvent* CacheEvent::unsafe_arena_release_locationchangedsuccess() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.CacheEvent.locationChangedSuccess)
  if (_internal_has_locationchangedsuccess()) {
    clear_has_event();
    ::grpc::CacheLocationChangeSuccessEvent* temp = event_.locationchangedsuccess_;
    event_.locationchangedsuccess_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CacheEvent::unsafe_arena_set_allocated_locationchangedsuccess(::grpc::CacheLocationChangeSuccessEvent* locationchangedsuccess) {
  clear_event();
  if (locationchangedsuccess) {
    set_has_locationchangedsuccess();
    event_.locationchangedsuccess_ = locationchangedsuccess;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.CacheEvent.locationChangedSuccess)
}
inline ::grpc::CacheLocationChangeSuccessEvent* CacheEvent::_internal_mutable_locationchangedsuccess() {
  if (!_internal_has_locationchangedsuccess()) {
    clear_event();
    set_has_locationchangedsuccess();
    event_.locationchangedsuccess_ = CreateMaybeMessage< ::grpc::CacheLocationChangeSuccessEvent >(GetArenaForAllocation());
  }
  return event_.locationchangedsuccess_;
}
inline ::grpc::CacheLocationChangeSuccessEvent* CacheEvent::mutable_locationchangedsuccess() {
  ::grpc::CacheLocationChangeSuccessEvent* _msg = _internal_mutable_locationchangedsuccess();
  // @@protoc_insertion_point(field_mutable:grpc.CacheEvent.locationChangedSuccess)
  return _msg;
}

// .grpc.ChangeLocalCacheFinishedEvent changeLocalCacheFinished = 3;
inline bool CacheEvent::_internal_has_changelocalcachefinished() const {
  return event_case() == kChangeLocalCacheFinished;
}
inline bool CacheEvent::has_changelocalcachefinished() const {
  return _internal_has_changelocalcachefinished();
}
inline void CacheEvent::set_has_changelocalcachefinished() {
  _oneof_case_[0] = kChangeLocalCacheFinished;
}
inline void CacheEvent::clear_changelocalcachefinished() {
  if (_internal_has_changelocalcachefinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.changelocalcachefinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ChangeLocalCacheFinishedEvent* CacheEvent::release_changelocalcachefinished() {
  // @@protoc_insertion_point(field_release:grpc.CacheEvent.changeLocalCacheFinished)
  if (_internal_has_changelocalcachefinished()) {
    clear_has_event();
      ::grpc::ChangeLocalCacheFinishedEvent* temp = event_.changelocalcachefinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.changelocalcachefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ChangeLocalCacheFinishedEvent& CacheEvent::_internal_changelocalcachefinished() const {
  return _internal_has_changelocalcachefinished()
      ? *event_.changelocalcachefinished_
      : reinterpret_cast< ::grpc::ChangeLocalCacheFinishedEvent&>(::grpc::_ChangeLocalCacheFinishedEvent_default_instance_);
}
inline const ::grpc::ChangeLocalCacheFinishedEvent& CacheEvent::changelocalcachefinished() const {
  // @@protoc_insertion_point(field_get:grpc.CacheEvent.changeLocalCacheFinished)
  return _internal_changelocalcachefinished();
}
inline ::grpc::ChangeLocalCacheFinishedEvent* CacheEvent::unsafe_arena_release_changelocalcachefinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.CacheEvent.changeLocalCacheFinished)
  if (_internal_has_changelocalcachefinished()) {
    clear_has_event();
    ::grpc::ChangeLocalCacheFinishedEvent* temp = event_.changelocalcachefinished_;
    event_.changelocalcachefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CacheEvent::unsafe_arena_set_allocated_changelocalcachefinished(::grpc::ChangeLocalCacheFinishedEvent* changelocalcachefinished) {
  clear_event();
  if (changelocalcachefinished) {
    set_has_changelocalcachefinished();
    event_.changelocalcachefinished_ = changelocalcachefinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.CacheEvent.changeLocalCacheFinished)
}
inline ::grpc::ChangeLocalCacheFinishedEvent* CacheEvent::_internal_mutable_changelocalcachefinished() {
  if (!_internal_has_changelocalcachefinished()) {
    clear_event();
    set_has_changelocalcachefinished();
    event_.changelocalcachefinished_ = CreateMaybeMessage< ::grpc::ChangeLocalCacheFinishedEvent >(GetArenaForAllocation());
  }
  return event_.changelocalcachefinished_;
}
inline ::grpc::ChangeLocalCacheFinishedEvent* CacheEvent::mutable_changelocalcachefinished() {
  ::grpc::ChangeLocalCacheFinishedEvent* _msg = _internal_mutable_changelocalcachefinished();
  // @@protoc_insertion_point(field_mutable:grpc.CacheEvent.changeLocalCacheFinished)
  return _msg;
}

// .grpc.IsCacheOnDiskEnabledChanged isCacheOnDiskEnabledChanged = 4;
inline bool CacheEvent::_internal_has_iscacheondiskenabledchanged() const {
  return event_case() == kIsCacheOnDiskEnabledChanged;
}
inline bool CacheEvent::has_iscacheondiskenabledchanged() const {
  return _internal_has_iscacheondiskenabledchanged();
}
inline void CacheEvent::set_has_iscacheondiskenabledchanged() {
  _oneof_case_[0] = kIsCacheOnDiskEnabledChanged;
}
inline void CacheEvent::clear_iscacheondiskenabledchanged() {
  if (_internal_has_iscacheondiskenabledchanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.iscacheondiskenabledchanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::IsCacheOnDiskEnabledChanged* CacheEvent::release_iscacheondiskenabledchanged() {
  // @@protoc_insertion_point(field_release:grpc.CacheEvent.isCacheOnDiskEnabledChanged)
  if (_internal_has_iscacheondiskenabledchanged()) {
    clear_has_event();
      ::grpc::IsCacheOnDiskEnabledChanged* temp = event_.iscacheondiskenabledchanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.iscacheondiskenabledchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::IsCacheOnDiskEnabledChanged& CacheEvent::_internal_iscacheondiskenabledchanged() const {
  return _internal_has_iscacheondiskenabledchanged()
      ? *event_.iscacheondiskenabledchanged_
      : reinterpret_cast< ::grpc::IsCacheOnDiskEnabledChanged&>(::grpc::_IsCacheOnDiskEnabledChanged_default_instance_);
}
inline const ::grpc::IsCacheOnDiskEnabledChanged& CacheEvent::iscacheondiskenabledchanged() const {
  // @@protoc_insertion_point(field_get:grpc.CacheEvent.isCacheOnDiskEnabledChanged)
  return _internal_iscacheondiskenabledchanged();
}
inline ::grpc::IsCacheOnDiskEnabledChanged* CacheEvent::unsafe_arena_release_iscacheondiskenabledchanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.CacheEvent.isCacheOnDiskEnabledChanged)
  if (_internal_has_iscacheondiskenabledchanged()) {
    clear_has_event();
    ::grpc::IsCacheOnDiskEnabledChanged* temp = event_.iscacheondiskenabledchanged_;
    event_.iscacheondiskenabledchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CacheEvent::unsafe_arena_set_allocated_iscacheondiskenabledchanged(::grpc::IsCacheOnDiskEnabledChanged* iscacheondiskenabledchanged) {
  clear_event();
  if (iscacheondiskenabledchanged) {
    set_has_iscacheondiskenabledchanged();
    event_.iscacheondiskenabledchanged_ = iscacheondiskenabledchanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.CacheEvent.isCacheOnDiskEnabledChanged)
}
inline ::grpc::IsCacheOnDiskEnabledChanged* CacheEvent::_internal_mutable_iscacheondiskenabledchanged() {
  if (!_internal_has_iscacheondiskenabledchanged()) {
    clear_event();
    set_has_iscacheondiskenabledchanged();
    event_.iscacheondiskenabledchanged_ = CreateMaybeMessage< ::grpc::IsCacheOnDiskEnabledChanged >(GetArenaForAllocation());
  }
  return event_.iscacheondiskenabledchanged_;
}
inline ::grpc::IsCacheOnDiskEnabledChanged* CacheEvent::mutable_iscacheondiskenabledchanged() {
  ::grpc::IsCacheOnDiskEnabledChanged* _msg = _internal_mutable_iscacheondiskenabledchanged();
  // @@protoc_insertion_point(field_mutable:grpc.CacheEvent.isCacheOnDiskEnabledChanged)
  return _msg;
}

// .grpc.DiskCachePathChanged diskCachePathChanged = 5;
inline bool CacheEvent::_internal_has_diskcachepathchanged() const {
  return event_case() == kDiskCachePathChanged;
}
inline bool CacheEvent::has_diskcachepathchanged() const {
  return _internal_has_diskcachepathchanged();
}
inline void CacheEvent::set_has_diskcachepathchanged() {
  _oneof_case_[0] = kDiskCachePathChanged;
}
inline void CacheEvent::clear_diskcachepathchanged() {
  if (_internal_has_diskcachepathchanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.diskcachepathchanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::DiskCachePathChanged* CacheEvent::release_diskcachepathchanged() {
  // @@protoc_insertion_point(field_release:grpc.CacheEvent.diskCachePathChanged)
  if (_internal_has_diskcachepathchanged()) {
    clear_has_event();
      ::grpc::DiskCachePathChanged* temp = event_.diskcachepathchanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.diskcachepathchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::DiskCachePathChanged& CacheEvent::_internal_diskcachepathchanged() const {
  return _internal_has_diskcachepathchanged()
      ? *event_.diskcachepathchanged_
      : reinterpret_cast< ::grpc::DiskCachePathChanged&>(::grpc::_DiskCachePathChanged_default_instance_);
}
inline const ::grpc::DiskCachePathChanged& CacheEvent::diskcachepathchanged() const {
  // @@protoc_insertion_point(field_get:grpc.CacheEvent.diskCachePathChanged)
  return _internal_diskcachepathchanged();
}
inline ::grpc::DiskCachePathChanged* CacheEvent::unsafe_arena_release_diskcachepathchanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.CacheEvent.diskCachePathChanged)
  if (_internal_has_diskcachepathchanged()) {
    clear_has_event();
    ::grpc::DiskCachePathChanged* temp = event_.diskcachepathchanged_;
    event_.diskcachepathchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CacheEvent::unsafe_arena_set_allocated_diskcachepathchanged(::grpc::DiskCachePathChanged* diskcachepathchanged) {
  clear_event();
  if (diskcachepathchanged) {
    set_has_diskcachepathchanged();
    event_.diskcachepathchanged_ = diskcachepathchanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.CacheEvent.diskCachePathChanged)
}
inline ::grpc::DiskCachePathChanged* CacheEvent::_internal_mutable_diskcachepathchanged() {
  if (!_internal_has_diskcachepathchanged()) {
    clear_event();
    set_has_diskcachepathchanged();
    event_.diskcachepathchanged_ = CreateMaybeMessage< ::grpc::DiskCachePathChanged >(GetArenaForAllocation());
  }
  return event_.diskcachepathchanged_;
}
inline ::grpc::DiskCachePathChanged* CacheEvent::mutable_diskcachepathchanged() {
  ::grpc::DiskCachePathChanged* _msg = _internal_mutable_diskcachepathchanged();
  // @@protoc_insertion_point(field_mutable:grpc.CacheEvent.diskCachePathChanged)
  return _msg;
}

inline bool CacheEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void CacheEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline CacheEvent::EventCase CacheEvent::event_case() const {
  return CacheEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CacheErrorEvent

// .grpc.CacheErrorType type = 1;
inline void CacheErrorEvent::clear_type() {
  type_ = 0;
}
inline ::grpc::CacheErrorType CacheErrorEvent::_internal_type() const {
  return static_cast< ::grpc::CacheErrorType >(type_);
}
inline ::grpc::CacheErrorType CacheErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.CacheErrorEvent.type)
  return _internal_type();
}
inline void CacheErrorEvent::_internal_set_type(::grpc::CacheErrorType value) {
  
  type_ = value;
}
inline void CacheErrorEvent::set_type(::grpc::CacheErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.CacheErrorEvent.type)
}

// -------------------------------------------------------------------

// CacheLocationChangeSuccessEvent

// -------------------------------------------------------------------

// ChangeLocalCacheFinishedEvent

// -------------------------------------------------------------------

// IsCacheOnDiskEnabledChanged

// bool enabled = 1;
inline void IsCacheOnDiskEnabledChanged::clear_enabled() {
  enabled_ = false;
}
inline bool IsCacheOnDiskEnabledChanged::_internal_enabled() const {
  return enabled_;
}
inline bool IsCacheOnDiskEnabledChanged::enabled() const {
  // @@protoc_insertion_point(field_get:grpc.IsCacheOnDiskEnabledChanged.enabled)
  return _internal_enabled();
}
inline void IsCacheOnDiskEnabledChanged::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void IsCacheOnDiskEnabledChanged::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:grpc.IsCacheOnDiskEnabledChanged.enabled)
}

// -------------------------------------------------------------------

// DiskCachePathChanged

// string path = 1;
inline void DiskCachePathChanged::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& DiskCachePathChanged::path() const {
  // @@protoc_insertion_point(field_get:grpc.DiskCachePathChanged.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DiskCachePathChanged::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.DiskCachePathChanged.path)
}
inline std::string* DiskCachePathChanged::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:grpc.DiskCachePathChanged.path)
  return _s;
}
inline const std::string& DiskCachePathChanged::_internal_path() const {
  return path_.Get();
}
inline void DiskCachePathChanged::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DiskCachePathChanged::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DiskCachePathChanged::release_path() {
  // @@protoc_insertion_point(field_release:grpc.DiskCachePathChanged.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DiskCachePathChanged::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.DiskCachePathChanged.path)
}

// -------------------------------------------------------------------

// MailSettingsEvent

// .grpc.MailSettingsErrorEvent error = 1;
inline bool MailSettingsEvent::_internal_has_error() const {
  return event_case() == kError;
}
inline bool MailSettingsEvent::has_error() const {
  return _internal_has_error();
}
inline void MailSettingsEvent::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void MailSettingsEvent::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.error_;
    }
    clear_has_event();
  }
}
inline ::grpc::MailSettingsErrorEvent* MailSettingsEvent::release_error() {
  // @@protoc_insertion_point(field_release:grpc.MailSettingsEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
      ::grpc::MailSettingsErrorEvent* temp = event_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::MailSettingsErrorEvent& MailSettingsEvent::_internal_error() const {
  return _internal_has_error()
      ? *event_.error_
      : reinterpret_cast< ::grpc::MailSettingsErrorEvent&>(::grpc::_MailSettingsErrorEvent_default_instance_);
}
inline const ::grpc::MailSettingsErrorEvent& MailSettingsEvent::error() const {
  // @@protoc_insertion_point(field_get:grpc.MailSettingsEvent.error)
  return _internal_error();
}
inline ::grpc::MailSettingsErrorEvent* MailSettingsEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailSettingsEvent.error)
  if (_internal_has_error()) {
    clear_has_event();
    ::grpc::MailSettingsErrorEvent* temp = event_.error_;
    event_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailSettingsEvent::unsafe_arena_set_allocated_error(::grpc::MailSettingsErrorEvent* error) {
  clear_event();
  if (error) {
    set_has_error();
    event_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailSettingsEvent.error)
}
inline ::grpc::MailSettingsErrorEvent* MailSettingsEvent::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_event();
    set_has_error();
    event_.error_ = CreateMaybeMessage< ::grpc::MailSettingsErrorEvent >(GetArenaForAllocation());
  }
  return event_.error_;
}
inline ::grpc::MailSettingsErrorEvent* MailSettingsEvent::mutable_error() {
  ::grpc::MailSettingsErrorEvent* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:grpc.MailSettingsEvent.error)
  return _msg;
}

// .grpc.UseSslForSmtpFinishedEvent useSslForSmtpFinished = 2;
inline bool MailSettingsEvent::_internal_has_usesslforsmtpfinished() const {
  return event_case() == kUseSslForSmtpFinished;
}
inline bool MailSettingsEvent::has_usesslforsmtpfinished() const {
  return _internal_has_usesslforsmtpfinished();
}
inline void MailSettingsEvent::set_has_usesslforsmtpfinished() {
  _oneof_case_[0] = kUseSslForSmtpFinished;
}
inline void MailSettingsEvent::clear_usesslforsmtpfinished() {
  if (_internal_has_usesslforsmtpfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.usesslforsmtpfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::UseSslForSmtpFinishedEvent* MailSettingsEvent::release_usesslforsmtpfinished() {
  // @@protoc_insertion_point(field_release:grpc.MailSettingsEvent.useSslForSmtpFinished)
  if (_internal_has_usesslforsmtpfinished()) {
    clear_has_event();
      ::grpc::UseSslForSmtpFinishedEvent* temp = event_.usesslforsmtpfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.usesslforsmtpfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UseSslForSmtpFinishedEvent& MailSettingsEvent::_internal_usesslforsmtpfinished() const {
  return _internal_has_usesslforsmtpfinished()
      ? *event_.usesslforsmtpfinished_
      : reinterpret_cast< ::grpc::UseSslForSmtpFinishedEvent&>(::grpc::_UseSslForSmtpFinishedEvent_default_instance_);
}
inline const ::grpc::UseSslForSmtpFinishedEvent& MailSettingsEvent::usesslforsmtpfinished() const {
  // @@protoc_insertion_point(field_get:grpc.MailSettingsEvent.useSslForSmtpFinished)
  return _internal_usesslforsmtpfinished();
}
inline ::grpc::UseSslForSmtpFinishedEvent* MailSettingsEvent::unsafe_arena_release_usesslforsmtpfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailSettingsEvent.useSslForSmtpFinished)
  if (_internal_has_usesslforsmtpfinished()) {
    clear_has_event();
    ::grpc::UseSslForSmtpFinishedEvent* temp = event_.usesslforsmtpfinished_;
    event_.usesslforsmtpfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailSettingsEvent::unsafe_arena_set_allocated_usesslforsmtpfinished(::grpc::UseSslForSmtpFinishedEvent* usesslforsmtpfinished) {
  clear_event();
  if (usesslforsmtpfinished) {
    set_has_usesslforsmtpfinished();
    event_.usesslforsmtpfinished_ = usesslforsmtpfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailSettingsEvent.useSslForSmtpFinished)
}
inline ::grpc::UseSslForSmtpFinishedEvent* MailSettingsEvent::_internal_mutable_usesslforsmtpfinished() {
  if (!_internal_has_usesslforsmtpfinished()) {
    clear_event();
    set_has_usesslforsmtpfinished();
    event_.usesslforsmtpfinished_ = CreateMaybeMessage< ::grpc::UseSslForSmtpFinishedEvent >(GetArenaForAllocation());
  }
  return event_.usesslforsmtpfinished_;
}
inline ::grpc::UseSslForSmtpFinishedEvent* MailSettingsEvent::mutable_usesslforsmtpfinished() {
  ::grpc::UseSslForSmtpFinishedEvent* _msg = _internal_mutable_usesslforsmtpfinished();
  // @@protoc_insertion_point(field_mutable:grpc.MailSettingsEvent.useSslForSmtpFinished)
  return _msg;
}

// .grpc.ChangePortsFinishedEvent changePortsFinished = 3;
inline bool MailSettingsEvent::_internal_has_changeportsfinished() const {
  return event_case() == kChangePortsFinished;
}
inline bool MailSettingsEvent::has_changeportsfinished() const {
  return _internal_has_changeportsfinished();
}
inline void MailSettingsEvent::set_has_changeportsfinished() {
  _oneof_case_[0] = kChangePortsFinished;
}
inline void MailSettingsEvent::clear_changeportsfinished() {
  if (_internal_has_changeportsfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.changeportsfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ChangePortsFinishedEvent* MailSettingsEvent::release_changeportsfinished() {
  // @@protoc_insertion_point(field_release:grpc.MailSettingsEvent.changePortsFinished)
  if (_internal_has_changeportsfinished()) {
    clear_has_event();
      ::grpc::ChangePortsFinishedEvent* temp = event_.changeportsfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.changeportsfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ChangePortsFinishedEvent& MailSettingsEvent::_internal_changeportsfinished() const {
  return _internal_has_changeportsfinished()
      ? *event_.changeportsfinished_
      : reinterpret_cast< ::grpc::ChangePortsFinishedEvent&>(::grpc::_ChangePortsFinishedEvent_default_instance_);
}
inline const ::grpc::ChangePortsFinishedEvent& MailSettingsEvent::changeportsfinished() const {
  // @@protoc_insertion_point(field_get:grpc.MailSettingsEvent.changePortsFinished)
  return _internal_changeportsfinished();
}
inline ::grpc::ChangePortsFinishedEvent* MailSettingsEvent::unsafe_arena_release_changeportsfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailSettingsEvent.changePortsFinished)
  if (_internal_has_changeportsfinished()) {
    clear_has_event();
    ::grpc::ChangePortsFinishedEvent* temp = event_.changeportsfinished_;
    event_.changeportsfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailSettingsEvent::unsafe_arena_set_allocated_changeportsfinished(::grpc::ChangePortsFinishedEvent* changeportsfinished) {
  clear_event();
  if (changeportsfinished) {
    set_has_changeportsfinished();
    event_.changeportsfinished_ = changeportsfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailSettingsEvent.changePortsFinished)
}
inline ::grpc::ChangePortsFinishedEvent* MailSettingsEvent::_internal_mutable_changeportsfinished() {
  if (!_internal_has_changeportsfinished()) {
    clear_event();
    set_has_changeportsfinished();
    event_.changeportsfinished_ = CreateMaybeMessage< ::grpc::ChangePortsFinishedEvent >(GetArenaForAllocation());
  }
  return event_.changeportsfinished_;
}
inline ::grpc::ChangePortsFinishedEvent* MailSettingsEvent::mutable_changeportsfinished() {
  ::grpc::ChangePortsFinishedEvent* _msg = _internal_mutable_changeportsfinished();
  // @@protoc_insertion_point(field_mutable:grpc.MailSettingsEvent.changePortsFinished)
  return _msg;
}

inline bool MailSettingsEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void MailSettingsEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline MailSettingsEvent::EventCase MailSettingsEvent::event_case() const {
  return MailSettingsEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MailSettingsErrorEvent

// .grpc.MailSettingsErrorType type = 1;
inline void MailSettingsErrorEvent::clear_type() {
  type_ = 0;
}
inline ::grpc::MailSettingsErrorType MailSettingsErrorEvent::_internal_type() const {
  return static_cast< ::grpc::MailSettingsErrorType >(type_);
}
inline ::grpc::MailSettingsErrorType MailSettingsErrorEvent::type() const {
  // @@protoc_insertion_point(field_get:grpc.MailSettingsErrorEvent.type)
  return _internal_type();
}
inline void MailSettingsErrorEvent::_internal_set_type(::grpc::MailSettingsErrorType value) {
  
  type_ = value;
}
inline void MailSettingsErrorEvent::set_type(::grpc::MailSettingsErrorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:grpc.MailSettingsErrorEvent.type)
}

// -------------------------------------------------------------------

// UseSslForSmtpFinishedEvent

// -------------------------------------------------------------------

// ChangePortsFinishedEvent

// -------------------------------------------------------------------

// KeychainEvent

// .grpc.ChangeKeychainFinishedEvent changeKeychainFinished = 1;
inline bool KeychainEvent::_internal_has_changekeychainfinished() const {
  return event_case() == kChangeKeychainFinished;
}
inline bool KeychainEvent::has_changekeychainfinished() const {
  return _internal_has_changekeychainfinished();
}
inline void KeychainEvent::set_has_changekeychainfinished() {
  _oneof_case_[0] = kChangeKeychainFinished;
}
inline void KeychainEvent::clear_changekeychainfinished() {
  if (_internal_has_changekeychainfinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.changekeychainfinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::release_changekeychainfinished() {
  // @@protoc_insertion_point(field_release:grpc.KeychainEvent.changeKeychainFinished)
  if (_internal_has_changekeychainfinished()) {
    clear_has_event();
      ::grpc::ChangeKeychainFinishedEvent* temp = event_.changekeychainfinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.changekeychainfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ChangeKeychainFinishedEvent& KeychainEvent::_internal_changekeychainfinished() const {
  return _internal_has_changekeychainfinished()
      ? *event_.changekeychainfinished_
      : reinterpret_cast< ::grpc::ChangeKeychainFinishedEvent&>(::grpc::_ChangeKeychainFinishedEvent_default_instance_);
}
inline const ::grpc::ChangeKeychainFinishedEvent& KeychainEvent::changekeychainfinished() const {
  // @@protoc_insertion_point(field_get:grpc.KeychainEvent.changeKeychainFinished)
  return _internal_changekeychainfinished();
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::unsafe_arena_release_changekeychainfinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.KeychainEvent.changeKeychainFinished)
  if (_internal_has_changekeychainfinished()) {
    clear_has_event();
    ::grpc::ChangeKeychainFinishedEvent* temp = event_.changekeychainfinished_;
    event_.changekeychainfinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KeychainEvent::unsafe_arena_set_allocated_changekeychainfinished(::grpc::ChangeKeychainFinishedEvent* changekeychainfinished) {
  clear_event();
  if (changekeychainfinished) {
    set_has_changekeychainfinished();
    event_.changekeychainfinished_ = changekeychainfinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.KeychainEvent.changeKeychainFinished)
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::_internal_mutable_changekeychainfinished() {
  if (!_internal_has_changekeychainfinished()) {
    clear_event();
    set_has_changekeychainfinished();
    event_.changekeychainfinished_ = CreateMaybeMessage< ::grpc::ChangeKeychainFinishedEvent >(GetArenaForAllocation());
  }
  return event_.changekeychainfinished_;
}
inline ::grpc::ChangeKeychainFinishedEvent* KeychainEvent::mutable_changekeychainfinished() {
  ::grpc::ChangeKeychainFinishedEvent* _msg = _internal_mutable_changekeychainfinished();
  // @@protoc_insertion_point(field_mutable:grpc.KeychainEvent.changeKeychainFinished)
  return _msg;
}

// .grpc.HasNoKeychainEvent hasNoKeychain = 2;
inline bool KeychainEvent::_internal_has_hasnokeychain() const {
  return event_case() == kHasNoKeychain;
}
inline bool KeychainEvent::has_hasnokeychain() const {
  return _internal_has_hasnokeychain();
}
inline void KeychainEvent::set_has_hasnokeychain() {
  _oneof_case_[0] = kHasNoKeychain;
}
inline void KeychainEvent::clear_hasnokeychain() {
  if (_internal_has_hasnokeychain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.hasnokeychain_;
    }
    clear_has_event();
  }
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::release_hasnokeychain() {
  // @@protoc_insertion_point(field_release:grpc.KeychainEvent.hasNoKeychain)
  if (_internal_has_hasnokeychain()) {
    clear_has_event();
      ::grpc::HasNoKeychainEvent* temp = event_.hasnokeychain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.hasnokeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::HasNoKeychainEvent& KeychainEvent::_internal_hasnokeychain() const {
  return _internal_has_hasnokeychain()
      ? *event_.hasnokeychain_
      : reinterpret_cast< ::grpc::HasNoKeychainEvent&>(::grpc::_HasNoKeychainEvent_default_instance_);
}
inline const ::grpc::HasNoKeychainEvent& KeychainEvent::hasnokeychain() const {
  // @@protoc_insertion_point(field_get:grpc.KeychainEvent.hasNoKeychain)
  return _internal_hasnokeychain();
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::unsafe_arena_release_hasnokeychain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.KeychainEvent.hasNoKeychain)
  if (_internal_has_hasnokeychain()) {
    clear_has_event();
    ::grpc::HasNoKeychainEvent* temp = event_.hasnokeychain_;
    event_.hasnokeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KeychainEvent::unsafe_arena_set_allocated_hasnokeychain(::grpc::HasNoKeychainEvent* hasnokeychain) {
  clear_event();
  if (hasnokeychain) {
    set_has_hasnokeychain();
    event_.hasnokeychain_ = hasnokeychain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.KeychainEvent.hasNoKeychain)
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::_internal_mutable_hasnokeychain() {
  if (!_internal_has_hasnokeychain()) {
    clear_event();
    set_has_hasnokeychain();
    event_.hasnokeychain_ = CreateMaybeMessage< ::grpc::HasNoKeychainEvent >(GetArenaForAllocation());
  }
  return event_.hasnokeychain_;
}
inline ::grpc::HasNoKeychainEvent* KeychainEvent::mutable_hasnokeychain() {
  ::grpc::HasNoKeychainEvent* _msg = _internal_mutable_hasnokeychain();
  // @@protoc_insertion_point(field_mutable:grpc.KeychainEvent.hasNoKeychain)
  return _msg;
}

// .grpc.RebuildKeychainEvent rebuildKeychain = 3;
inline bool KeychainEvent::_internal_has_rebuildkeychain() const {
  return event_case() == kRebuildKeychain;
}
inline bool KeychainEvent::has_rebuildkeychain() const {
  return _internal_has_rebuildkeychain();
}
inline void KeychainEvent::set_has_rebuildkeychain() {
  _oneof_case_[0] = kRebuildKeychain;
}
inline void KeychainEvent::clear_rebuildkeychain() {
  if (_internal_has_rebuildkeychain()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.rebuildkeychain_;
    }
    clear_has_event();
  }
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::release_rebuildkeychain() {
  // @@protoc_insertion_point(field_release:grpc.KeychainEvent.rebuildKeychain)
  if (_internal_has_rebuildkeychain()) {
    clear_has_event();
      ::grpc::RebuildKeychainEvent* temp = event_.rebuildkeychain_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.rebuildkeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::RebuildKeychainEvent& KeychainEvent::_internal_rebuildkeychain() const {
  return _internal_has_rebuildkeychain()
      ? *event_.rebuildkeychain_
      : reinterpret_cast< ::grpc::RebuildKeychainEvent&>(::grpc::_RebuildKeychainEvent_default_instance_);
}
inline const ::grpc::RebuildKeychainEvent& KeychainEvent::rebuildkeychain() const {
  // @@protoc_insertion_point(field_get:grpc.KeychainEvent.rebuildKeychain)
  return _internal_rebuildkeychain();
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::unsafe_arena_release_rebuildkeychain() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.KeychainEvent.rebuildKeychain)
  if (_internal_has_rebuildkeychain()) {
    clear_has_event();
    ::grpc::RebuildKeychainEvent* temp = event_.rebuildkeychain_;
    event_.rebuildkeychain_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void KeychainEvent::unsafe_arena_set_allocated_rebuildkeychain(::grpc::RebuildKeychainEvent* rebuildkeychain) {
  clear_event();
  if (rebuildkeychain) {
    set_has_rebuildkeychain();
    event_.rebuildkeychain_ = rebuildkeychain;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.KeychainEvent.rebuildKeychain)
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::_internal_mutable_rebuildkeychain() {
  if (!_internal_has_rebuildkeychain()) {
    clear_event();
    set_has_rebuildkeychain();
    event_.rebuildkeychain_ = CreateMaybeMessage< ::grpc::RebuildKeychainEvent >(GetArenaForAllocation());
  }
  return event_.rebuildkeychain_;
}
inline ::grpc::RebuildKeychainEvent* KeychainEvent::mutable_rebuildkeychain() {
  ::grpc::RebuildKeychainEvent* _msg = _internal_mutable_rebuildkeychain();
  // @@protoc_insertion_point(field_mutable:grpc.KeychainEvent.rebuildKeychain)
  return _msg;
}

inline bool KeychainEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void KeychainEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline KeychainEvent::EventCase KeychainEvent::event_case() const {
  return KeychainEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ChangeKeychainFinishedEvent

// -------------------------------------------------------------------

// HasNoKeychainEvent

// -------------------------------------------------------------------

// RebuildKeychainEvent

// -------------------------------------------------------------------

// MailEvent

// .grpc.NoActiveKeyForRecipientEvent noActiveKeyForRecipientEvent = 1;
inline bool MailEvent::_internal_has_noactivekeyforrecipientevent() const {
  return event_case() == kNoActiveKeyForRecipientEvent;
}
inline bool MailEvent::has_noactivekeyforrecipientevent() const {
  return _internal_has_noactivekeyforrecipientevent();
}
inline void MailEvent::set_has_noactivekeyforrecipientevent() {
  _oneof_case_[0] = kNoActiveKeyForRecipientEvent;
}
inline void MailEvent::clear_noactivekeyforrecipientevent() {
  if (_internal_has_noactivekeyforrecipientevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.noactivekeyforrecipientevent_;
    }
    clear_has_event();
  }
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::release_noactivekeyforrecipientevent() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.noActiveKeyForRecipientEvent)
  if (_internal_has_noactivekeyforrecipientevent()) {
    clear_has_event();
      ::grpc::NoActiveKeyForRecipientEvent* temp = event_.noactivekeyforrecipientevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.noactivekeyforrecipientevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::NoActiveKeyForRecipientEvent& MailEvent::_internal_noactivekeyforrecipientevent() const {
  return _internal_has_noactivekeyforrecipientevent()
      ? *event_.noactivekeyforrecipientevent_
      : reinterpret_cast< ::grpc::NoActiveKeyForRecipientEvent&>(::grpc::_NoActiveKeyForRecipientEvent_default_instance_);
}
inline const ::grpc::NoActiveKeyForRecipientEvent& MailEvent::noactivekeyforrecipientevent() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.noActiveKeyForRecipientEvent)
  return _internal_noactivekeyforrecipientevent();
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::unsafe_arena_release_noactivekeyforrecipientevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.noActiveKeyForRecipientEvent)
  if (_internal_has_noactivekeyforrecipientevent()) {
    clear_has_event();
    ::grpc::NoActiveKeyForRecipientEvent* temp = event_.noactivekeyforrecipientevent_;
    event_.noactivekeyforrecipientevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_noactivekeyforrecipientevent(::grpc::NoActiveKeyForRecipientEvent* noactivekeyforrecipientevent) {
  clear_event();
  if (noactivekeyforrecipientevent) {
    set_has_noactivekeyforrecipientevent();
    event_.noactivekeyforrecipientevent_ = noactivekeyforrecipientevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.noActiveKeyForRecipientEvent)
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::_internal_mutable_noactivekeyforrecipientevent() {
  if (!_internal_has_noactivekeyforrecipientevent()) {
    clear_event();
    set_has_noactivekeyforrecipientevent();
    event_.noactivekeyforrecipientevent_ = CreateMaybeMessage< ::grpc::NoActiveKeyForRecipientEvent >(GetArenaForAllocation());
  }
  return event_.noactivekeyforrecipientevent_;
}
inline ::grpc::NoActiveKeyForRecipientEvent* MailEvent::mutable_noactivekeyforrecipientevent() {
  ::grpc::NoActiveKeyForRecipientEvent* _msg = _internal_mutable_noactivekeyforrecipientevent();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.noActiveKeyForRecipientEvent)
  return _msg;
}

// .grpc.AddressChangedEvent addressChanged = 2;
inline bool MailEvent::_internal_has_addresschanged() const {
  return event_case() == kAddressChanged;
}
inline bool MailEvent::has_addresschanged() const {
  return _internal_has_addresschanged();
}
inline void MailEvent::set_has_addresschanged() {
  _oneof_case_[0] = kAddressChanged;
}
inline void MailEvent::clear_addresschanged() {
  if (_internal_has_addresschanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.addresschanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::AddressChangedEvent* MailEvent::release_addresschanged() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.addressChanged)
  if (_internal_has_addresschanged()) {
    clear_has_event();
      ::grpc::AddressChangedEvent* temp = event_.addresschanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.addresschanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::AddressChangedEvent& MailEvent::_internal_addresschanged() const {
  return _internal_has_addresschanged()
      ? *event_.addresschanged_
      : reinterpret_cast< ::grpc::AddressChangedEvent&>(::grpc::_AddressChangedEvent_default_instance_);
}
inline const ::grpc::AddressChangedEvent& MailEvent::addresschanged() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.addressChanged)
  return _internal_addresschanged();
}
inline ::grpc::AddressChangedEvent* MailEvent::unsafe_arena_release_addresschanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.addressChanged)
  if (_internal_has_addresschanged()) {
    clear_has_event();
    ::grpc::AddressChangedEvent* temp = event_.addresschanged_;
    event_.addresschanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_addresschanged(::grpc::AddressChangedEvent* addresschanged) {
  clear_event();
  if (addresschanged) {
    set_has_addresschanged();
    event_.addresschanged_ = addresschanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.addressChanged)
}
inline ::grpc::AddressChangedEvent* MailEvent::_internal_mutable_addresschanged() {
  if (!_internal_has_addresschanged()) {
    clear_event();
    set_has_addresschanged();
    event_.addresschanged_ = CreateMaybeMessage< ::grpc::AddressChangedEvent >(GetArenaForAllocation());
  }
  return event_.addresschanged_;
}
inline ::grpc::AddressChangedEvent* MailEvent::mutable_addresschanged() {
  ::grpc::AddressChangedEvent* _msg = _internal_mutable_addresschanged();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.addressChanged)
  return _msg;
}

// .grpc.AddressChangedLogoutEvent addressChangedLogout = 3;
inline bool MailEvent::_internal_has_addresschangedlogout() const {
  return event_case() == kAddressChangedLogout;
}
inline bool MailEvent::has_addresschangedlogout() const {
  return _internal_has_addresschangedlogout();
}
inline void MailEvent::set_has_addresschangedlogout() {
  _oneof_case_[0] = kAddressChangedLogout;
}
inline void MailEvent::clear_addresschangedlogout() {
  if (_internal_has_addresschangedlogout()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.addresschangedlogout_;
    }
    clear_has_event();
  }
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::release_addresschangedlogout() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.addressChangedLogout)
  if (_internal_has_addresschangedlogout()) {
    clear_has_event();
      ::grpc::AddressChangedLogoutEvent* temp = event_.addresschangedlogout_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.addresschangedlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::AddressChangedLogoutEvent& MailEvent::_internal_addresschangedlogout() const {
  return _internal_has_addresschangedlogout()
      ? *event_.addresschangedlogout_
      : reinterpret_cast< ::grpc::AddressChangedLogoutEvent&>(::grpc::_AddressChangedLogoutEvent_default_instance_);
}
inline const ::grpc::AddressChangedLogoutEvent& MailEvent::addresschangedlogout() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.addressChangedLogout)
  return _internal_addresschangedlogout();
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::unsafe_arena_release_addresschangedlogout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.addressChangedLogout)
  if (_internal_has_addresschangedlogout()) {
    clear_has_event();
    ::grpc::AddressChangedLogoutEvent* temp = event_.addresschangedlogout_;
    event_.addresschangedlogout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_addresschangedlogout(::grpc::AddressChangedLogoutEvent* addresschangedlogout) {
  clear_event();
  if (addresschangedlogout) {
    set_has_addresschangedlogout();
    event_.addresschangedlogout_ = addresschangedlogout;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.addressChangedLogout)
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::_internal_mutable_addresschangedlogout() {
  if (!_internal_has_addresschangedlogout()) {
    clear_event();
    set_has_addresschangedlogout();
    event_.addresschangedlogout_ = CreateMaybeMessage< ::grpc::AddressChangedLogoutEvent >(GetArenaForAllocation());
  }
  return event_.addresschangedlogout_;
}
inline ::grpc::AddressChangedLogoutEvent* MailEvent::mutable_addresschangedlogout() {
  ::grpc::AddressChangedLogoutEvent* _msg = _internal_mutable_addresschangedlogout();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.addressChangedLogout)
  return _msg;
}

// .grpc.ApiCertIssueEvent apiCertIssue = 6;
inline bool MailEvent::_internal_has_apicertissue() const {
  return event_case() == kApiCertIssue;
}
inline bool MailEvent::has_apicertissue() const {
  return _internal_has_apicertissue();
}
inline void MailEvent::set_has_apicertissue() {
  _oneof_case_[0] = kApiCertIssue;
}
inline void MailEvent::clear_apicertissue() {
  if (_internal_has_apicertissue()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.apicertissue_;
    }
    clear_has_event();
  }
}
inline ::grpc::ApiCertIssueEvent* MailEvent::release_apicertissue() {
  // @@protoc_insertion_point(field_release:grpc.MailEvent.apiCertIssue)
  if (_internal_has_apicertissue()) {
    clear_has_event();
      ::grpc::ApiCertIssueEvent* temp = event_.apicertissue_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.apicertissue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ApiCertIssueEvent& MailEvent::_internal_apicertissue() const {
  return _internal_has_apicertissue()
      ? *event_.apicertissue_
      : reinterpret_cast< ::grpc::ApiCertIssueEvent&>(::grpc::_ApiCertIssueEvent_default_instance_);
}
inline const ::grpc::ApiCertIssueEvent& MailEvent::apicertissue() const {
  // @@protoc_insertion_point(field_get:grpc.MailEvent.apiCertIssue)
  return _internal_apicertissue();
}
inline ::grpc::ApiCertIssueEvent* MailEvent::unsafe_arena_release_apicertissue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.MailEvent.apiCertIssue)
  if (_internal_has_apicertissue()) {
    clear_has_event();
    ::grpc::ApiCertIssueEvent* temp = event_.apicertissue_;
    event_.apicertissue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MailEvent::unsafe_arena_set_allocated_apicertissue(::grpc::ApiCertIssueEvent* apicertissue) {
  clear_event();
  if (apicertissue) {
    set_has_apicertissue();
    event_.apicertissue_ = apicertissue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.MailEvent.apiCertIssue)
}
inline ::grpc::ApiCertIssueEvent* MailEvent::_internal_mutable_apicertissue() {
  if (!_internal_has_apicertissue()) {
    clear_event();
    set_has_apicertissue();
    event_.apicertissue_ = CreateMaybeMessage< ::grpc::ApiCertIssueEvent >(GetArenaForAllocation());
  }
  return event_.apicertissue_;
}
inline ::grpc::ApiCertIssueEvent* MailEvent::mutable_apicertissue() {
  ::grpc::ApiCertIssueEvent* _msg = _internal_mutable_apicertissue();
  // @@protoc_insertion_point(field_mutable:grpc.MailEvent.apiCertIssue)
  return _msg;
}

inline bool MailEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void MailEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline MailEvent::EventCase MailEvent::event_case() const {
  return MailEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NoActiveKeyForRecipientEvent

// string email = 1;
inline void NoActiveKeyForRecipientEvent::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& NoActiveKeyForRecipientEvent::email() const {
  // @@protoc_insertion_point(field_get:grpc.NoActiveKeyForRecipientEvent.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoActiveKeyForRecipientEvent::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.NoActiveKeyForRecipientEvent.email)
}
inline std::string* NoActiveKeyForRecipientEvent::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:grpc.NoActiveKeyForRecipientEvent.email)
  return _s;
}
inline const std::string& NoActiveKeyForRecipientEvent::_internal_email() const {
  return email_.Get();
}
inline void NoActiveKeyForRecipientEvent::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NoActiveKeyForRecipientEvent::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NoActiveKeyForRecipientEvent::release_email() {
  // @@protoc_insertion_point(field_release:grpc.NoActiveKeyForRecipientEvent.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NoActiveKeyForRecipientEvent::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.NoActiveKeyForRecipientEvent.email)
}

// -------------------------------------------------------------------

// AddressChangedEvent

// string address = 1;
inline void AddressChangedEvent::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& AddressChangedEvent::address() const {
  // @@protoc_insertion_point(field_get:grpc.AddressChangedEvent.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddressChangedEvent::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.AddressChangedEvent.address)
}
inline std::string* AddressChangedEvent::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.AddressChangedEvent.address)
  return _s;
}
inline const std::string& AddressChangedEvent::_internal_address() const {
  return address_.Get();
}
inline void AddressChangedEvent::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddressChangedEvent::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddressChangedEvent::release_address() {
  // @@protoc_insertion_point(field_release:grpc.AddressChangedEvent.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddressChangedEvent::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.AddressChangedEvent.address)
}

// -------------------------------------------------------------------

// AddressChangedLogoutEvent

// string address = 1;
inline void AddressChangedLogoutEvent::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& AddressChangedLogoutEvent::address() const {
  // @@protoc_insertion_point(field_get:grpc.AddressChangedLogoutEvent.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddressChangedLogoutEvent::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.AddressChangedLogoutEvent.address)
}
inline std::string* AddressChangedLogoutEvent::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:grpc.AddressChangedLogoutEvent.address)
  return _s;
}
inline const std::string& AddressChangedLogoutEvent::_internal_address() const {
  return address_.Get();
}
inline void AddressChangedLogoutEvent::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddressChangedLogoutEvent::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddressChangedLogoutEvent::release_address() {
  // @@protoc_insertion_point(field_release:grpc.AddressChangedLogoutEvent.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddressChangedLogoutEvent::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.AddressChangedLogoutEvent.address)
}

// -------------------------------------------------------------------

// ApiCertIssueEvent

// -------------------------------------------------------------------

// UserEvent

// .grpc.ToggleSplitModeFinishedEvent toggleSplitModeFinished = 1;
inline bool UserEvent::_internal_has_togglesplitmodefinished() const {
  return event_case() == kToggleSplitModeFinished;
}
inline bool UserEvent::has_togglesplitmodefinished() const {
  return _internal_has_togglesplitmodefinished();
}
inline void UserEvent::set_has_togglesplitmodefinished() {
  _oneof_case_[0] = kToggleSplitModeFinished;
}
inline void UserEvent::clear_togglesplitmodefinished() {
  if (_internal_has_togglesplitmodefinished()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.togglesplitmodefinished_;
    }
    clear_has_event();
  }
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::release_togglesplitmodefinished() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.toggleSplitModeFinished)
  if (_internal_has_togglesplitmodefinished()) {
    clear_has_event();
      ::grpc::ToggleSplitModeFinishedEvent* temp = event_.togglesplitmodefinished_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.togglesplitmodefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::ToggleSplitModeFinishedEvent& UserEvent::_internal_togglesplitmodefinished() const {
  return _internal_has_togglesplitmodefinished()
      ? *event_.togglesplitmodefinished_
      : reinterpret_cast< ::grpc::ToggleSplitModeFinishedEvent&>(::grpc::_ToggleSplitModeFinishedEvent_default_instance_);
}
inline const ::grpc::ToggleSplitModeFinishedEvent& UserEvent::togglesplitmodefinished() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.toggleSplitModeFinished)
  return _internal_togglesplitmodefinished();
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::unsafe_arena_release_togglesplitmodefinished() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.toggleSplitModeFinished)
  if (_internal_has_togglesplitmodefinished()) {
    clear_has_event();
    ::grpc::ToggleSplitModeFinishedEvent* temp = event_.togglesplitmodefinished_;
    event_.togglesplitmodefinished_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_togglesplitmodefinished(::grpc::ToggleSplitModeFinishedEvent* togglesplitmodefinished) {
  clear_event();
  if (togglesplitmodefinished) {
    set_has_togglesplitmodefinished();
    event_.togglesplitmodefinished_ = togglesplitmodefinished;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.toggleSplitModeFinished)
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::_internal_mutable_togglesplitmodefinished() {
  if (!_internal_has_togglesplitmodefinished()) {
    clear_event();
    set_has_togglesplitmodefinished();
    event_.togglesplitmodefinished_ = CreateMaybeMessage< ::grpc::ToggleSplitModeFinishedEvent >(GetArenaForAllocation());
  }
  return event_.togglesplitmodefinished_;
}
inline ::grpc::ToggleSplitModeFinishedEvent* UserEvent::mutable_togglesplitmodefinished() {
  ::grpc::ToggleSplitModeFinishedEvent* _msg = _internal_mutable_togglesplitmodefinished();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.toggleSplitModeFinished)
  return _msg;
}

// .grpc.UserDisconnectedEvent userDisconnected = 2;
inline bool UserEvent::_internal_has_userdisconnected() const {
  return event_case() == kUserDisconnected;
}
inline bool UserEvent::has_userdisconnected() const {
  return _internal_has_userdisconnected();
}
inline void UserEvent::set_has_userdisconnected() {
  _oneof_case_[0] = kUserDisconnected;
}
inline void UserEvent::clear_userdisconnected() {
  if (_internal_has_userdisconnected()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.userdisconnected_;
    }
    clear_has_event();
  }
}
inline ::grpc::UserDisconnectedEvent* UserEvent::release_userdisconnected() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.userDisconnected)
  if (_internal_has_userdisconnected()) {
    clear_has_event();
      ::grpc::UserDisconnectedEvent* temp = event_.userdisconnected_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.userdisconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UserDisconnectedEvent& UserEvent::_internal_userdisconnected() const {
  return _internal_has_userdisconnected()
      ? *event_.userdisconnected_
      : reinterpret_cast< ::grpc::UserDisconnectedEvent&>(::grpc::_UserDisconnectedEvent_default_instance_);
}
inline const ::grpc::UserDisconnectedEvent& UserEvent::userdisconnected() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.userDisconnected)
  return _internal_userdisconnected();
}
inline ::grpc::UserDisconnectedEvent* UserEvent::unsafe_arena_release_userdisconnected() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.userDisconnected)
  if (_internal_has_userdisconnected()) {
    clear_has_event();
    ::grpc::UserDisconnectedEvent* temp = event_.userdisconnected_;
    event_.userdisconnected_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_userdisconnected(::grpc::UserDisconnectedEvent* userdisconnected) {
  clear_event();
  if (userdisconnected) {
    set_has_userdisconnected();
    event_.userdisconnected_ = userdisconnected;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.userDisconnected)
}
inline ::grpc::UserDisconnectedEvent* UserEvent::_internal_mutable_userdisconnected() {
  if (!_internal_has_userdisconnected()) {
    clear_event();
    set_has_userdisconnected();
    event_.userdisconnected_ = CreateMaybeMessage< ::grpc::UserDisconnectedEvent >(GetArenaForAllocation());
  }
  return event_.userdisconnected_;
}
inline ::grpc::UserDisconnectedEvent* UserEvent::mutable_userdisconnected() {
  ::grpc::UserDisconnectedEvent* _msg = _internal_mutable_userdisconnected();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.userDisconnected)
  return _msg;
}

// .grpc.UserChangedEvent userChanged = 3;
inline bool UserEvent::_internal_has_userchanged() const {
  return event_case() == kUserChanged;
}
inline bool UserEvent::has_userchanged() const {
  return _internal_has_userchanged();
}
inline void UserEvent::set_has_userchanged() {
  _oneof_case_[0] = kUserChanged;
}
inline void UserEvent::clear_userchanged() {
  if (_internal_has_userchanged()) {
    if (GetArenaForAllocation() == nullptr) {
      delete event_.userchanged_;
    }
    clear_has_event();
  }
}
inline ::grpc::UserChangedEvent* UserEvent::release_userchanged() {
  // @@protoc_insertion_point(field_release:grpc.UserEvent.userChanged)
  if (_internal_has_userchanged()) {
    clear_has_event();
      ::grpc::UserChangedEvent* temp = event_.userchanged_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    event_.userchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::grpc::UserChangedEvent& UserEvent::_internal_userchanged() const {
  return _internal_has_userchanged()
      ? *event_.userchanged_
      : reinterpret_cast< ::grpc::UserChangedEvent&>(::grpc::_UserChangedEvent_default_instance_);
}
inline const ::grpc::UserChangedEvent& UserEvent::userchanged() const {
  // @@protoc_insertion_point(field_get:grpc.UserEvent.userChanged)
  return _internal_userchanged();
}
inline ::grpc::UserChangedEvent* UserEvent::unsafe_arena_release_userchanged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:grpc.UserEvent.userChanged)
  if (_internal_has_userchanged()) {
    clear_has_event();
    ::grpc::UserChangedEvent* temp = event_.userchanged_;
    event_.userchanged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UserEvent::unsafe_arena_set_allocated_userchanged(::grpc::UserChangedEvent* userchanged) {
  clear_event();
  if (userchanged) {
    set_has_userchanged();
    event_.userchanged_ = userchanged;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:grpc.UserEvent.userChanged)
}
inline ::grpc::UserChangedEvent* UserEvent::_internal_mutable_userchanged() {
  if (!_internal_has_userchanged()) {
    clear_event();
    set_has_userchanged();
    event_.userchanged_ = CreateMaybeMessage< ::grpc::UserChangedEvent >(GetArenaForAllocation());
  }
  return event_.userchanged_;
}
inline ::grpc::UserChangedEvent* UserEvent::mutable_userchanged() {
  ::grpc::UserChangedEvent* _msg = _internal_mutable_userchanged();
  // @@protoc_insertion_point(field_mutable:grpc.UserEvent.userChanged)
  return _msg;
}

inline bool UserEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void UserEvent::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline UserEvent::EventCase UserEvent::event_case() const {
  return UserEvent::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ToggleSplitModeFinishedEvent

// string userID = 1;
inline void ToggleSplitModeFinishedEvent::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& ToggleSplitModeFinishedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.ToggleSplitModeFinishedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ToggleSplitModeFinishedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.ToggleSplitModeFinishedEvent.userID)
}
inline std::string* ToggleSplitModeFinishedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.ToggleSplitModeFinishedEvent.userID)
  return _s;
}
inline const std::string& ToggleSplitModeFinishedEvent::_internal_userid() const {
  return userid_.Get();
}
inline void ToggleSplitModeFinishedEvent::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ToggleSplitModeFinishedEvent::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ToggleSplitModeFinishedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.ToggleSplitModeFinishedEvent.userID)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ToggleSplitModeFinishedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.ToggleSplitModeFinishedEvent.userID)
}

// -------------------------------------------------------------------

// UserDisconnectedEvent

// string username = 1;
inline void UserDisconnectedEvent::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& UserDisconnectedEvent::username() const {
  // @@protoc_insertion_point(field_get:grpc.UserDisconnectedEvent.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserDisconnectedEvent::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserDisconnectedEvent.username)
}
inline std::string* UserDisconnectedEvent::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:grpc.UserDisconnectedEvent.username)
  return _s;
}
inline const std::string& UserDisconnectedEvent::_internal_username() const {
  return username_.Get();
}
inline void UserDisconnectedEvent::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserDisconnectedEvent::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserDisconnectedEvent::release_username() {
  // @@protoc_insertion_point(field_release:grpc.UserDisconnectedEvent.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserDisconnectedEvent::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserDisconnectedEvent.username)
}

// -------------------------------------------------------------------

// UserChangedEvent

// string userID = 1;
inline void UserChangedEvent::clear_userid() {
  userid_.ClearToEmpty();
}
inline const std::string& UserChangedEvent::userid() const {
  // @@protoc_insertion_point(field_get:grpc.UserChangedEvent.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserChangedEvent::set_userid(ArgT0&& arg0, ArgT... args) {
 
 userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpc.UserChangedEvent.userID)
}
inline std::string* UserChangedEvent::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:grpc.UserChangedEvent.userID)
  return _s;
}
inline const std::string& UserChangedEvent::_internal_userid() const {
  return userid_.Get();
}
inline void UserChangedEvent::_internal_set_userid(const std::string& value) {
  
  userid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserChangedEvent::_internal_mutable_userid() {
  
  return userid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserChangedEvent::release_userid() {
  // @@protoc_insertion_point(field_release:grpc.UserChangedEvent.userID)
  return userid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserChangedEvent::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  userid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), userid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (userid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    userid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpc.UserChangedEvent.userID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::grpc::LoginErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::LoginErrorType>() {
  return ::grpc::LoginErrorType_descriptor();
}
template <> struct is_proto_enum< ::grpc::UpdateErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::UpdateErrorType>() {
  return ::grpc::UpdateErrorType_descriptor();
}
template <> struct is_proto_enum< ::grpc::CacheErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::CacheErrorType>() {
  return ::grpc::CacheErrorType_descriptor();
}
template <> struct is_proto_enum< ::grpc::MailSettingsErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::grpc::MailSettingsErrorType>() {
  return ::grpc::MailSettingsErrorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bridge_2eproto
